Module_Interface(3)        Erlang Module Definition        Module_Interface(3)



NNAAMMEE
       Module_Interface - Orber generated stubs/skeletons.

DDEESSCCRRIIPPTTIIOONN
       This module contains the stub/skeleton functions generated by IC.

       Starting a Orber server can be done in three ways:

         * Normal - when the server dies Orber forgets all knowledge of the
           server.

         * Supervisor child - adding the configuration parameter _{_s_u_p___c_h_i_l_d_,
           _t_r_u_e_} the _o_e___c_r_e_a_t_e___l_i_n_k_/_2 function returns _{_o_k_, _P_i_d_, _O_b_j_R_e_f_} which
           can be handled by the application _s_u_p_e_r_v_i_s_o_r_/_s_t_d_l_i_b_-_1_._7 or later.

         * Persistent object reference - adding the configuration parameters
           _{_p_e_r_s_i_s_t_e_n_t_, _t_r_u_e_} and _{_r_e_g_n_a_m_e_, _{_g_l_o_b_a_l_, _t_e_r_m_(_)_}_} Orber will
           remember the object reference until the server terminates with
           reason _n_o_r_m_a_l or _s_h_u_t_d_o_w_n. Hence, if the server is started as a
           _t_r_a_n_s_i_e_n_t supervisor child we do not receive a 'OBJECT_NOT_EXIST'
           exception when it has crashed and is being restarted.

       The Orber stub can be used to start a _p_s_e_u_d_o _o_b_j_e_c_t, which will create
       a non-server implementation. A pseudo object introduce some
       limitations:

         * The functions _o_e___c_r_e_a_t_e___l_i_n_k_/_2 is equal to _o_e___c_r_e_a_t_e_/_2, i.e., no
           link can or will be created.

         * The _B_I_F_:_s _s_e_l_f_(_) and _p_r_o_c_e_s_s___f_l_a_g_(_t_r_a_p___e_x_i_t_,_t_r_u_e_) behaves
           incorrectly.

         * The _I_C option _{_{_i_m_p_l_, _"_M_:_:_I_"_}_, _"_o_t_h_e_r___i_m_p_l_"_} has no effect. The
           call-back functions must be implemented in a file called
           _M___I___i_m_p_l_._e_r_l

         * The _I_C option _f_r_o_m has no effect.

         * The call-back functions must be implemented as if the _I_C option
           _{_t_h_i_s_, _"_M_:_:_I_"_} was used.

         * Server _S_t_a_t_e changes have no effect. The user can provide
           information via the _E_n_v start parameter and the State returned from
           _i_n_i_t_/_2 will be the State passed in following invocations.

         * If a call-back function replies with the _T_i_m_e_o_u_t parameter set it
           have no effect.

         * Operations defined as _o_n_e_w_a_y are blocking until the operation
           replies.

         * The option _{_p_s_e_u_d_o_, _t_r_u_e_} overrides all other start options.

         * Only the functions, besides own definitions, _i_n_i_t_/_2 (called via
           oe_create*/2) and _t_e_r_m_i_n_a_t_e_/_2 (called via corba:dispose/1) must be
           implemented.

       By adopting the rules for _p_s_e_u_d_o objects described above we can use
       _o_e___c_r_e_a_t_e_/_2 to create _s_e_r_v_e_r or _p_s_e_u_d_o objects, by excluding or
       including the option _{_p_s_e_u_d_o_, _t_r_u_e_}, without changing the call-back
       module.

       If you start a object without _{_r_e_g_n_a_m_e_, _R_e_g_N_a_m_e_} it can only be
       accessed through the returned object key. Started with a _{_r_e_g_n_a_m_e_,
       _R_e_g_N_a_m_e_} the name is registered locally or globally.

   WWaarrnniinngg::
       To avoid flooding Orber with old object references start erlang using
       the flag _-_o_r_b_e_r _o_b_j_e_c_t_k_e_y_s___g_c___t_i_m_e _T_i_m_e, which will remove all object
       references related to servers being dead for Time seconds. To avoid
       extra overhead, i.e., performing garbage collect if no persistent
       objects are started, the objectkeys_gc_time default value is _i_n_f_i_n_i_t_y.
       For more information, see the orber and corba documentation.


EEXXPPOORRTTSS
       MMoodduullee__IInntteerrffaaccee::ttyyppeeIIDD(()) -->> TTyyppeeIIdd

              Types:

                 TypeId = string(), e.g., "IDL:Module/Interface:1.0"

              Returns the Type ID related to this stub/skeleton

       MMoodduullee__IInntteerrffaaccee::ooee__ccrreeaattee(()) -->> OObbjjRReeff

              Types:

                 ObjRef = #object reference

              Start a Orber server.

       MMoodduullee__IInntteerrffaaccee::ooee__ccrreeaattee__lliinnkk(()) -->> OObbjjRReeff

              Types:

                 ObjRef = #object reference

              Start a linked Orber server.

       MMoodduullee__IInntteerrffaaccee::ooee__ccrreeaattee((EEnnvv)) -->> OObbjjRReeff

              Types:

                 Env = term()
                 ObjRef = #object reference

              Start a Orber server passing Env to _i_n_i_t_/_1.

       MMoodduullee__IInntteerrffaaccee::ooee__ccrreeaattee__lliinnkk((EEnnvv)) -->> OObbjjRReeff

              Types:

                 Env = term()
                 ObjRef = #object reference

              Start a linked Orber server passing Env to _i_n_i_t_/_1.

       MMoodduullee__IInntteerrffaaccee::ooee__ccrreeaattee((EEnnvv,, OOppttiioonnss)) -->> OObbjjRReeff

              Types:

                 Env = term()
                 ObjRef = #object reference
                 Options = [{sup_child, false} | {persistent, Bool} |
                 {regname, RegName} | {pseudo, Bool} | {local_typecheck, Bool}
                 | {survive_exit, Bool} | {create_options, [CreateOpts]}]
                 Bool = true | false
                 RegName = {global, term()} | {local, atom()}
                 CreateOpts = {debug, [Dbg]} | {timeout, Time}
                 Dbg = trace | log | statistics | {log_to_file, FileName}

              Start a Orber server passing Env to _i_n_i_t_/_1.

              If the option _{_p_s_e_u_d_o_, _t_r_u_e_} is used, all other options are
              overridden. As default, this option is set to false.

              This function cannot be used for starting a server as supervisor
              child. If started as _p_e_r_s_i_s_t_e_n_t, the options _[_{_p_e_r_s_i_s_t_e_n_t_,
              _t_r_u_e_}_, _{_r_e_g_n_a_m_e_, _{_g_l_o_b_a_l_, _t_e_r_m_(_)_}_}_] must be used and Orber will
              only forget the object reference if it terminates with reason
              _n_o_r_m_a_l or _s_h_u_t_d_o_w_n.

              The option _{_l_o_c_a_l___t_y_p_e_c_h_e_c_k_, _b_o_o_l_e_a_n_(_)_}, which overrides the
              LLooccaall TTyyppeecchheecckkiinngg environment flag, turns on or off
              typechecking. If activated, parameters, replies and raised
              exceptions will be checked to ensure that the data is correct,
              when invoking operations on CORBA Objects within the same Orber
              domain. Due to the extra overhead, this option _M_A_Y _O_N_L_Y be used
              during testing and development.

              _{_s_u_r_v_i_v_e___e_x_i_t_, _b_o_o_l_e_a_n_(_)_} overrides the EEXXIITT TToolleerraannccee
              environment flag. If activated, the server will not terminate,
              even though the call-back module returns EXIT.

              _T_i_m_e specifies how long time, in milliseconds, the server is
              allowed to spend initializing. For more information about the
              _D_b_g options, see the _s_y_s module.

       MMoodduullee__IInntteerrffaaccee::ooee__ccrreeaattee__lliinnkk((EEnnvv,, OOppttiioonnss)) -->> RReettuurrnn

              Types:

                 Env = term()
                 Return = ObjRef | {ok, Pid, ObjRef}
                 ObjRef = #object reference
                 Options = [{sup_child, Bool} | {persistent, Bool} | {regname,
                 RegName} | {pseudo, Bool} | {local_typecheck, Bool} |
                 {survive_exit, Bool} | {create_options, [CreateOpts]}]
                 Bool = true | false
                 RegName = {global, term()} | {local, atom()}
                 CreateOpts = {debug, [Dbg]} | {timeout, Time}
                 Dbg = trace | log | statistics | {log_to_file, FileName}




              Start a linked Orber server passing Env to _i_n_i_t_/_1.

              If the option _{_p_s_e_u_d_o_, _t_r_u_e_} is used, all other options are
              overridden and no link will be created. As default, this option
              is set to false.

              This function can be used for starting a server as persistent or
              supervisor child. At the moment _[_{_p_e_r_s_i_s_t_e_n_t_, _t_r_u_e_}_, _{_r_e_g_n_a_m_e_,
              _{_g_l_o_b_a_l_, _t_e_r_m_(_)_}_}_] must be used to start a server as persistent,
              i.e., if a server died and is in the process of being restarted
              a call to the server will not raise _'_O_B_J_E_C_T___N_O_T___E_X_I_S_T_'
              exception. Orber will only forget the object reference if it
              terminates with reason _n_o_r_m_a_l or _s_h_u_t_d_o_w_n, hence, the server
              must be started as _t_r_a_n_s_i_e_n_t (for more information see the
              supervisor documentation).

              The options _{_l_o_c_a_l___t_y_p_e_c_h_e_c_k_, _b_o_o_l_e_a_n_(_)_} and _{_s_u_r_v_i_v_e___e_x_i_t_,
              _b_o_o_l_e_a_n_(_)_} behaves in the same way as for _o_e___c_r_e_a_t_e_/_2.

              _T_i_m_e specifies how long time, in milliseconds, the server is
              allowed to spend initializing. For more information about the
              _D_b_g options, see the _s_y_s module.

       MMoodduullee__IInntteerrffaaccee::oowwnn__ffuunnccttiioonnss((OObbjjRReeff,, AArrgg11,, ......,, AArrggNN)) -->> RReeppllyy
       MMoodduullee__IInntteerrffaaccee::oowwnn__ffuunnccttiioonnss((OObbjjRReeff,, OOppttiioonnss,, AArrgg11,, ......,, AArrggNN)) -->>
       RReeppllyy

              Types:

                 ObjRef = #object reference
                 Options = [Option] | Timeout
                 Option = {timeout, Timeout} | {context, [Context]}
                 Timeout = infinity | integer(milliseconds)
                 Context = #'IOP_ServiceContext'{context_id = CtxId,
                 context_data = CtxData}
                 CtxId = ?ORBER_GENERIC_CTX_ID
                 CtxData = {interface, Interface} | {userspecific, term()} |
                 {configuration, Options}
                 Interface = string()
                 Options = [{Key, Value}]
                 Key = ssl_client_verify | ssl_client_depth |
                 ssl_client_certfile | ssl_client_cacertfile |
                 ssl_client_password | ssl_client_keyfile | ssl_client_ciphers
                 | ssl_client_cachetimeout
                 Value = allowed value associated with the given key
                 ArgX = specified in the IDL-code.
                 Reply = specified in the IDL-code.

              The default value for the _T_i_m_e_o_u_t option is _i_n_f_i_n_i_t_y. IPv4 or
              IPv6 addresses are accepted as local Interface.

              The _c_o_n_f_i_g_u_r_a_t_i_o_n context is used to override the global SSL
              client side ccoonnffiigguurraattiioonn.

              To gain access to _#_'_I_O_P___S_e_r_v_i_c_e_C_o_n_t_e_x_t_'_{_} record and the
              _?_O_R_B_E_R___G_E_N_E_R_I_C___C_T_X___I_D macro, you must add
              _-_i_n_c_l_u_d_e___l_i_b_(_"_o_r_b_e_r_/_i_n_c_l_u_d_e_/_c_o_r_b_a_._h_r_l_"_)_. to your module.

CCAALLLLBBAACCKK FFUUNNCCTTIIOONNSS
       The following functions should be exported from a _C_O_R_B_A callback
       module. Note, a complete template of the call-back module can be
       generated automatically by compiling the IDL-file with the IC option
       _{_b_e_,_e_r_l___t_e_m_p_l_a_t_e_}. One should also add the same compile options, for
       example _t_h_i_s or _f_r_o_m, used when generating the stub/skeleton modules.

EEXXPPOORRTTSS
       MMoodduullee__IInntteerrffaaccee__iimmppll::iinniitt((EEnnvv)) -->> CCaallllRReeppllyy

              Types:

                 Env = term()
                 CallReply = {ok, State} | {ok, State, Timeout} | ignore |
                 {stop, StopReason}
                 State = term()
                 Timeout = int() >= 0 | infinity
                 StopReason = term()

              Whenever a new server is started, _i_n_i_t_/_1 is the first function
              called in the specified call-back module.

       MMoodduullee__IInntteerrffaaccee__iimmppll::tteerrmmiinnaattee((RReeaassoonn,, SSttaattee)) -->> ookk

              Types:

                 Reason = term()
                 State = term()

              This call-back function is called whenever the server is about
              to terminate.

       MMoodduullee__IInntteerrffaaccee__iimmppll::ccooddee__cchhaannggee((OOllddVVssnn,, SSttaattee,, EExxttrraa)) -->> CCaallllRReeppllyy

              Types:

                 OldVsn = undefined | term()
                 State = term()
                 Extra = term()
                 CallReply = {ok, NewState}
                 NewState = term()

              Update the internal _S_t_a_t_e.

       MMoodduullee__IInntteerrffaaccee__iimmppll::hhaannddllee__iinnffoo((IInnffoo,, SSttaattee)) -->> CCaallllRReeppllyy

              Types:

                 Info = term()
                 State = term()
                 CallReply = {noreply, State} | {noreply, State, Timeout} |
                 {stop, StopReason, State}
                 Timeout = int() >= 0 | infinity
                 StopReason = normal | shutdown | term()

              If the configuration parameter _{_{_h_a_n_d_l_e___i_n_f_o_,
              _"_M_o_d_u_l_e_:_:_I_n_t_e_r_f_a_c_e_"_}_, _t_r_u_e_} is passed to IC and
              _p_r_o_c_e_s_s___f_l_a_g_(_t_r_a_p___e_x_i_t_,_t_r_u_e_) is set in the _i_n_i_t_(_) call-back this
              function must be exported.

          NNoottee::
              To be able to handle the _T_i_m_e_o_u_t option in _C_a_l_l_R_e_p_l_y in the
              call-back module the configuration parameter _{_{_h_a_n_d_l_e___i_n_f_o_,
              _"_M_o_d_u_l_e_:_:_I_n_t_e_r_f_a_c_e_"_}_, _t_r_u_e_} must be passed to IC.


       MMoodduullee__IInntteerrffaaccee__iimmppll::oowwnn__ffuunnccttiioonnss((SSttaattee,, AArrgg11,, ......,, AArrggNN)) -->>
       CCaallllRReeppllyy
       MMoodduullee__IInntteerrffaaccee__iimmppll::oowwnn__ffuunnccttiioonnss((TThhiiss,, SSttaattee,, AArrgg11,, ......,, AArrggNN)) -->>
       CCaallllRReeppllyy
       MMoodduullee__IInntteerrffaaccee__iimmppll::oowwnn__ffuunnccttiioonnss((TThhiiss,, FFrroomm,, SSttaattee,, AArrgg11,, ......,, AArrggNN))
       -->> EExxttCCaallllRReeppllyy
       MMoodduullee__IInntteerrffaaccee__iimmppll::oowwnn__ffuunnccttiioonnss((FFrroomm,, SSttaattee,, AArrgg11,, ......,, AArrggNN)) -->>
       EExxttCCaallllRReeppllyy

              Types:

                 This = the servers #object reference
                 State = term()
                 ArgX = specified in the IDL-code.
                 CallReply = {reply, Reply, State} | {reply, Reply, State,
                 Timeout} | {stop, StopReason, Reply, State} | {stop,
                 StopReason, State} | corba:raise(Exception)
                 ExtCallReply = CallReply | corba:reply(From, Reply),
                 {noreply, State} | corba:reply(From, Reply), {noreply, State,
                 Timeout}
                 Reply = specified in the IDL-code.
                 Timeout = int() >= 0 | infinity
                 StopReason = normal | shutdown | term()

              All two-way functions must return one of the listed replies or
              raise any of the exceptions listed in the IDL code (i.e.
              raises(...)). If the IC compile options _t_h_i_s and/or _f_r_o_m are
              used, the implementation must accept the _T_h_i_s and/or _F_r_o_m
              parameters.

       MMoodduullee__IInntteerrffaaccee__iimmppll::oowwnn__ffuunnccttiioonnss((SSttaattee,, AArrgg11,, ......,, AArrggNN)) -->>
       CCaassttRReeppllyy
       MMoodduullee__IInntteerrffaaccee__iimmppll::oowwnn__ffuunnccttiioonnss((TThhiiss,, SSttaattee,, AArrgg11,, ......,, AArrggNN)) -->>
       CCaassttRReeppllyy

              Types:

                 This = the servers #object reference
                 State = term()
                 CastReply = {noreply, State} | {noreply, State, Timeout} |
                 {stop, StopReason, State}
                 ArgX = specified in the IDL-code.
                 Reply = specified in the IDL-code.
                 Timeout = int() >= 0 | infinity
                 StopReason = normal | shutdown | term()

              All one-way functions must return one of the listed replies. If
              the IC compile option _t_h_i_s is used, the implementation must
              accept the _T_h_i_s parameter.



Ericsson AB                      orber 3.6.24              Module_Interface(3)
