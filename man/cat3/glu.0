glu(3)                     Erlang Module Definition                     glu(3)



NNAAMMEE
       glu -  A part of the standard OpenGL Utility api.

DDEESSCCRRIIPPTTIIOONN
       A part of the standard OpenGL Utility api. See www.opengl.org

       Booleans are represented by integers 0 and 1.

DDAATTAA TTYYPPEESS
         _e_n_u_m_(_) _= _n_o_n___n_e_g___i_n_t_e_g_e_r_(_):


           See wx/include/gl.hrl or glu.hrl

         _m_a_t_r_i_x_(_) _= _{_f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_,
         _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_,
         _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_}:


         _m_e_m_(_) _= _b_i_n_a_r_y_(_) _| _t_u_p_l_e_(_):


           Memory block

         _v_e_r_t_e_x_(_) _= _{_f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_}:


EEXXPPOORRTTSS
       tteesssseellaattee((NNoorrmmaall,, VVss::::[[VVss]])) -->> {{TTrriiaanngglleess,, VVeerrtteexxPPooss}}

              Types:

                 Normal = vertex()
                 Vs = vertex()
                 Triangles = [integer()]
                 VertexPos = binary()

              General purpose polygon triangulation. The first argument is the
              normal and the second a list of vertex positions. Returned is a
              list of indecies of the vertices and a binary (64bit native
              float) containing an array of vertex positions, it starts with
              the vertices in Vs and may contain newly created vertices in the
              end.

       bbuuiilldd11DDMMiippmmaappLLeevveellss((TTaarrggeett,, IInntteerrnnaallFFoorrmmaatt,, WWiiddtthh,, FFoorrmmaatt,, TTyyppee,, LLeevveell,,
       BBaassee,, MMaaxx,, DDaattaa)) -->> iinntteeggeerr(())

              Types:

                 Target = enum()
                 InternalFormat = integer()
                 Width = integer()
                 Format = enum()
                 Type = enum()
                 Level = integer()
                 Base = integer()
                 Max = integer()
                 Data = binary()

              Builds a subset of one-dimensional mipmap levels

              _g_l_u_:_b_u_i_l_d_1_D_M_i_p_m_a_p_L_e_v_e_l_s builds a subset of prefiltered one-
              dimensional texture maps of decreasing resolutions called a
              mipmap. This is used for the antialiasing of texture mapped
              primitives.

              A return value of zero indicates success, otherwise a GLU error
              code is returned (see gglluu::eerrrroorrSSttrriinngg//11 ).

              A series of mipmap levels from _B_a_s_e to _M_a_x is built by
              decimating _D_a_t_a in half until size 1*1 is reached. At each
              level, each texel in the halved mipmap level is an average of
              the corresponding two texels in the larger mipmap level.
              ggll::tteexxIImmaaggee11DD//88 is called to load these mipmap levels from _B_a_s_e
              to _M_a_x . If _M_a_x is larger than the highest mipmap level for the
              texture of the specified size, then a GLU error code is returned
              (see gglluu::eerrrroorrSSttrriinngg//11 ) and nothing is loaded.

              For example, if _L_e_v_e_l is 2 and _W_i_d_t_h is 16, the following levels
              are possible: 16*1, 8*1, 4*1, 2*1, 1*1. These correspond to
              levels 2 through 6 respectively. If _B_a_s_e is 3 and _M_a_x is 5, then
              only mipmap levels 8*1, 4*1 and 2*1 are loaded. However, if _M_a_x
              is 7, then an error is returned and nothing is loaded since _M_a_x
              is larger than the highest mipmap level which is, in this case,
              6.

              The highest mipmap level can be derived from the formula log
              2(width*2 level).

              See the ggll::tteexxIImmaaggee11DD//88 reference page for a description of the
              acceptable values for _T_y_p_e parameter. See the ggll::ddrraawwPPiixxeellss//55
              reference page for a description of the acceptable values for
              _L_e_v_e_l parameter.

              See external documentation.

       bbuuiilldd11DDMMiippmmaappss((TTaarrggeett,, IInntteerrnnaallFFoorrmmaatt,, WWiiddtthh,, FFoorrmmaatt,, TTyyppee,, DDaattaa)) -->>
       iinntteeggeerr(())

              Types:

                 Target = enum()
                 InternalFormat = integer()
                 Width = integer()
                 Format = enum()
                 Type = enum()
                 Data = binary()

              Builds a one-dimensional mipmap

              _g_l_u_:_b_u_i_l_d_1_D_M_i_p_m_a_p_s builds a series of prefiltered one-
              dimensional texture maps of decreasing resolutions called a
              mipmap. This is used for the antialiasing of texture mapped
              primitives.

              A return value of zero indicates success, otherwise a GLU error
              code is returned (see gglluu::eerrrroorrSSttrriinngg//11 ).

              Initially, the _W_i_d_t_h of _D_a_t_a is checked to see if it is a power
              of 2. If not, a copy of _D_a_t_a is scaled up or down to the nearest
              power of 2. (If _W_i_d_t_h is exactly between powers of 2, then the
              copy of _D_a_t_a will scale upwards.) This copy will be used for
              subsequent mipmapping operations described below. For example,
              if _W_i_d_t_h is 57, then a copy of _D_a_t_a will scale up to 64 before
              mipmapping takes place.

              Then, proxy textures (see ggll::tteexxIImmaaggee11DD//88 ) are used to
              determine if the implementation can fit the requested texture.
              If not, _W_i_d_t_h is continually halved until it fits.

              Next, a series of mipmap levels is built by decimating a copy of
              _D_a_t_a in half until size 1*1 is reached. At each level, each
              texel in the halved mipmap level is an average of the
              corresponding two texels in the larger mipmap level.

              ggll::tteexxIImmaaggee11DD//88 is called to load each of these mipmap levels.
              Level 0 is a copy of _D_a_t_a . The highest level is (log 2)(width).
              For example, if _W_i_d_t_h is 64 and the implementation can store a
              texture of this size, the following mipmap levels are built:
              64*1, 32*1, 16*1, 8*1, 4*1, 2*1, and 1*1. These correspond to
              levels 0 through 6, respectively.

              See the ggll::tteexxIImmaaggee11DD//88 reference page for a description of the
              acceptable values for the _T_y_p_e parameter. See the
              ggll::ddrraawwPPiixxeellss//55 reference page for a description of the
              acceptable values for the _D_a_t_a parameter.

              See external documentation.

       bbuuiilldd22DDMMiippmmaappLLeevveellss((TTaarrggeett,, IInntteerrnnaallFFoorrmmaatt,, WWiiddtthh,, HHeeiigghhtt,, FFoorrmmaatt,,
       TTyyppee,, LLeevveell,, BBaassee,, MMaaxx,, DDaattaa)) -->> iinntteeggeerr(())

              Types:

                 Target = enum()
                 InternalFormat = integer()
                 Width = integer()
                 Height = integer()
                 Format = enum()
                 Type = enum()
                 Level = integer()
                 Base = integer()
                 Max = integer()
                 Data = binary()

              Builds a subset of two-dimensional mipmap levels

              _g_l_u_:_b_u_i_l_d_2_D_M_i_p_m_a_p_L_e_v_e_l_s builds a subset of prefiltered two-
              dimensional texture maps of decreasing resolutions called a
              mipmap. This is used for the antialiasing of texture mapped
              primitives.

              A return value of zero indicates success, otherwise a GLU error
              code is returned (see gglluu::eerrrroorrSSttrriinngg//11 ).

              A series of mipmap levels from _B_a_s_e to _M_a_x is built by
              decimating _D_a_t_a in half along both dimensions until size 1*1 is
              reached. At each level, each texel in the halved mipmap level is
              an average of the corresponding four texels in the larger mipmap
              level. (In the case of rectangular images, the decimation will
              ultimately reach an N*1 or 1*N configuration. Here, two texels
              are averaged instead.) ggll::tteexxIImmaaggee22DD//99 is called to load these
              mipmap levels from _B_a_s_e to _M_a_x . If _M_a_x is larger than the
              highest mipmap level for the texture of the specified size, then
              a GLU error code is returned (see gglluu::eerrrroorrSSttrriinngg//11 ) and
              nothing is loaded.

              For example, if _L_e_v_e_l is 2 and _W_i_d_t_h is 16 and _H_e_i_g_h_t is 8, the
              following levels are possible: 16*8, 8*4, 4*2, 2*1, 1*1. These
              correspond to levels 2 through 6 respectively. If _B_a_s_e is 3 and
              _M_a_x is 5, then only mipmap levels 8*4, 4*2, and 2*1 are loaded.
              However, if _M_a_x is 7, then an error is returned and nothing is
              loaded since _M_a_x is larger than the highest mipmap level which
              is, in this case, 6.

              The highest mipmap level can be derived from the formula log
              2(max(width height)*2 level).

              See the ggll::tteexxIImmaaggee11DD//88 reference page for a description of the
              acceptable values for _F_o_r_m_a_t parameter. See the ggll::ddrraawwPPiixxeellss//55
              reference page for a description of the acceptable values for
              _T_y_p_e parameter.

              See external documentation.

       bbuuiilldd22DDMMiippmmaappss((TTaarrggeett,, IInntteerrnnaallFFoorrmmaatt,, WWiiddtthh,, HHeeiigghhtt,, FFoorrmmaatt,, TTyyppee,,
       DDaattaa)) -->> iinntteeggeerr(())

              Types:

                 Target = enum()
                 InternalFormat = integer()
                 Width = integer()
                 Height = integer()
                 Format = enum()
                 Type = enum()
                 Data = binary()

              Builds a two-dimensional mipmap

              _g_l_u_:_b_u_i_l_d_2_D_M_i_p_m_a_p_s builds a series of prefiltered two-
              dimensional texture maps of decreasing resolutions called a
              mipmap. This is used for the antialiasing of texture-mapped
              primitives.

              A return value of zero indicates success, otherwise a GLU error
              code is returned (see gglluu::eerrrroorrSSttrriinngg//11 ).

              Initially, the _W_i_d_t_h and _H_e_i_g_h_t of _D_a_t_a are checked to see if
              they are a power of 2. If not, a copy of _D_a_t_a (not _D_a_t_a ), is
              scaled up or down to the nearest power of 2. This copy will be
              used for subsequent mipmapping operations described below. (If
              _W_i_d_t_h or _H_e_i_g_h_t is exactly between powers of 2, then the copy of
              _D_a_t_a will scale upwards.) For example, if _W_i_d_t_h is 57 and _H_e_i_g_h_t
              is 23, then a copy of _D_a_t_a will scale up to 64 in _W_i_d_t_h and down
              to 16 in depth, before mipmapping takes place.

              Then, proxy textures (see ggll::tteexxIImmaaggee22DD//99 ) are used to
              determine if the implementation can fit the requested texture.
              If not, both dimensions are continually halved until it fits.
              (If the OpenGL version is (<= 1.0, both maximum texture
              dimensions are clamped to the value returned by ggll::ggeettBBoooolleeaannvv//11
              with the argument _?_G_L_U___M_A_X___T_E_X_T_U_R_E___S_I_Z_E .)

              Next, a series of mipmap levels is built by decimating a copy of
              _D_a_t_a in half along both dimensions until size 1*1 is reached. At
              each level, each texel in the halved mipmap level is an average
              of the corresponding four texels in the larger mipmap level. (In
              the case of rectangular images, the decimation will ultimately
              reach an N*1 or 1*N configuration. Here, two texels are averaged
              instead.)

              ggll::tteexxIImmaaggee22DD//99 is called to load each of these mipmap levels.
              Level 0 is a copy of _D_a_t_a . The highest level is (log
              2)(max(width height)). For example, if _W_i_d_t_h is 64 and _H_e_i_g_h_t is
              16 and the implementation can store a texture of this size, the
              following mipmap levels are built: 64*16, 32*8, 16*4, 8*2, 4*1,
              2*1, and 1*1 These correspond to levels 0 through 6,
              respectively.

              See the ggll::tteexxIImmaaggee11DD//88 reference page for a description of the
              acceptable values for _F_o_r_m_a_t parameter. See the ggll::ddrraawwPPiixxeellss//55
              reference page for a description of the acceptable values for
              _T_y_p_e parameter.

              See external documentation.

       bbuuiilldd33DDMMiippmmaappLLeevveellss((TTaarrggeett,, IInntteerrnnaallFFoorrmmaatt,, WWiiddtthh,, HHeeiigghhtt,, DDeepptthh,,
       FFoorrmmaatt,, TTyyppee,, LLeevveell,, BBaassee,, MMaaxx,, DDaattaa)) -->> iinntteeggeerr(())

              Types:

                 Target = enum()
                 InternalFormat = integer()
                 Width = integer()
                 Height = integer()
                 Depth = integer()
                 Format = enum()
                 Type = enum()
                 Level = integer()
                 Base = integer()
                 Max = integer()
                 Data = binary()

              Builds a subset of three-dimensional mipmap levels

              _g_l_u_:_b_u_i_l_d_3_D_M_i_p_m_a_p_L_e_v_e_l_s builds a subset of prefiltered three-
              dimensional texture maps of decreasing resolutions called a
              mipmap. This is used for the antialiasing of texture mapped
              primitives.

              A return value of zero indicates success, otherwise a GLU error
              code is returned (see gglluu::eerrrroorrSSttrriinngg//11 ).

              A series of mipmap levels from _B_a_s_e to _M_a_x is built by
              decimating _D_a_t_a in half along both dimensions until size 1*1*1
              is reached. At each level, each texel in the halved mipmap level
              is an average of the corresponding eight texels in the larger
              mipmap level. (If exactly one of the dimensions is 1, four
              texels are averaged. If exactly two of the dimensions are 1, two
              texels are averaged.) ggll::tteexxIImmaaggee33DD//1100 is called to load these
              mipmap levels from _B_a_s_e to _M_a_x . If _M_a_x is larger than the
              highest mipmap level for the texture of the specified size, then
              a GLU error code is returned (see gglluu::eerrrroorrSSttrriinngg//11 ) and
              nothing is loaded.

              For example, if _L_e_v_e_l is 2 and _W_i_d_t_h is 16, _H_e_i_g_h_t is 8 and
              _D_e_p_t_h is 4, the following levels are possible: 16*8*4, 8*4*2,
              4*2*1, 2*1*1, 1*1*1. These correspond to levels 2 through 6
              respectively. If _B_a_s_e is 3 and _M_a_x is 5, then only mipmap levels
              8*4*2, 4*2*1, and 2*1*1 are loaded. However, if _M_a_x is 7, then
              an error is returned and nothing is loaded, since _M_a_x is larger
              than the highest mipmap level which is, in this case, 6.

              The highest mipmap level can be derived from the formula log
              2(max(width height depth)*2 level).

              See the ggll::tteexxIImmaaggee11DD//88 reference page for a description of the
              acceptable values for _F_o_r_m_a_t parameter. See the ggll::ddrraawwPPiixxeellss//55
              reference page for a description of the acceptable values for
              _T_y_p_e parameter.

              See external documentation.

       bbuuiilldd33DDMMiippmmaappss((TTaarrggeett,, IInntteerrnnaallFFoorrmmaatt,, WWiiddtthh,, HHeeiigghhtt,, DDeepptthh,, FFoorrmmaatt,,
       TTyyppee,, DDaattaa)) -->> iinntteeggeerr(())

              Types:

                 Target = enum()
                 InternalFormat = integer()
                 Width = integer()
                 Height = integer()
                 Depth = integer()
                 Format = enum()
                 Type = enum()
                 Data = binary()

              Builds a three-dimensional mipmap

              _g_l_u_:_b_u_i_l_d_3_D_M_i_p_m_a_p_s builds a series of prefiltered three-
              dimensional texture maps of decreasing resolutions called a
              mipmap. This is used for the antialiasing of texture-mapped
              primitives.

              A return value of zero indicates success, otherwise a GLU error
              code is returned (see gglluu::eerrrroorrSSttrriinngg//11 ).

              Initially, the _W_i_d_t_h , _H_e_i_g_h_t and _D_e_p_t_h of _D_a_t_a are checked to
              see if they are a power of 2. If not, a copy of _D_a_t_a is made and
              scaled up or down to the nearest power of 2. (If _W_i_d_t_h , _H_e_i_g_h_t
              , or _D_e_p_t_h is exactly between powers of 2, then the copy of _D_a_t_a
              will scale upwards.) This copy will be used for subsequent
              mipmapping operations described below. For example, if _W_i_d_t_h is
              57, _H_e_i_g_h_t is 23, and _D_e_p_t_h is 24, then a copy of _D_a_t_a will
              scale up to 64 in width, down to 16 in height, and up to 32 in
              depth before mipmapping takes place.

              Then, proxy textures (see ggll::tteexxIImmaaggee33DD//1100 ) are used to
              determine if the implementation can fit the requested texture.
              If not, all three dimensions are continually halved until it
              fits.

              Next, a series of mipmap levels is built by decimating a copy of
              _D_a_t_a in half along all three dimensions until size 1*1*1 is
              reached. At each level, each texel in the halved mipmap level is
              an average of the corresponding eight texels in the larger
              mipmap level. (If exactly one of the dimensions is 1, four
              texels are averaged. If exactly two of the dimensions are 1, two
              texels are averaged.)

              ggll::tteexxIImmaaggee33DD//1100 is called to load each of these mipmap levels.
              Level 0 is a copy of _D_a_t_a . The highest level is (log
              2)(max(width height depth)). For example, if _W_i_d_t_h is 64, _H_e_i_g_h_t
              is 16, and _D_e_p_t_h is 32, and the implementation can store a
              texture of this size, the following mipmap levels are built:
              64*16*32, 32*8*16, 16*4*8, 8*2*4, 4*1*2, 2*1*1, and 1*1*1. These
              correspond to levels 0 through 6, respectively.

              See the ggll::tteexxIImmaaggee11DD//88 reference page for a description of the
              acceptable values for _F_o_r_m_a_t parameter. See the ggll::ddrraawwPPiixxeellss//55
              reference page for a description of the acceptable values for
              _T_y_p_e parameter.

              See external documentation.

       cchheecckkEExxtteennssiioonn((EExxttNNaammee,, EExxttSSttrriinngg)) -->> 00 || 11

              Types:

                 ExtName = string()
                 ExtString = string()

              Determines if an extension name is supported

              _g_l_u_:_c_h_e_c_k_E_x_t_e_n_s_i_o_n returns _?_G_L_U___T_R_U_E if _E_x_t_N_a_m_e is supported
              otherwise _?_G_L_U___F_A_L_S_E is returned.

              This is used to check for the presence for OpenGL, GLU, or GLX
              extension names by passing the extension strings returned by
              ggll::ggeettSSttrriinngg//11 , gglluu::ggeettSSttrriinngg//11 , see _g_l_X_G_e_t_C_l_i_e_n_t_S_t_r_i_n_g , see
              _g_l_X_Q_u_e_r_y_E_x_t_e_n_s_i_o_n_s_S_t_r_i_n_g, or see _g_l_X_Q_u_e_r_y_S_e_r_v_e_r_S_t_r_i_n_g,
              respectively, as _E_x_t_S_t_r_i_n_g .

              See external documentation.

       ccyylliinnddeerr((QQuuaadd,, BBaassee,, TToopp,, HHeeiigghhtt,, SSlliicceess,, SSttaacckkss)) -->> ookk

              Types:

                 Quad = integer()
                 Base = float()
                 Top = float()
                 Height = float()
                 Slices = integer()
                 Stacks = integer()

              Draw a cylinder

              _g_l_u_:_c_y_l_i_n_d_e_r draws a cylinder oriented along the _z axis. The
              base of the cylinder is placed at _z = 0 and the top at z=
              height. Like a sphere, a cylinder is subdivided around the _z
              axis into slices and along the _z axis into stacks.

              Note that if _T_o_p is set to 0.0, this routine generates a cone.

              If the orientation is set to _?_G_L_U___O_U_T_S_I_D_E (with
              gglluu::qquuaaddrriiccOOrriieennttaattiioonn//22 ), then any generated normals point
              away from the _z axis. Otherwise, they point toward the _z axis.

              If texturing is turned on (with gglluu::qquuaaddrriiccTTeexxttuurree//22 ), then
              texture coordinates are generated so that _t ranges linearly from
              0.0 at _z = 0 to 1.0 at _z = _H_e_i_g_h_t , and _s ranges from 0.0 at the
              +_y axis, to 0.25 at the +_x axis, to 0.5 at the -_y axis, to 0.75
              at the -_x axis, and back to 1.0 at the +_y axis.

              See external documentation.

       ddeelleetteeQQuuaaddrriicc((QQuuaadd)) -->> ookk

              Types:

                 Quad = integer()

              Destroy a quadrics object

              _g_l_u_:_d_e_l_e_t_e_Q_u_a_d_r_i_c destroys the quadrics object (created with
              gglluu::nneewwQQuuaaddrriicc//00 ) and frees any memory it uses. Once
              _g_l_u_:_d_e_l_e_t_e_Q_u_a_d_r_i_c has been called, _Q_u_a_d cannot be used again.

              See external documentation.

       ddiisskk((QQuuaadd,, IInnnneerr,, OOuutteerr,, SSlliicceess,, LLooooppss)) -->> ookk

              Types:

                 Quad = integer()
                 Inner = float()
                 Outer = float()
                 Slices = integer()
                 Loops = integer()

              Draw a disk

              _g_l_u_:_d_i_s_k renders a disk on the _z = 0 plane. The disk has a
              radius of _O_u_t_e_r and contains a concentric circular hole with a
              radius of _I_n_n_e_r . If _I_n_n_e_r is 0, then no hole is generated. The
              disk is subdivided around the _z axis into slices (like pizza
              slices) and also about the _z axis into rings (as specified by
              _S_l_i_c_e_s and _L_o_o_p_s , respectively).

              With respect to orientation, the +_z side of the disk is
              considered to be _o_u_t_s_i_d_e (see gglluu::qquuaaddrriiccOOrriieennttaattiioonn//22 ). This
              means that if the orientation is set to _?_G_L_U___O_U_T_S_I_D_E , then any
              normals generated point along the +_z axis. Otherwise, they point
              along the -_z axis.

              If texturing has been turned on (with gglluu::qquuaaddrriiccTTeexxttuurree//22 ),
              texture coordinates are generated linearly such that where r=
              outer, the value at (_r, 0, 0) is (1, 0.5), at (0, _r, 0) it is
              (0.5, 1), at (-_r, 0, 0) it is (0, 0.5), and at (0, -_r, 0) it is
              (0.5, 0).

              See external documentation.

       eerrrroorrSSttrriinngg((EErrrroorr)) -->> ssttrriinngg(())

              Types:

                 Error = enum()

              Produce an error string from a GL or GLU error code

              _g_l_u_:_e_r_r_o_r_S_t_r_i_n_g produces an error string from a GL or GLU error
              code. The string is in ISO Latin 1 format. For example,
              _g_l_u_:_e_r_r_o_r_S_t_r_i_n_g(_?_G_L_U___O_U_T___O_F___M_E_M_O_R_Y) returns the string _o_u_t _o_f
              _m_e_m_o_r_y.

              The standard GLU error codes are _?_G_L_U___I_N_V_A_L_I_D___E_N_U_M,
              _?_G_L_U___I_N_V_A_L_I_D___V_A_L_U_E, and _?_G_L_U___O_U_T___O_F___M_E_M_O_R_Y. Certain other GLU
              functions can return specialized error codes through callbacks.
              See the ggll::ggeettEErrrroorr//00 reference page for the list of GL error
              codes.

              See external documentation.

       ggeettSSttrriinngg((NNaammee)) -->> ssttrriinngg(())

              Types:

                 Name = enum()

              Return a string describing the GLU version or GLU extensions

              _g_l_u_:_g_e_t_S_t_r_i_n_g returns a pointer to a static string describing
              the GLU version or the GLU extensions that are supported.

              The version number is one of the following forms:

              _m_a_j_o_r___n_u_m_b_e_r_._m_i_n_o_r___n_u_m_b_e_r_m_a_j_o_r___n_u_m_b_e_r_._m_i_n_o_r___n_u_m_b_e_r_._r_e_l_e_a_s_e___n_u_m_b_e_r.

              The version string is of the following form:

              _v_e_r_s_i_o_n _n_u_m_b_e_r_&_l_t_;_s_p_a_c_e_&_g_t_;_v_e_n_d_o_r_-_s_p_e_c_i_f_i_c _i_n_f_o_r_m_a_t_i_o_n

              Vendor-specific information is optional. Its format and contents
              depend on the implementation.

              The standard GLU contains a basic set of features and
              capabilities. If a company or group of companies wish to support
              other features, these may be included as extensions to the GLU.
              If _N_a_m_e is _?_G_L_U___E_X_T_E_N_S_I_O_N_S, then _g_l_u_:_g_e_t_S_t_r_i_n_g returns a space-
              separated list of names of supported GLU extensions. (Extension
              names never contain spaces.)

              All strings are null-terminated.

              See external documentation.

       llooookkAAtt((EEyyeeXX,, EEyyeeYY,, EEyyeeZZ,, CCeenntteerrXX,, CCeenntteerrYY,, CCeenntteerrZZ,, UUppXX,, UUppYY,, UUppZZ)) -->>
       ookk

              Types:

                 EyeX = float()
                 EyeY = float()
                 EyeZ = float()
                 CenterX = float()
                 CenterY = float()
                 CenterZ = float()
                 UpX = float()
                 UpY = float()
                 UpZ = float()

              Define a viewing transformation

              _g_l_u_:_l_o_o_k_A_t creates a viewing matrix derived from an eye point, a
              reference point indicating the center of the scene, and an _U_P
              vector.

              The matrix maps the reference point to the negative _z axis and
              the eye point to the origin. When a typical projection matrix is
              used, the center of the scene therefore maps to the center of
              the viewport. Similarly, the direction described by the _U_P
              vector projected onto the viewing plane is mapped to the
              positive _y axis so that it points upward in the viewport. The _U_P
              vector must not be parallel to the line of sight from the eye
              point to the reference point.

              Let

              F=(centerX-eyeX centerY-eyeY centerZ-eyeZ)

              Let _U_P be the vector (upX upY upZ).

              Then normalize as follows: f= F/(||F||)

              UP"= UP/(||UP||)

              Finally, let s= f*UP", and u= s*f.

              M is then constructed as follows: M=(s[0] s[1] s[2] 0 u[0] u[1]
              u[2] 0-f[0]-f[1]-f[2] 0 0 0 0 1)

              and _g_l_u_:_l_o_o_k_A_t is equivalent to glMultMatrixf(M);
              glTranslated(-eyex, -eyey, -eyez);

              See external documentation.

       nneewwQQuuaaddrriicc(()) -->> iinntteeggeerr(())

              Create a quadrics object

              _g_l_u_:_n_e_w_Q_u_a_d_r_i_c creates and returns a pointer to a new quadrics
              object. This object must be referred to when calling quadrics
              rendering and control functions. A return value of 0 means that
              there is not enough memory to allocate the object.

              See external documentation.

       oorrtthhoo22DD((LLeefftt,, RRiigghhtt,, BBoottttoomm,, TToopp)) -->> ookk

              Types:

                 Left = float()
                 Right = float()
                 Bottom = float()
                 Top = float()

              Define a 2D orthographic projection matrix

              _g_l_u_:_o_r_t_h_o_2_D sets up a two-dimensional orthographic viewing
              region. This is equivalent to calling ggll::oorrtthhoo//66 with near= -1
              and far= 1.

              See external documentation.

       ppaarrttiiaallDDiisskk((QQuuaadd,, IInnnneerr,, OOuutteerr,, SSlliicceess,, LLooooppss,, SSttaarrtt,, SSwweeeepp)) -->> ookk

              Types:

                 Quad = integer()
                 Inner = float()
                 Outer = float()
                 Slices = integer()
                 Loops = integer()
                 Start = float()
                 Sweep = float()

              Draw an arc of a disk

              _g_l_u_:_p_a_r_t_i_a_l_D_i_s_k renders a partial disk on the z= 0 plane. A
              partial disk is similar to a full disk, except that only the
              subset of the disk from _S_t_a_r_t through _S_t_a_r_t + _S_w_e_e_p is included
              (where 0 degrees is along the +f2yf axis, 90 degrees along the
              +_x axis, 180 degrees along the -_y axis, and 270 degrees along
              the -_x axis).

              The partial disk has a radius of _O_u_t_e_r and contains a concentric
              circular hole with a radius of _I_n_n_e_r . If _I_n_n_e_r is 0, then no
              hole is generated. The partial disk is subdivided around the _z
              axis into slices (like pizza slices) and also about the _z axis
              into rings (as specified by _S_l_i_c_e_s and _L_o_o_p_s , respectively).

              With respect to orientation, the +_z side of the partial disk is
              considered to be outside (see gglluu::qquuaaddrriiccOOrriieennttaattiioonn//22 ). This
              means that if the orientation is set to _?_G_L_U___O_U_T_S_I_D_E, then any
              normals generated point along the +_z axis. Otherwise, they point
              along the -_z axis.

              If texturing is turned on (with gglluu::qquuaaddrriiccTTeexxttuurree//22 ), texture
              coordinates are generated linearly such that where r= outer, the
              value at (_r, 0, 0) is (1.0, 0.5), at (0, _r, 0) it is (0.5, 1.0),
              at (-_r, 0, 0) it is (0.0, 0.5), and at (0, -_r, 0) it is (0.5,
              0.0).

              See external documentation.

       ppeerrssppeeccttiivvee((FFoovvyy,, AAssppeecctt,, ZZNNeeaarr,, ZZFFaarr)) -->> ookk

              Types:

                 Fovy = float()
                 Aspect = float()
                 ZNear = float()
                 ZFar = float()

              Set up a perspective projection matrix

              _g_l_u_:_p_e_r_s_p_e_c_t_i_v_e specifies a viewing frustum into the world
              coordinate system. In general, the aspect ratio in
              _g_l_u_:_p_e_r_s_p_e_c_t_i_v_e should match the aspect ratio of the associated
              viewport. For example, aspect= 2.0 means the viewer's angle of
              view is twice as wide in _x as it is in _y. If the viewport is
              twice as wide as it is tall, it displays the image without
              distortion.

              The matrix generated by _g_l_u_:_p_e_r_s_p_e_c_t_i_v_e is multipled by the
              current matrix, just as if ggll::mmuullttMMaattrriixxdd//11 were called with the
              generated matrix. To load the perspective matrix onto the
              current matrix stack instead, precede the call to
              _g_l_u_:_p_e_r_s_p_e_c_t_i_v_e with a call to ggll::llooaaddIIddeennttiittyy//00 .

              Given _f defined as follows:

              f= cotangent(fovy/2) The generated matrix is

              (f/aspect 0 0 0 0 f 0 0 0 0(zFar+zNear)/(zNear-
              zFar)(2*zFar*zNear)/(zNear-zFar) 0 0 -1 0)

              See external documentation.

       ppiicckkMMaattrriixx((XX,, YY,, DDeellXX,, DDeellYY,, VViieewwppoorrtt)) -->> ookk

              Types:

                 X = float()
                 Y = float()
                 DelX = float()
                 DelY = float()
                 Viewport = {integer(), integer(), integer(), integer()}

              Define a picking region

              _g_l_u_:_p_i_c_k_M_a_t_r_i_x creates a projection matrix that can be used to
              restrict drawing to a small region of the viewport. This is
              typically useful to determine what objects are being drawn near
              the cursor. Use _g_l_u_:_p_i_c_k_M_a_t_r_i_x to restrict drawing to a small
              region around the cursor. Then, enter selection mode (with
              ggll::rreennddeerrMMooddee//11 ) and rerender the scene. All primitives that
              would have been drawn near the cursor are identified and stored
              in the selection buffer.

              The matrix created by _g_l_u_:_p_i_c_k_M_a_t_r_i_x is multiplied by the
              current matrix just as if ggll::mmuullttMMaattrriixxdd//11 is called with the
              generated matrix. To effectively use the generated pick matrix
              for picking, first call ggll::llooaaddIIddeennttiittyy//00 to load an identity
              matrix onto the perspective matrix stack. Then call
              _g_l_u_:_p_i_c_k_M_a_t_r_i_x, and, finally, call a command (such as
              gglluu::ppeerrssppeeccttiivvee//44 ) to multiply the perspective matrix by the
              pick matrix.

              When using _g_l_u_:_p_i_c_k_M_a_t_r_i_x to pick NURBS, be careful to turn off
              the NURBS property _?_G_L_U___A_U_T_O___L_O_A_D___M_A_T_R_I_X. If
              _?_G_L_U___A_U_T_O___L_O_A_D___M_A_T_R_I_X is not turned off, then any NURBS surface
              rendered is subdivided differently with the pick matrix than the
              way it was subdivided without the pick matrix.

              See external documentation.

       pprroojjeecctt((OObbjjXX,, OObbjjYY,, OObbjjZZ,, MMooddeell,, PPrroojj,, VViieeww)) -->> {{iinntteeggeerr(()),,
       WWiinnXX::::ffllooaatt(()),, WWiinnYY::::ffllooaatt(()),, WWiinnZZ::::ffllooaatt(())}}

              Types:

                 ObjX = float()
                 ObjY = float()
                 ObjZ = float()
                 Model = matrix()
                 Proj = matrix()
                 View = {integer(), integer(), integer(), integer()}

              Map object coordinates to window coordinates

              _g_l_u_:_p_r_o_j_e_c_t transforms the specified object coordinates into
              window coordinates using _M_o_d_e_l , _P_r_o_j , and _V_i_e_w . The result is
              stored in _W_i_n_X , _W_i_n_Y , and _W_i_n_Z . A return value of _?_G_L_U___T_R_U_E
              indicates success, a return value of _?_G_L_U___F_A_L_S_E indicates
              failure.

              To compute the coordinates, let v=(objX objY objZ 1.0)
              represented as a matrix with 4 rows and 1 column. Then
              _g_l_u_:_p_r_o_j_e_c_t computes v" as follows:

              v"= P*M*v

              where P is the current projection matrix _P_r_o_j and M is the
              current modelview matrix _M_o_d_e_l (both represented as 4*4 matrices
              in column-major order).

              The window coordinates are then computed as follows:

              winX= view(0)+view(2)*(v"(0)+1)/2

              winY= view(1)+view(3)*(v"(1)+1)/2

              winZ=(v"(2)+1)/2

              See external documentation.

       qquuaaddrriiccDDrraawwSSttyyllee((QQuuaadd,, DDrraaww)) -->> ookk

              Types:

                 Quad = integer()
                 Draw = enum()

              Specify the draw style desired for quadrics

              _g_l_u_:_q_u_a_d_r_i_c_D_r_a_w_S_t_y_l_e specifies the draw style for quadrics
              rendered with _Q_u_a_d . The legal values are as follows:

              _?_G_L_U___F_I_L_L: Quadrics are rendered with polygon primitives. The
              polygons are drawn in a counterclockwise fashion with respect to
              their normals (as defined with gglluu::qquuaaddrriiccOOrriieennttaattiioonn//22 ).

              _?_G_L_U___L_I_N_E: Quadrics are rendered as a set of lines.

              _?_G_L_U___S_I_L_H_O_U_E_T_T_E: Quadrics are rendered as a set of lines, except
              that edges separating coplanar faces will not be drawn.

              _?_G_L_U___P_O_I_N_T: Quadrics are rendered as a set of points.

              See external documentation.

       qquuaaddrriiccNNoorrmmaallss((QQuuaadd,, NNoorrmmaall)) -->> ookk

              Types:

                 Quad = integer()
                 Normal = enum()

              Specify what kind of normals are desired for quadrics

              _g_l_u_:_q_u_a_d_r_i_c_N_o_r_m_a_l_s specifies what kind of normals are desired
              for quadrics rendered with _Q_u_a_d . The legal values are as
              follows:

              _?_G_L_U___N_O_N_E: No normals are generated.

              _?_G_L_U___F_L_A_T: One normal is generated for every facet of a quadric.

              _?_G_L_U___S_M_O_O_T_H: One normal is generated for every vertex of a
              quadric. This is the initial value.

              See external documentation.

       qquuaaddrriiccOOrriieennttaattiioonn((QQuuaadd,, OOrriieennttaattiioonn)) -->> ookk

              Types:

                 Quad = integer()
                 Orientation = enum()

              Specify inside/outside orientation for quadrics

              _g_l_u_:_q_u_a_d_r_i_c_O_r_i_e_n_t_a_t_i_o_n specifies what kind of orientation is
              desired for quadrics rendered with _Q_u_a_d . The _O_r_i_e_n_t_a_t_i_o_n values
              are as follows:

              _?_G_L_U___O_U_T_S_I_D_E: Quadrics are drawn with normals pointing outward
              (the initial value).

              _?_G_L_U___I_N_S_I_D_E: Quadrics are drawn with normals pointing inward.

              Note that the interpretation of _o_u_t_w_a_r_d and _i_n_w_a_r_d depends on
              the quadric being drawn.

              See external documentation.

       qquuaaddrriiccTTeexxttuurree((QQuuaadd,, TTeexxttuurree)) -->> ookk

              Types:

                 Quad = integer()
                 Texture = 0 | 1

              Specify if texturing is desired for quadrics

              _g_l_u_:_q_u_a_d_r_i_c_T_e_x_t_u_r_e specifies if texture coordinates should be
              generated for quadrics rendered with _Q_u_a_d . If the value of
              _T_e_x_t_u_r_e is _?_G_L_U___T_R_U_E, then texture coordinates are generated,
              and if _T_e_x_t_u_r_e is _?_G_L_U___F_A_L_S_E, they are not. The initial value is
              _?_G_L_U___F_A_L_S_E.

              The manner in which texture coordinates are generated depends
              upon the specific quadric rendered.

              See external documentation.

       ssccaalleeIImmaaggee((FFoorrmmaatt,, WWIInn,, HHIInn,, TTyyppeeIInn,, DDaattaaIInn,, WWOOuutt,, HHOOuutt,, TTyyppeeOOuutt,,
       DDaattaaOOuutt)) -->> iinntteeggeerr(())

              Types:

                 Format = enum()
                 WIn = integer()
                 HIn = integer()
                 TypeIn = enum()
                 DataIn = binary()
                 WOut = integer()
                 HOut = integer()
                 TypeOut = enum()
                 DataOut = mem()

              Scale an image to an arbitrary size

              _g_l_u_:_s_c_a_l_e_I_m_a_g_e scales a pixel image using the appropriate pixel
              store modes to unpack data from the source image and pack data
              into the destination image.

              When shrinking an image, _g_l_u_:_s_c_a_l_e_I_m_a_g_e uses a box filter to
              sample the source image and create pixels for the destination
              image. When magnifying an image, the pixels from the source
              image are linearly interpolated to create the destination image.

              A return value of zero indicates success, otherwise a GLU error
              code is returned (see gglluu::eerrrroorrSSttrriinngg//11 ).

              See the ggll::rreeaaddPPiixxeellss//77 reference page for a description of the
              acceptable values for the _F_o_r_m_a_t , _T_y_p_e_I_n , and _T_y_p_e_O_u_t
              parameters.

              See external documentation.

       sspphheerree((QQuuaadd,, RRaaddiiuuss,, SSlliicceess,, SSttaacckkss)) -->> ookk

              Types:

                 Quad = integer()
                 Radius = float()
                 Slices = integer()
                 Stacks = integer()

              Draw a sphere

              _g_l_u_:_s_p_h_e_r_e draws a sphere of the given radius centered around
              the origin. The sphere is subdivided around the _z axis into
              slices and along the _z axis into stacks (similar to lines of
              longitude and latitude).

              If the orientation is set to _?_G_L_U___O_U_T_S_I_D_E (with
              gglluu::qquuaaddrriiccOOrriieennttaattiioonn//22 ), then any normals generated point
              away from the center of the sphere. Otherwise, they point toward
              the center of the sphere.

              If texturing is turned on (with gglluu::qquuaaddrriiccTTeexxttuurree//22 ), then
              texture coordinates are generated so that _t ranges from 0.0 at
              z=-radius to 1.0 at z= radius (_t increases linearly along
              longitudinal lines), and _s ranges from 0.0 at the +_y axis, to
              0.25 at the +_x axis, to 0.5 at the -_y axis, to 0.75 at the -_x
              axis, and back to 1.0 at the +_y axis.

              See external documentation.

       uunnPPrroojjeecctt((WWiinnXX,, WWiinnYY,, WWiinnZZ,, MMooddeell,, PPrroojj,, VViieeww)) -->> {{iinntteeggeerr(()),,
       OObbjjXX::::ffllooaatt(()),, OObbjjYY::::ffllooaatt(()),, OObbjjZZ::::ffllooaatt(())}}

              Types:

                 WinX = float()
                 WinY = float()
                 WinZ = float()
                 Model = matrix()
                 Proj = matrix()
                 View = {integer(), integer(), integer(), integer()}

              Map window coordinates to object coordinates

              _g_l_u_:_u_n_P_r_o_j_e_c_t maps the specified window coordinates into object
              coordinates using _M_o_d_e_l , _P_r_o_j , and _V_i_e_w . The result is stored
              in _O_b_j_X , _O_b_j_Y , and _O_b_j_Z . A return value of _?_G_L_U___T_R_U_E
              indicates success; a return value of _?_G_L_U___F_A_L_S_E indicates
              failure.

              To compute the coordinates (objX objY objZ), _g_l_u_:_u_n_P_r_o_j_e_c_t
              multiplies the normalized device coordinates by the inverse of
              _M_o_d_e_l * _P_r_o_j as follows:

              (objX objY objZ W)= INV(P M) ((2(winX-
              view[0]))/(view[2])-1(2(winY-view[1]))/(view[3])-1 2(winZ)-1 1)
              INV denotes matrix inversion. W is an unused variable, included
              for consistent matrix notation.

              See external documentation.

       uunnPPrroojjeecctt44((WWiinnXX,, WWiinnYY,, WWiinnZZ,, CClliippWW,, MMooddeell,, PPrroojj,, VViieeww,, NNeeaarrVVaall,, FFaarrVVaall))
       -->> {{iinntteeggeerr(()),, OObbjjXX::::ffllooaatt(()),, OObbjjYY::::ffllooaatt(()),, OObbjjZZ::::ffllooaatt(()),,
       OObbjjWW::::ffllooaatt(())}}

              Types:

                 WinX = float()
                 WinY = float()
                 WinZ = float()
                 ClipW = float()
                 Model = matrix()
                 Proj = matrix()
                 View = {integer(), integer(), integer(), integer()}
                 NearVal = float()
                 FarVal = float()

              See uunnPPrroojjeecctt//66

AAUUTTHHOORRSS
       _<_>



                                   wx 0.99.2                            glu(3)
