megaco(3)                  Erlang Module Definition                  megaco(3)



NNAAMMEE
       megaco - Main API of the Megaco application

DDEESSCCRRIIPPTTIIOONN
       Interface module for the Megaco application

DDAATTAA TTYYPPEESS
       megaco_mid() = ip4Address() | ip6Address() |
                      domainName() | deviceName() |
                      mtpAddress()
       ip4Address() = #'IP4Address'{}
       ip6Address() = #'IP6Address'{}
       domainName() = #'DomainName'{}
       deviceName() = pathName()
       pathName()   = ia5String(1..64)
       mtpAddress() = octetString(2..4)

       action_request() = #'ActionRequest'{}
       action_reply() = #'ActionReply'{}
       error_desc() = #'ErrorDescriptor'{}
       transaction_reply() = #'TransactionReply'{}
       segment_no() = integer()

       resend_indication() = flag | boolean()

       property_parm() = #'PropertyParm'{}
       property_group() = [property_parm()]
       property_groups() = [property_group()]

       sdp() = sdp_c() | sdp_o() | sdp_s() | sdp_i() | sdp_u() |
               sdp_e() | sdp_p() | sdp_b() | sdp_z() | sdp_k() |
               sdp_a() | sdp_a_rtpmap() | sdp_a_ptime() |
               sdp_t() | sdp_r() | sdp_m()
       sdp_v() = #megaco_sdp_v{} (Protocol version)
       sdp_o() = #megaco_sdp_o{} (Owner/creator and session identifier)
       sdp_s() = #megaco_sdp_s{} (Session name)
       sdp_i() = #megaco_sdp_i{} (Session information)
       sdp_u() = #megaco_sdp_u{} (URI of description)
       sdp_e() = #megaco_sdp_e{} (Email address)
       sdp_p() = #megaco_sdp_p{} (Phone number)
       sdp_c() = #megaco_sdp_c{} (Connection information)
       sdp_b() = #megaco_sdp_b{} (Bandwidth information)
       sdp_k() = #megaco_sdp_k{} (Encryption key)
       sdp_a() = #megaco_sdp_a{} (Session attribute)
       sdp_a_rtpmap() = #megaco_sdp_a_rtpmap{}
       sdp_a_ptime() = #megaco_sdp_a_ptime{}
       sdp_a_quality() = #megaco_sdp_a_quality{}
       sdp_a_fmtp() = #megaco_sdp_a_fmtp{}
       sdp_z() = #megaco_sdp_z{} (Time zone adjustment)
       sdp_t() = #megaco_sdp_t{} (Time the session is active)
       sdp_r() = #megaco_sdp_r{} (Repeat times)
       sdp_m() = #megaco_sdp_m{} (Media name and transport address)
       sdp_property_parm() = sdp() | property_parm()
       sdp_property_group() = [sdp_property_parm()]
       sdp_property_groups() = [sdp_property_group()]

       megaco_timer() = infinity | integer() >= 0 | megaco_incr_timer()
       megaco_incr_timer() = #megaco_incr_timer{}


       The record _m_e_g_a_c_o___i_n_c_r___t_i_m_e_r contains the following fields:

         _w_a_i_t___f_o_r _= _i_n_t_e_g_e_r_(_) _>_= _0:
           The actual timer time.

         _f_a_c_t_o_r _= _i_n_t_e_g_e_r_(_) _>_= _0:
           The factor when calculating the new timer time (_w_a_i_t___f_o_r).

         _i_n_c_r _= _i_n_t_e_g_e_r_(_):
           The increment value when calculating the new timer time (_w_a_i_t___f_o_r).
           Note that this value _c_a_n be negative and that a timer restart can
           therefor lead to a _w_a_i_t___f_o_r value of zero! It is up to the user to
           be aware of the consequences of a _w_a_i_t___f_o_r value of zero.

         _m_a_x___r_e_t_r_i_e_s _= _i_n_f_i_n_i_t_y _| _i_n_f_i_n_i_t_y___r_e_s_t_a_r_t_a_b_l_e _| _i_n_t_e_g_e_r_(_) _>_= _0:
           The maximum number of repetitions of the timer.

           There is a special case for this field. When the _m_a_x___r_e_t_r_i_e_s has
           the value _i_n_f_i_n_i_t_y___r_e_s_t_a_r_t_a_b_l_e, it means that the timer is
           restartable as long as some external event occurs (e.g. receipt of
           a pending message for instance). But the timer will never be
           restarted "by itself", i.e. when the timer expires (whatever the
           timeout time), so does the timer. Whenever the timer is restarted,
           the timeout time will be calculated in the usual way! Also, as
           mentioned above, beware the consequences of setting the value to
           _i_n_f_i_n_i_t_y if _i_n_c_r has been set to an negative value.

EEXXPPOORRTTSS
       ssttaarrtt(()) -->> ookk || {{eerrrroorr,, RReeaassoonn}}

              Types:

                 Reason = term()

              Starts the Megaco application

              Users may either explicitly be registered with
              megaco:start_user/2 and/or be statically configured by setting
              the application environment variable 'users' to a list of
              {UserMid, Config} tuples. See the function megaco:start_user/2
              for details.

       ssttoopp(()) -->> ookk || {{eerrrroorr,, RReeaassoonn}}

              Types:

                 Reason = term()

              Stops the Megaco application

       ssttaarrtt__uusseerr((UUsseerrMMiidd,, CCoonnffiigg)) -->> ookk || {{eerrrroorr,, RReeaassoonn}}

              Types:

                 UserMid = megaco_mid()
                 Config = [{user_info_item(), user_info_value()}]
                 Reason = term()

              Initial configuration of a user

              Requires the megaco application to be started. A user is either
              a Media Gateway (MG) or a Media Gateway Controller (MGC). One
              Erlang node may host many users.

              A user is identified by its UserMid, which must be a legal
              Megaco MID.

              Config is a list of {Item, Value} tuples. See megaco:user_info/2
              about which items and values that are valid.

       ssttoopp__uusseerr((UUsseerrMMiidd)) -->> ookk || {{eerrrroorr,, RReeaassoonn}}

              Types:

                 UserMid = megaco_mid()
                 Reason = term()

              Delete the configuration of a user

              Requires that the user does not have any active connection.

       uusseerr__iinnffoo((UUsseerrMMiidd)) -->> [[{{IItteemm,, VVaalluuee}}]]
       uusseerr__iinnffoo((UUsseerrMMiidd,, IItteemm)) -->> VVaalluuee || eexxiitt((RReeaassoonn))

              Types:

                 Handle = user_info_handle()
                 UserMid = megaco_mid()
                 Item = user_info_item()
                 Value = user_info_value()
                 Reason = term()

              Lookup user information

              The following Item's are valid:

                _c_o_n_n_e_c_t_i_o_n_s:
                  Lists all active connections for this user. Returns a list
                  of megaco_conn_handle records.

                _r_e_c_e_i_v_e___h_a_n_d_l_e:
                  Construct a megaco_receive_handle record from user config

                _t_r_a_n_s___i_d:
                  Current transaction id.

                  A positive integer or the atom _u_n_d_e_f_i_n_e_d___s_e_r_i_a_l (in case no
                  messages has been sent).

                _m_i_n___t_r_a_n_s___i_d:
                  First trans id.

                  A positive integer, defaults to 1.

                _m_a_x___t_r_a_n_s___i_d:
                  Last trans id.

                  A positive integer or _i_n_f_i_n_i_t_y, defaults to _i_n_f_i_n_i_t_y.

                _r_e_q_u_e_s_t___t_i_m_e_r:
                  Wait for reply.

                  The timer is cancelled when a reply is received.

                  When a pending message is received, the timer is cancelled
                  and the _l_o_n_g___r_e_q_u_e_s_t___t_i_m_e_r is started instead (see below).
                  No resends will be performed from this point (since we now
                  know that the other side has received the request).

                  When the timer reaches an intermediate expire, the request
                  is resent and the timer is restarted.

                  When the timer reaches the final expire, either the function
                  _m_e_g_a_c_o_:_c_a_l_l will return with _{_e_r_r_o_r_, _t_i_m_e_o_u_t_} or the
                  callback function _h_a_n_d_l_e___t_r_a_n_s___r_e_p_l_y will be called with
                  _U_s_e_r_R_e_p_l_y _= _{_e_r_r_o_r_, _t_i_m_e_o_u_t_} (if _m_e_g_a_c_o_:_c_a_s_t was used).

                  A Megaco Timer (see explanation above), defaults to
                  _#_m_e_g_a_c_o___i_n_c_r___t_i_m_e_r_{_}.

                _l_o_n_g___r_e_q_u_e_s_t___t_i_m_e_r:
                  Wait for reply after having received a pending message.

                  When the timer reaches an intermediate expire, the timer is
                  restarted.

                  When a pending message is received, and the
                  _l_o_n_g___r_e_q_u_e_s_t___t_i_m_e_r is _n_o_t "on its final leg", the timer will
                  be restarted, and, if _l_o_n_g___r_e_q_u_e_s_t___r_e_s_e_n_d _= _t_r_u_e, the
                  request will be re-sent.

                  A Megaco Timer (see explanation above), defaults to _6_0
                  _s_e_c_o_n_d_s.

                _l_o_n_g___r_e_q_u_e_s_t___r_e_s_e_n_d:
                  This option indicates weather the request should be resent
                  until the reply is received, _e_v_e_n though a pending message
                  has been received.

                  Normally, after a pending message has been received, the
                  request is not resent (since a pending message is an
                  indication that the request has been received). But since
                  the reply (to the request) can be lost, this behaviour has
                  its values.

                  It is of course pointless to set this value to _t_r_u_e unless
                  the _l_o_n_g___r_e_q_u_e_s_t___t_i_m_e_r (see above) is also set to an
                  incremental timer (_#_m_e_g_a_c_o___i_n_c_r___t_i_m_e_r_{_}).

                  A _b_o_o_l_e_a_n, defaults to _f_a_l_s_e.

                _r_e_p_l_y___t_i_m_e_r:
                  Wait for an ack.

                  When a request is received, some info related to the reply
                  is store internally (e.g. the binary of the reply). This
                  info will live until either an ack is received or this timer
                  expires. For instance, if the same request is received again
                  (e.g. a request with the same transaction id), the (stored)
                  reply will be (re-) sent automatically by megaco.

                  If the timer is of type _#_m_e_g_a_c_o___i_n_c_r___t_i_m_e_r_{_}, then for each
                  intermediate timout, the reply will be resent (this is valid
                  until the ack is received or the timer expires).

                  A Megaco Timer (see explanation above), defaults to 30000.

                _r_e_q_u_e_s_t___k_e_e_p___a_l_i_v_e___t_i_m_e_o_u_t:
                  Specifies the timeout time for the request-keep-alive timer.

                  This timer is started when the _f_i_r_s_t reply to an
                  asynchroneous request (issued using the mmeeggaaccoo::ccaasstt//33
                  function) arrives. As long as this timer is running, replies
                  will be delivered via the hhaannddllee__ttrraannss__rreeppllyy//44,,55 callback
                  function, with their "arrival number" (see _U_s_e_r_R_e_p_l_y of the
                  hhaannddllee__ttrraannss__rreeppllyy//44,,55 callback function).

                  Replies arriving after the timer has expired, will be
                  delivered using the hhaannddllee__uunneexxppeecctteedd__ttrraannss//33,,44 callback
                  function.

                  The timeout time can have the values: _p_l_a_i_n _| _i_n_t_e_g_e_r_(_) _>_=
                  _0.

                  Defaults to _p_l_a_i_n.

                _c_a_l_l___p_r_o_x_y___g_c___t_i_m_e_o_u_t:
                  Timeout time for the call proxy.

                  When a request is sent using the ccaallll//33 function, a proxy
                  process is started to handle all replies. When the reply has
                  been received and delivered to the user, the proxy process
                  continue to exist for as long as this option specifies. Any
                  received messages, is passed on to the user via the
                  hhaannddllee__uunneexxppeecctteedd__ttrraannss callback function.

                  The timeout time is in milliseconds. A value of 0 (zero)
                  means that the proxy process will exit directly after the
                  reply has been delivered.

                  An integer >= 0, defaults to 5000 (= 5 seconds).

                _a_u_t_o___a_c_k:
                  Automatic send transaction ack when the transaction reply
                  has been received (see _t_r_a_n_s___a_c_k below).

                  This is used for _t_h_r_e_e_-_w_a_y_-_h_a_n_d_s_h_a_k_e.

                  A _b_o_o_l_e_a_n, defaults to _f_a_l_s_e.

                _t_r_a_n_s___a_c_k:
                  Shall ack's be accumulated or not.

                  This property is only valid if _a_u_t_o___a_c_k is true.

                  If _a_u_t_o___a_c_k is true, then if _t_r_a_n_s___a_c_k is _f_a_l_s_e, ack's will
                  be sent immediately. If _t_r_a_n_s___a_c_k is _t_r_u_e, then ack's will
                  instead be sent to the transaction sender process for
                  accumulation and later sending (see _t_r_a_n_s___a_c_k___m_a_x_c_o_u_n_t,
                  _t_r_a_n_s___r_e_q___m_a_x_c_o_u_n_t, _t_r_a_n_s___r_e_q___m_a_x_s_i_z_e, _t_r_a_n_s___a_c_k___m_a_x_c_o_u_n_t
                  and _t_r_a_n_s___t_i_m_e_r).

                  See also ttrraannssaaccttiioonn sseennddeerr for more info.

                  An _b_o_o_l_e_a_n, defaults to _f_a_l_s_e.

                _t_r_a_n_s___a_c_k___m_a_x_c_o_u_n_t:
                  Maximum number of accumulated ack's. At most this many ack's
                  will be accumulated by the transaction sender (if started
                  and configured to accumulate ack's).

                  See also ttrraannssaaccttiioonn sseennddeerr for more info.

                  An _i_n_t_e_g_e_r, defaults to 10.

                _t_r_a_n_s___r_e_q:
                  Shall requests be accumulated or not.

                  If _t_r_a_n_s___r_e_q is _f_a_l_s_e, then request(s) will be sent
                  immediately (in its own message).

                  If _t_r_a_n_s___r_e_q is true, then request(s) will instead be sent
                  to the transaction sender process for accumulation and later
                  sending (see _t_r_a_n_s___a_c_k___m_a_x_c_o_u_n_t, _t_r_a_n_s___r_e_q___m_a_x_c_o_u_n_t,
                  _t_r_a_n_s___r_e_q___m_a_x_s_i_z_e, _t_r_a_n_s___a_c_k___m_a_x_c_o_u_n_t and _t_r_a_n_s___t_i_m_e_r).

                  See also ttrraannssaaccttiioonn sseennddeerr for more info.

                  An _b_o_o_l_e_a_n, defaults to _f_a_l_s_e.

                _t_r_a_n_s___r_e_q___m_a_x_c_o_u_n_t:
                  Maximum number of accumulated requests. At most this many
                  requests will be accumulated by the transaction sender (if
                  started and configured to accumulate requests).

                  See also ttrraannssaaccttiioonn sseennddeerr for more info.

                  An _i_n_t_e_g_e_r, defaults to 10.

                _t_r_a_n_s___r_e_q___m_a_x_s_i_z_e:
                  Maximum size of the accumulated requests. At most this much
                  requests will be accumulated by the transaction sender (if
                  started and configured to accumulate requests).

                  See also ttrraannssaaccttiioonn sseennddeerr for more info.

                  An _i_n_t_e_g_e_r, defaults to 2048.

                _t_r_a_n_s___t_i_m_e_r:
                  Transaction sender timeout time. Has two functions. First,
                  if the value is 0, then transactions will not be accumulated
                  (e.g. the transaction sender process will not be started).
                  Second, if the value is greater then 0 and _a_u_t_o___a_c_k and
                  _t_r_a_n_s___a_c_k are both true or if _t_r_a_n_s___r_e_q is true, then
                  transaction sender will be started and transactions (which
                  is depending on the values of _a_u_t_o___a_c_k, _t_r_a_n_s___a_c_k and
                  _t_r_a_n_s___r_e_q) will be accumulated, for later sending.

                  See also ttrraannssaaccttiioonn sseennddeerr for more info.

                  An _i_n_t_e_g_e_r, defaults to 0.

                _p_e_n_d_i_n_g___t_i_m_e_r:
                  Automatically send pending if the timer expires before a
                  transaction reply has been sent. This timer is also called
                  provisional response timer.

                  A Megaco Timer (see explanation above), defaults to 30000.

                _s_e_n_t___p_e_n_d_i_n_g___l_i_m_i_t:
                  Sent pending limit (see the MGOriginatedPendingLimit and the
                  MGCOriginatedPendingLimit of the megaco root package). This
                  parameter specifies how many pending messages that can be
                  sent (for a given received transaction request). When the
                  limit is exceeded, the transaction is aborted (see
                  hhaannddllee__ttrraannss__rreeqquueesstt__aabboorrtt) and an error message is sent to
                  the other side.

                  Note that this has no effect on the actual sending of
                  pending transactions. This is either implicit (e.g. when
                  receiving a re-sent transaction request for a request which
                  is being processed) or controlled by the pending_timer, see
                  above.

                  A positive integer or _i_n_f_i_n_i_t_y, defaults to _i_n_f_i_n_i_t_y.

                _r_e_c_v___p_e_n_d_i_n_g___l_i_m_i_t:
                  Receive pending limit (see the MGOriginatedPendingLimit and
                  the MGCOriginatedPendingLimit of the megaco root package).
                  This parameter specifies how many pending messages that can
                  be received (for a sent transaction request). When the limit
                  is exceeded, the transaction is considered lost, and an
                  error returned to the user (through the call-back function
                  _h_a_n_d_l_e___t_r_a_n_s___r_e_p_l_y).

                  A positive integer or _i_n_f_i_n_i_t_y, defaults to _i_n_f_i_n_i_t_y.

                _s_e_n_d___m_o_d:
                  Send callback module which exports send_message/2. The
                  function SendMod:send_message(SendHandle, Binary) is invoked
                  when the bytes needs to be transmitted to the remote user.

                  An _a_t_o_m, defaults to _m_e_g_a_c_o___t_c_p.

                _e_n_c_o_d_i_n_g___m_o_d:
                  Encoding callback module which exports encode_message/2 and
                  decode_message/2. The function
                  EncodingMod:encode_message(EncodingConfig, MegacoMessage) is
                  invoked whenever a 'MegacoMessage' record needs to be
                  translated into an Erlang binary. The function
                  EncodingMod:decode_message(EncodingConfig, Binary) is
                  invoked whenever an Erlang binary needs to be translated
                  into a 'MegacoMessage' record.

                  An _a_t_o_m, defaults to _m_e_g_a_c_o___p_r_e_t_t_y___t_e_x_t___e_n_c_o_d_e_r.

                _e_n_c_o_d_i_n_g___c_o_n_f_i_g:
                  Encoding module config.

                  A _l_i_s_t, defaults to _[_].

                _p_r_o_t_o_c_o_l___v_e_r_s_i_o_n:
                  Actual protocol version.

                  An _i_n_t_e_g_e_r, default is 1.

                _s_t_r_i_c_t___v_e_r_s_i_o_n:
                  Strict version control, i.e. when a message is received,
                  verify that the version is that which was negotiated.

                  An _b_o_o_l_e_a_n, default is true.

                _r_e_p_l_y___d_a_t_a:
                  Default reply data.

                  Any term, defaults to the atom _u_n_d_e_f_i_n_e_d.

                _u_s_e_r___m_o_d:
                  Name of the user callback module. See the the reference
                  manual for megaco_user for more info.

                _u_s_e_r___a_r_g_s:
                  List of extra arguments to the user callback functions. See
                  the the reference manual for megaco_user for more info.

                _t_h_r_e_a_d_e_d:
                  If a received message contains several transaction requests,
                  this option indicates whether the requests should be handled
                  sequentially in the same process (_f_a_l_s_e), or if each request
                  should be handled by its own process (_t_r_u_e i.e. a separate
                  process is spawned for each request).

                  An _b_o_o_l_e_a_n, defaults to _f_a_l_s_e.

                _r_e_s_e_n_d___i_n_d_i_c_a_t_i_o_n:
                  This option indicates weather the transport module should be
                  told if a message send is a resend or not.

                  If _f_a_l_s_e, megaco messages are sent using the sseenndd__mmeessssaaggee
                  function.

                  If _t_r_u_e, megaco message _r_e_-_s_e_n_d_s are made using the
                  rreesseenndd__mmeessssaaggee function. The initial message send is still
                  done using the sseenndd__mmeessssaaggee function.

                  The special value _f_l_a_g instead indicates that the function
                  sseenndd__mmeessssaaggee//33 shall be used.

                  A _r_e_s_e_n_d___i_n_d_i_c_a_t_i_o_n_(_), defaults to _f_a_l_s_e.

                _s_e_g_m_e_n_t___r_e_p_l_y___i_n_d:
                  This option specifies if the user shall be notified of
                  received segment replies or not.

                  See hhaannddllee__sseeggmmeenntt__rreeppllyy callback function for more
                  information.

                  A _b_o_o_l_e_a_n, defaults to _f_a_l_s_e.

                _s_e_g_m_e_n_t___r_e_c_v___t_i_m_e_r:
                  This timer is started when the segment indicated by the
                  _s_e_g_m_e_n_t_a_t_i_o_n _c_o_m_p_l_e_t_e _t_o_k_e_n is received, but all segments
                  has not yet been received.

                  When the timer finally expires, a "megaco segments not
                  received" (459) error message is sent to the other side and
                  the user is notified with a _s_e_g_m_e_n_t _t_i_m_e_o_u_t _U_s_e_r_R_e_p_l_y in
                  either the hhaannddllee__ttrraannss__rreeppllyy callback function or the
                  return value of the ccaallll function.

                  A Megaco Timer (see explanation above), defaults to _1_0_0_0_0.

                _s_e_g_m_e_n_t___s_e_n_d:
                  Shall outgoing messages be segmented or not:

                  _n_o_n_e:
                    Do not segment outgoing reply messages. This is useful
                    when either it is known that messages are never to large
                    or that the transport protocol can handle such things on
                    its own (e.g. TCP or SCTP).

                  _i_n_t_e_g_e_r_(_) _> _0:
                    Outgoing reply messages will be segmented as needed (see
                    _m_a_x___p_d_u___s_i_z_e below). This value, K, indicate the
                    outstanding window, i.e. how many segments can be
                    outstanding (not acknowledged) at any given time.

                  _i_n_f_i_n_i_t_y:
                    Outgoing reply messages will be segmented as needed (see
                    _m_a_x___p_d_u___s_i_z_e below). Segment messages are sent all at once
                    (i.e. no acknowledgement awaited before sending the next
                    segment).

                  Defaults to _n_o_n_e.

                _m_a_x___p_d_u___s_i_z_e:
                  Max message size. If the encoded message (PDU) exceeds this
                  size, the message should be segmented, and then encoded.

                  A positive integer or _i_n_f_i_n_i_t_y, defaults to _i_n_f_i_n_i_t_y.

       uuppddaattee__uusseerr__iinnffoo((UUsseerrMMiidd,, IItteemm,, VVaalluuee)) -->> ookk || {{eerrrroorr,, RReeaassoonn}}

              Types:

                 UserMid = megaco_mid()
                 Item = user_info_item()
                 Value = user_info_value()
                 Reason = term()

              Update information about a user

              Requires that the user is started. See megaco:user_info/2 about
              which items and values that are valid.

       ccoonnnn__iinnffoo((CCoonnnnHHaannddllee)) -->> [[{{IItteemm,, VVaalluuee}}]]
       ccoonnnn__iinnffoo((CCoonnnnHHaannddllee,, IItteemm)) -->> VVaalluuee || eexxiitt((RReeaassoonn))

              Types:

                 ConnHandle = #megaco_conn_handle{}
                 Item = conn_info_item()
                 Value = conn_info_value()
                 Reason = {no_such_connection, ConnHandle} | term()

              Lookup information about an active connection

              Requires that the connection is active.

                _c_o_n_t_r_o_l___p_i_d:
                  The process identifier of the controlling process for a
                  connection.

                _s_e_n_d___h_a_n_d_l_e:
                  Opaque send handle whose contents is internal for the send
                  module. May be any term.

                _l_o_c_a_l___m_i_d:
                  The local mid (of the connection, i.e. the own mid).
                  _m_e_g_a_c_o___m_i_d_(_).

                _r_e_m_o_t_e___m_i_d:
                  The remote mid (of the connection). _m_e_g_a_c_o___m_i_d_(_).

                _r_e_c_e_i_v_e___h_a_n_d_l_e:
                  Construct a megaco_receive_handle record.

                _t_r_a_n_s___i_d:
                  Next transaction id. A positive integer or the atom
                  _u_n_d_e_f_i_n_e_d___s_e_r_i_a_l (only in case of error).

                  Note that transaction id's are (currently) maintained on a
                  per user basis so there is no way to be sure that the value
                  returned will actually be used for a transaction sent on
                  this connection (in case a user has several connections,
                  which is not at all unlikely).

                _m_a_x___t_r_a_n_s___i_d:
                  Last trans id.

                  A positive integer or _i_n_f_i_n_i_t_y, defaults to _i_n_f_i_n_i_t_y.

                _r_e_q_u_e_s_t___t_i_m_e_r:
                  Wait for reply.

                  The timer is cancelled when a reply is received.

                  When a pending message is received, the timer is cancelled
                  and the _l_o_n_g___r_e_q_u_e_s_t___t_i_m_e_r is started instead (see below).
                  No resends will be performed from this point (since we now
                  know that the other side has received the request).

                  When the timer reaches an intermediate expire, the request
                  is resent and the timer is restarted.

                  When the timer reaches the final expire, either the function
                  _m_e_g_a_c_o_:_c_a_l_l will return with _{_e_r_r_o_r_, _t_i_m_e_o_u_t_} or the
                  callback function _h_a_n_d_l_e___t_r_a_n_s___r_e_p_l_y will be called with
                  _U_s_e_r_R_e_p_l_y _= _{_e_r_r_o_r_, _t_i_m_e_o_u_t_} (if _m_e_g_a_c_o_:_c_a_s_t was used).

                  A Megaco Timer (see explanation above), defaults to
                  #megaco_incr_timer{}.

                _l_o_n_g___r_e_q_u_e_s_t___t_i_m_e_r:
                  Wait for reply after having received a pending message.

                  When the timer reaches an intermediate expire, the timer
                  restarted.

                  When a pending message is received, and the
                  _l_o_n_g___r_e_q_u_e_s_t___t_i_m_e_r is _n_o_t "on its final leg", the timer will
                  be restarted, and, if _l_o_n_g___r_e_q_u_e_s_t___r_e_s_e_n_d _= _t_r_u_e, the
                  request will be re-sent.

                  A Megaco Timer (see explanation above), defaults to _6_0
                  _s_e_c_o_n_d_s.

                _r_e_q_u_e_s_t___k_e_e_p___a_l_i_v_e___t_i_m_e_o_u_t:
                  Specifies the timeout time for the request-keep-alive timer.

                  This timer is started when the _f_i_r_s_t reply to an
                  asynchroneous request (issued using the mmeeggaaccoo::ccaasstt//33
                  function) arrives. As long as this timer is running, replies
                  will be delivered via the hhaannddllee__ttrraannss__rreeppllyy//44,,55 callback
                  function, with their "arrival number" (see _U_s_e_r_R_e_p_l_y of the
                  hhaannddllee__ttrraannss__rreeppllyy//44,,55 callback function).

                  Replies arriving after the timer has expired, will be
                  delivered using the hhaannddllee__uunneexxppeecctteedd__ttrraannss//33,,44 callback
                  function.

                  The timeout time can have the values: _p_l_a_i_n _| _i_n_t_e_g_e_r_(_) _>_=
                  _0.

                  Defaults to _p_l_a_i_n.

                _l_o_n_g___r_e_q_u_e_s_t___r_e_s_e_n_d:
                  This option indicates weather the request should be resent
                  until the reply is received, _e_v_e_n though a pending message
                  has been received.

                  Normally, after a pending message has been received, the
                  request is not resent (since a pending message is an
                  indication that the request has been received). But since
                  the reply (to the request) can be lost, this behaviour has
                  its values.

                  It is of course pointless to set this value to _t_r_u_e unless
                  the _l_o_n_g___r_e_q_u_e_s_t___t_i_m_e_r (see above) is also set to an
                  incremental timer (_#_m_e_g_a_c_o___i_n_c_r___t_i_m_e_r_{_}).

                  A _b_o_o_l_e_a_n, defaults to _f_a_l_s_e.

                _r_e_p_l_y___t_i_m_e_r:
                  Wait for an ack.

                  When a request is received, some info related to the reply
                  is store internally (e.g. the binary of the reply). This
                  info will live until either an ack is received or this timer
                  expires. For instance, if the same request is received again
                  (e.g. a request with the same transaction id), the (stored)
                  reply will be (re-) sent automatically by megaco.

                  If the timer is of type _#_m_e_g_a_c_o___i_n_c_r___t_i_m_e_r_{_}, then for each
                  intermediate timout, the reply will be resent (this is valid
                  until the ack is received or the timer expires).

                  A Megaco Timer (see explanation above), defaults to 30000.

                _c_a_l_l___p_r_o_x_y___g_c___t_i_m_e_o_u_t:
                  Timeout time for the call proxy.

                  When a request is sent using the ccaallll//33 function, a proxy
                  process is started to handle all replies. When the reply has
                  been received and delivered to the user, the proxy process
                  continue to exist for as long as this option specifies. Any
                  received messages, is passed on to the user via the
                  hhaannddllee__uunneexxppeecctteedd__ttrraannss callback function.

                  The timeout time is in milliseconds. A value of 0 (zero)
                  means that the proxy process will exit directly after the
                  reply has been delivered.

                  An integer >= 0, defaults to 5000 (= 5 seconds).

                _a_u_t_o___a_c_k:
                  Automatic send transaction ack when the transaction reply
                  has been received (see _t_r_a_n_s___a_c_k below).

                  This is used for _t_h_r_e_e_-_w_a_y_-_h_a_n_d_s_h_a_k_e.

                  A _b_o_o_l_e_a_n, defaults to _f_a_l_s_e.

                _t_r_a_n_s___a_c_k:
                  Shall ack's be accumulated or not.

                  This property is only valid if _a_u_t_o___a_c_k is true.

                  If _a_u_t_o___a_c_k is true, then if _t_r_a_n_s___a_c_k is _f_a_l_s_e, ack's will
                  be sent immediately. If _t_r_a_n_s___a_c_k is _t_r_u_e, then ack's will
                  instead be sent to the transaction sender process for
                  accumulation and later sending (see _t_r_a_n_s___a_c_k___m_a_x_c_o_u_n_t,
                  _t_r_a_n_s___r_e_q___m_a_x_c_o_u_n_t, _t_r_a_n_s___r_e_q___m_a_x_s_i_z_e, _t_r_a_n_s___a_c_k___m_a_x_c_o_u_n_t
                  and _t_r_a_n_s___t_i_m_e_r).

                  See also ttrraannssaaccttiioonn sseennddeerr for more info.

                  An _b_o_o_l_e_a_n, defaults to _f_a_l_s_e.

                _t_r_a_n_s___a_c_k___m_a_x_c_o_u_n_t:
                  Maximum number of accumulated ack's. At most this many ack's
                  will be accumulated by the transaction sender (if started
                  and configured to accumulate ack's).

                  See also ttrraannssaaccttiioonn sseennddeerr for more info.

                  An integer, defaults to 10.

                _t_r_a_n_s___r_e_q:
                  Shall requests be accumulated or not.

                  If _t_r_a_n_s___r_e_q is _f_a_l_s_e, then request(s) will be sent
                  immediately (in its own message).

                  If _t_r_a_n_s___r_e_q is true, then request(s) will instead be sent
                  to the transaction sender process for accumulation and later
                  sending (see _t_r_a_n_s___a_c_k___m_a_x_c_o_u_n_t, _t_r_a_n_s___r_e_q___m_a_x_c_o_u_n_t,
                  _t_r_a_n_s___r_e_q___m_a_x_s_i_z_e, _t_r_a_n_s___a_c_k___m_a_x_c_o_u_n_t and _t_r_a_n_s___t_i_m_e_r).

                  See also ttrraannssaaccttiioonn sseennddeerr for more info.

                  An _b_o_o_l_e_a_n, defaults to _f_a_l_s_e.

                _t_r_a_n_s___r_e_q___m_a_x_c_o_u_n_t:
                  Maximum number of accumulated requests. At most this many
                  requests will be accumulated by the transaction sender (if
                  started and configured to accumulate requests).

                  See also ttrraannssaaccttiioonn sseennddeerr for more info.

                  An _i_n_t_e_g_e_r, defaults to 10.

                _t_r_a_n_s___r_e_q___m_a_x_s_i_z_e:
                  Maximum size of the accumulated requests. At most this much
                  requests will be accumulated by the transaction sender (if
                  started and configured to accumulate requests).

                  See also ttrraannssaaccttiioonn sseennddeerr for more info.

                  An _i_n_t_e_g_e_r, defaults to 2048.

                _t_r_a_n_s___t_i_m_e_r:
                  Transaction sender timeout time. Has two functions. First,
                  if the value is 0, then transactions will not be accumulated
                  (e.g. the transaction sender process will not be started).
                  Second, if the value is greater then 0 and _a_u_t_o___a_c_k and
                  _t_r_a_n_s___a_c_k is true or if _t_r_a_n_s___r_e_q is true, then transaction
                  sender will be started and transactions (which is depending
                  on the values of _a_u_t_o___a_c_k, _t_r_a_n_s___a_c_k and _t_r_a_n_s___r_e_q) will be
                  accumulated, for later sending.

                  See also ttrraannssaaccttiioonn sseennddeerr for more info.

                  An _i_n_t_e_g_e_r, defaults to 0.

                _p_e_n_d_i_n_g___t_i_m_e_r:
                  Automatic send transaction pending if the timer expires
                  before a transaction reply has been sent. This timer is also
                  called provisional response timer.

                  A Megaco Timer (see explanation above), defaults to 30000.

                _s_e_n_t___p_e_n_d_i_n_g___l_i_m_i_t:
                  Sent pending limit (see the MGOriginatedPendingLimit and the
                  MGCOriginatedPendingLimit of the megaco root package). This
                  parameter specifies how many pending messages that can be
                  sent (for a given received transaction request). When the
                  limit is exceeded, the transaction is aborted (see
                  hhaannddllee__ttrraannss__rreeqquueesstt__aabboorrtt) and an error message is sent to
                  the other side.

                  Note that this has no effect on the actual sending of
                  pending transactions. This is either implicit (e.g. when
                  receiving a re-sent transaction request for a request which
                  is being processed) or controlled by the pending_timer, see
                  above.

                  A positive integer or _i_n_f_i_n_i_t_y, defaults to _i_n_f_i_n_i_t_y.

                _r_e_c_v___p_e_n_d_i_n_g___l_i_m_i_t:
                  Receive pending limit (see the MGOriginatedPendingLimit and
                  the MGCOriginatedPendingLimit of the megaco root package).
                  This parameter specifies how many pending messages that can
                  be received (for a sent transaction request). When the limit
                  is exceeded, the transaction is considered lost, and an
                  error returned to the user (through the call-back function
                  _h_a_n_d_l_e___t_r_a_n_s___r_e_p_l_y).

                  A positive integer or _i_n_f_i_n_i_t_y, defaults to _i_n_f_i_n_i_t_y.

                _s_e_n_d___m_o_d:
                  Send callback module which exports send_message/2. The
                  function SendMod:send_message(SendHandle, Binary) is invoked
                  when the bytes needs to be transmitted to the remote user.

                  An _a_t_o_m, defaults to _m_e_g_a_c_o___t_c_p.

                _e_n_c_o_d_i_n_g___m_o_d:
                  Encoding callback module which exports encode_message/2 and
                  decode_message/2. The function
                  EncodingMod:encode_message(EncodingConfig, MegacoMessage) is
                  invoked whenever a 'MegacoMessage' record needs to be
                  translated into an Erlang binary. The function
                  EncodingMod:decode_message(EncodingConfig, Binary) is
                  invoked whenever an Erlang binary needs to be translated
                  into a 'MegacoMessage' record.

                  An _a_t_o_m, defaults to _m_e_g_a_c_o___p_r_e_t_t_y___t_e_x_t___e_n_c_o_d_e_r.

                _e_n_c_o_d_i_n_g___c_o_n_f_i_g:
                  Encoding module config.

                  A _l_i_s_t, defaults to [].

                _p_r_o_t_o_c_o_l___v_e_r_s_i_o_n:
                  Actual protocol version.

                  An positive integer, Current default is 1.

                _s_t_r_i_c_t___v_e_r_s_i_o_n:
                  Strict version control, i.e. when a message is received,
                  verify that the version is that which was negotiated.

                  An _b_o_o_l_e_a_n, default is true.

                _r_e_p_l_y___d_a_t_a:
                  Default reply data.

                  Any term, defaults to the atom _u_n_d_e_f_i_n_e_d.

                _t_h_r_e_a_d_e_d:
                  If a received message contains several transaction requests,
                  this option indicates whether the requests should be handled
                  sequentially in the same process (_f_a_l_s_e), or if each request
                  should be handled by its own process (_t_r_u_e i.e. a separate
                  process is spawned for each request).

                  An _b_o_o_l_e_a_n, defaults to _f_a_l_s_e.

                _r_e_s_e_n_d___i_n_d_i_c_a_t_i_o_n:
                  This option indicates weather the transport module should be
                  told if a message send is a resend or not.

                  If _f_a_l_s_e, megaco messages are sent using the sseenndd__mmeessssaaggee//22
                  function.

                  If _t_r_u_e, megaco message _r_e_-_s_e_n_d_s are made using the
                  rreesseenndd__mmeessssaaggee function. The initial message send is still
                  done using the sseenndd__mmeessssaaggee function.

                  The special value _f_l_a_g instead indicates that the function
                  sseenndd__mmeessssaaggee//33 shall be used.

                  A _r_e_s_e_n_d___i_n_d_i_c_a_t_i_o_n_(_), defaults to _f_a_l_s_e.

                _s_e_g_m_e_n_t___r_e_p_l_y___i_n_d:
                  This option specifies if the user shall be notified of
                  received segment replies or not.

                  See hhaannddllee__sseeggmmeenntt__rreeppllyy callback function for more
                  information.

                  A _b_o_o_l_e_a_n, defaults to _f_a_l_s_e.

                _s_e_g_m_e_n_t___r_e_c_v___t_i_m_e_r:
                  This timer is started when the segment indicated by the
                  _s_e_g_m_e_n_t_a_t_i_o_n _c_o_m_p_l_e_t_e _t_o_k_e_n (e.g. the last of the segment
                  which makes up the reply) is received, but all segments has
                  not yet been received.

                  When the timer finally expires, a "megaco segments not
                  received" (459) error message is sent to the other side and
                  the user is notified with a _s_e_g_m_e_n_t _t_i_m_e_o_u_t _U_s_e_r_R_e_p_l_y in
                  either the hhaannddllee__ttrraannss__rreeppllyy callback function or the
                  return value of the ccaallll function.

                  A Megaco Timer (see explanation above), defaults to _1_0_0_0_0.

                _s_e_g_m_e_n_t___s_e_n_d:
                  Shall outgoing messages be segmented or not:

                  _n_o_n_e:
                    Do not segment outgoing reply messages. This is useful
                    when either it is known that messages are never to large
                    or that the transport protocol can handle such things on
                    its own (e.g. TCP or SCTP).

                  _i_n_t_e_g_e_r_(_) _> _0:
                    Outgoing reply messages will be segmented as needed (see
                    _m_a_x___p_d_u___s_i_z_e below). This value, K, indicate the
                    outstanding window, i.e. how many segments can be
                    outstanding (not acknowledged) at any given time.

                  _i_n_f_i_n_i_t_y:
                    Outgoing reply messages will be segmented as needed (see
                    _m_a_x___p_d_u___s_i_z_e below). Segment messages are sent all at once
                    (i.e. no acknowledgement awaited before sending the next
                    segment).

                  Defaults to _n_o_n_e.

                _m_a_x___p_d_u___s_i_z_e:
                  Max message size. If the encoded message (PDU) exceeds this
                  size, the message should be segmented, and then encoded.

                  A positive integer or _i_n_f_i_n_i_t_y, defaults to _i_n_f_i_n_i_t_y.

       uuppddaattee__ccoonnnn__iinnffoo((CCoonnnnHHaannddllee,, IItteemm,, VVaalluuee)) -->> ookk || {{eerrrroorr,, RReeaassoonn}}

              Types:

                 ConnHandle = #megaco_conn_handle{}
                 Item = conn_info_item()
                 Value = conn_info_value()
                 Reason = term()

              Update information about an active connection

              Requires that the connection is activated. See
              megaco:conn_info/2 about which items and values that are valid.

       ssyysstteemm__iinnffoo(()) -->> [[{{IItteemm,, VVaalluuee}}]] || eexxiitt((RReeaassoonn))
       ssyysstteemm__iinnffoo((IItteemm)) -->> VVaalluuee || eexxiitt((RReeaassoonn))

              Types:

                 Item = system_info_item()

              Lookup system information

              The following items are valid:

                _t_e_x_t___c_o_n_f_i_g:
                  The text encoding config.

                _c_o_n_n_e_c_t_i_o_n_s:
                  Lists all active connections. Returns a list of
                  megaco_conn_handle records.

                _u_s_e_r_s:
                  Lists all active users. Returns a list of megaco_mid()'s.

                _n___a_c_t_i_v_e___r_e_q_u_e_s_t_s:
                  Returns an integer representing the number of requests that
                  has originated from this Erlang node and still are active
                  (and therefore consumes system resources).

                _n___a_c_t_i_v_e___r_e_p_l_i_e_s:
                  Returns an integer representing the number of replies that
                  has originated from this Erlang node and still are active
                  (and therefore consumes system resources).

                _n___a_c_t_i_v_e___c_o_n_n_e_c_t_i_o_n_s:
                  Returns an integer representing the number of active
                  connections.

       iinnffoo(()) -->> IInnffoo

              Types:

                 Info = [{Key, Value}]

              This function produces a list of information about the megaco
              application. Such as users and their config, connections and
              their config, statistics and so on.

              This information can be produced by the functions uusseerr__iinnffoo,
              ccoonnnn__iinnffoo, ssyysstteemm__iinnffoo and ggeett__ssttaattss but this is a simple way to
              get it all at once.

       ccoonnnneecctt((RReecceeiivveeHHaannddllee,, RReemmootteeMMiidd,, SSeennddHHaannddllee,, CCoonnttrroollPPiidd)) -->> {{ookk,,
       CCoonnnnHHaannddllee}} || {{eerrrroorr,, RReeaassoonn}}
       ccoonnnneecctt((RReecceeiivveeHHaannddllee,, RReemmootteeMMiidd,, SSeennddHHaannddllee,, CCoonnttrroollPPiidd,, EExxttrraa)) -->>
       {{ookk,, CCoonnnnHHaannddllee}} || {{eerrrroorr,, RReeaassoonn}}

              Types:

                 ReceiveHandle = #megaco_receive_handle{}
                 RemoteMid = preliminary_mid | megaco_mid()
                 SendHandle = term()
                 ControlPid = pid()
                 ConnHandle = #megaco_conn_handle{}
                 Reason = connect_reason() | handle_connect_reason() | term()
                 connect_reason() = {no_such_user, LocalMid} |
                 {already_connected, ConnHandle} | term()
                 handle_connect_error() = {connection_refused, ConnData,
                 ErrorInfo} | term()
                 LocalMid = megaco_mid()
                 ConnData = term()
                 ErrorInfo = term()
                 Extra = term()

              Establish a "virtual" connection

              Activates a connection to a remote user. When this is done the
              connection can be used to send messages (with
              SendMod:send_message/2). The ControlPid is the identifier of a
              process that controls the connection. That process will be
              supervised and if it dies, this will be detected and the
              UserMod:handle_disconnect/2 callback function will be invoked.
              See the megaco_user module for more info about the callback
              arguments. The connection may also explicitly be deactivated by
              invoking megaco:disconnect/2.

              The ControlPid may be the identity of a process residing on
              another Erlang node. This is useful when you want to distribute
              a user over several Erlang nodes. In such a case one of the
              nodes has the physical connection. When a user residing on one
              of the other nodes needs to send a request (with megaco:call/3
              or megaco:cast/3), the message will encoded on the originating
              Erlang node, and then be forwarded to the node with the physical
              connection. When the reply arrives, it will be forwarded back to
              the originator. The distributed connection may explicitly be
              deactivated by a local call to megaco:disconnect/2 or implicitly
              when the physical connection is deactivated (with
              megaco:disconnect/2, killing the controlling process, halting
              the other node, ...).

              The call of this function will trigger the callback function
              UserMod:handle_connect/2 to be invoked. See the megaco_user
              module for more info about the callback arguments.

              A connection may be established in several ways:

                _p_r_o_v_i_s_i_o_n_e_d _M_I_D:
                  The MG may explicitly invoke megaco:connect/4 and use a
                  provisioned MID of the MGC as the RemoteMid.

                _u_p_g_r_a_d_e _p_r_e_l_i_m_i_n_a_r_y _M_I_D:
                  The MG may explicitly invoke megaco:connect/4 with the atom
                  'preliminary_mid' as a temporary MID of the MGC, send an
                  intial message, the Service Change Request, to the MGC and
                  then wait for an initial message, the Service Change Reply.
                  When the reply arrives, the Megaco application will pick the
                  MID of the MGC from the message header and automatically
                  upgrade the connection to be a "normal" connection. By using
                  this method of establishing the connection, the callback
                  function UserMod:handle_connect/2 to be invoked twice. First
                  with a ConnHandle with the remote_mid-field set to
                  preliminary_mid, and then when the connection upgrade is
                  done with the remote_mid-field set to the actual MID of the
                  MGC.

                _a_u_t_o_m_a_t_i_c:
                  When the MGC receives its first message, the Service Change
                  Request, the Megaco application will automatically establish
                  the connection by using the MG MID found in the message
                  header as remote mid.

                _d_i_s_t_r_i_b_u_t_e_d:
                  When a user (MG/MGC) is distributed over several nodes, it
                  is required that the node hosting the connection already has
                  activated the connection and that it is in the "normal"
                  state. The RemoteMid must be a real Megaco MID and not a
                  preliminary_mid.

              An initial megaco_receive_handle record may be obtained with
              megaco:user_info(UserMid, receive_handle)

              The send handle is provided by the preferred transport module,
              e.g. megaco_tcp, megaco_udp. Read the documentation about each
              transport module about the details.

              The connect is done in two steps: first an internal _c_o_n_n_e_c_t_i_o_n
              _s_e_t_u_p and then by calling the user hhaannddllee__ccoonnnneecctt callback
              function. The first step could result in an error with _R_e_a_s_o_n _=
              _c_o_n_n_e_c_t___r_e_a_s_o_n_(_) and the second an error with _R_e_a_s_o_n _=
              _h_a_n_d_l_e___c_o_n_n_e_c_t___r_e_a_s_o_n_(_):

                _c_o_n_n_e_c_t___r_e_a_s_o_n_(_):
                  An error with this reason is generated by the megaco
                  application itself.

                _h_a_n_d_l_e___c_o_n_n_e_c_t___r_e_a_s_o_n_(_):
                  An error with this reason is caused by the user
                  hhaannddllee__ccoonnnneecctt callback function either returning an error
                  or an invalid value.

              _E_x_t_r_a can be any _t_e_r_m_(_) except the atom _i_g_n_o_r_e___e_x_t_r_a. It is
              passed (back) to the user via the callback function
              hhaannddllee__ccoonnnneecctt//33.

       ddiissccoonnnneecctt((CCoonnnnHHaannddllee,, DDiissccooRReeaassoonn)) -->> ookk || {{eerrrroorr,, EErrrrRReeaassoonn}}

              Types:

                 ConnHandle = conn_handle()
                 DiscoReason = term()
                 ErrReason = term()

              Tear down a "virtual" connection

              Causes the UserMod:handle_disconnect/2 callback function to be
              invoked. See the megaco_user module for more info about the
              callback arguments.

       ccaallll((CCoonnnnHHaannddllee,, AAccttiioonnss,, OOppttiioonnss)) -->> {{PPrroottooccoollVVeerrssiioonn,, UUsseerrRReeppllyy}}

              Types:

                 ConnHandle = conn_handle()
                 Actions = action_reqs() | [action_reqs()]
                 action_reqs() = binary() | [action_request()]
                 Options = [send_option()]
                 send_option() = {request_timer, megaco_timer()} |
                 {long_request_timer, megaco_timer()} | {send_handle, term()}
                 | {protocol_version, integer()} | {call_proxy_gc_timeout,
                 call_proxy_gc_timeout()}
                 ProtocolVersion = integer()
                 UserReply = user_reply() | [user_reply()]
                 user_reply() = success() | failure()
                 success() = {ok, result()} | {ok, result(), extra()}
                 result() = message_result() | segment_result()
                 message_result() = action_reps()
                 segment_result() = segments_ok()
                 failure() = {error, reason()} | {error, reason(), extra()}
                 reason() = message_reason() | segment_reason() |
                 user_cancel_reason() | send_reason() | other_reason()
                 message_reason() = error_desc()
                 segment_reason() = {segment, segments_ok(), segments_err()} |
                 {segment_timeout, missing_segments(), segments_ok(),
                 segments_err()}
                 segments_ok() = [segment_ok()]
                 segment_ok() = {segment_no(), action_reps()}
                 segments_err() = [segment_err()]
                 segment_err() = {segment_no(), error_desc()}
                 missing_segments() = [segment_no()]
                 user_cancel_reason() = {user_cancel,
                 reason_for_user_cancel()}
                 reason_for_user_cancel() = term()
                 send_reason() = send_cancelled_reason() |
                 send_failed_reason()
                 send_cancelled_reason() = {send_message_cancelled,
                 reason_for_send_cancel()}
                 reason_for_send_cancel() = term()
                 send_failed_reason() = {send_message_failed,
                 reason_for_send_failure()}
                 reason_for_send_failure() = term()
                 other_reason() = {wrong_mid, WrongMid, RightMid, TR} | term()
                 WrongMid = mid()
                 RightMid = mid()
                 TR = transaction_reply()
                 action_reps() = [action_reply()]
                 call_proxy_gc_timeout() = integer() >= 0
                 extra() = term()

              Sends one or more transaction request(s) and waits for the
              reply.

              When sending one transaction in a message, _A_c_t_i_o_n_s should be
              _a_c_t_i_o_n___r_e_q_s_(_) (_U_s_e_r_R_e_p_l_y will then be _u_s_e_r___r_e_p_l_y_(_)). When
              sending several transactions in a message, _A_c_t_i_o_n_s should be
              _[_a_c_t_i_o_n___r_e_q_s_(_)_] (_U_s_e_r_R_e_p_l_y will then be _[_u_s_e_r___r_e_p_l_y_(_)_]). Each
              element of the list is part of one transaction.

              For some of _o_u_r codecs (not binary), it is also possible to pre-
              encode the actions, in which case _A_c_t_i_o_n_s will be either a
              _b_i_n_a_r_y_(_) or _[_b_i_n_a_r_y_(_)_].

              The function returns when the reply arrives, when the request
              timer eventually times out or when the outstanding requests are
              explicitly cancelled.

              The default values of the send options are obtained by
              _m_e_g_a_c_o_:_c_o_n_n___i_n_f_o_(_C_o_n_n_H_a_n_d_l_e_, _I_t_e_m_). But the send options above,
              may explicitly be overridden.

              The _P_r_o_t_o_c_o_l_V_e_r_s_i_o_n version is the version actually encoded in
              the reply message.

              At _s_u_c_c_e_s_s_(_), the _U_s_e_r_R_e_p_l_y contains a list of 'ActionReply'
              records possibly containing error indications.

              A _m_e_s_s_a_g_e___e_r_r_o_r_(_), indicates that the remote user has replied
              with an explicit transactionError.

              A _u_s_e_r___c_a_n_c_e_l___e_r_r_o_r_(_), indicates that the request has been
              canceled by the user. _r_e_a_s_o_n___f_o_r___u_s_e_r___c_a_n_c_e_l_(_) is the reason
              given in the call to the ccaanncceell function.

              A _s_e_n_d___e_r_r_o_r_(_), indicates that the send function of the megaco
              transport callback module failed to send the request. There are
              two separate cases: _s_e_n_d___c_a_n_c_e_l_l_e_d___r_e_a_s_o_n_(_) and
              _s_e_n_d___f_a_i_l_e_d___r_e_a_s_o_n_(_). The first is the result of the send
              function returning _{_c_a_n_c_e_l_, _R_e_a_s_o_n_} and the second is some other
              kind of erroneous return value. See the sseenndd__mmeessssaaggee function
              for more info.

              An _o_t_h_e_r___e_r_r_o_r_(_), indicates some other error such as timeout.

              For more info about the _e_x_t_r_a_(_) part of the result, see the nnoottee
              in the user callback module documentation.

       ccaasstt((CCoonnnnHHaannddllee,, AAccttiioonnss,, OOppttiioonnss)) -->> ookk || {{eerrrroorr,, RReeaassoonn}}

              Types:

                 ConnHandle = conn_handle()
                 Actions = action_reqs() | [action_reqs()]
                 action_reqs() = binary() | [action_request()]
                 Options = [send_option()]
                 send_option() = {request_keep_alive_timeout,
                 request_keep_alive_timeout()} | {request_timer,
                 megaco_timer()} | {long_request_timer, megaco_timer()} |
                 {send_handle, term()} | {reply_data, reply_data()} |
                 {protocol_version, integer()}
                 request_keep_alive_timeout() = plain | integer() >= 0
                 Reason = term()

              Sends one or more transaction request(s) but does NOT wait for a
              reply

              When sending one transaction in a message, _A_c_t_i_o_n_s should be
              _a_c_t_i_o_n___r_e_q_s_(_). When sending several transactions in a message,
              _A_c_t_i_o_n_s should be _[_a_c_t_i_o_n___r_e_q_s_(_)_]. Each element of the list is
              part of one transaction.

              For some of _o_u_r codecs (not binary), it is also possible to pre-
              encode the actions, in which case _A_c_t_i_o_n_s will be either a
              _b_i_n_a_r_y_(_) or _[_b_i_n_a_r_y_(_)_].

              The default values of the send options are obtained by
              megaco:conn_info(ConnHandle, Item). But the send options above,
              may explicitly be overridden.

              The ProtocolVersion version is the version actually encoded in
              the reply message.

              The callback function UserMod:handle_trans_reply/4 is invoked
              when the reply arrives, when the request timer eventually times
              out or when the outstanding requests are explicitly cancelled.
              See the megaco_user module for more info about the callback
              arguments.

              Given as UserData argument to UserMod:handle_trans_reply/4.

       eennccooddee__aaccttiioonnss((CCoonnnnHHaannddllee,, AAccttiioonnss,, OOppttiioonnss)) -->> {{ookk,, BBiinnOOrrBBiinnss}} ||
       {{eerrrroorr,, RReeaassoonn}}

              Types:

                 ConnHandle = conn_handle()
                 Actions = action_reqs() | [action_reqs()]
                 action_reqs() = [#'ActionRequest'{}]
                 Options = [send_option()]
                 send_option() = {request_timer, megaco_timer()} |
                 {long_request_timer, megaco_timer()} | {send_handle, term()}
                 | {protocol_version, integer()}
                 BinOrBins = binary() | [binary()]
                 Reason = term()

              Encodes lists of action requests for one or more transaction
              request(s).

              When encoding action requests for one transaction, _A_c_t_i_o_n_s
              should be _a_c_t_i_o_n___r_e_q_s_(_). When encoding action requests for
              several transactions, _A_c_t_i_o_n_s should be _[_a_c_t_i_o_n___r_e_q_s_(_)_]. Each
              element of the list is part of one transaction.

       ttookkeenn__ttaagg22ssttrriinngg((TTaagg)) -->> RReessuulltt
       ttookkeenn__ttaagg22ssttrriinngg((TTaagg,, EEnnccooddeerrMMoodd)) -->> RReessuulltt
       ttookkeenn__ttaagg22ssttrriinngg((TTaagg,, EEnnccooddeerrMMoodd,, VVeerrssiioonn)) -->> RReessuulltt

              Types:

                 Tag = atom()
                 EncoderMod = pretty | compact | encoder_module()
                 encoder_module() = megaco_pretty_text_encoder |
                 megaco_compact_text_encoder | atom()
                 Version = int_version() | atom_version()
                 int_version() = 1 | 2 | 3
                 atom_version() = v1 | v2 | v3 | prev3c | prev3b
                 Result = string() | {error, Reason}
                 Reason = term()

              Convert a token tag to a string

              If no encoder module is given, the default is used (which is
              pretty).

              If no or an unknown version is given, the _b_e_s_t version is used
              (which is v3).

              If no match is found for _T_a_g, _R_e_s_u_l_t will be the empty string
              (_[_]).

       ccaanncceell((CCoonnnnHHaannddllee,, CCaanncceellRReeaassoonn)) -->> ookk || {{eerrrroorr,, EErrrrRReeaassoonn}}

              Types:

                 ConnHandle = conn_handle()
                 CancelReason = term()
                 ErrReason = term()

              Cancel all outstanding messages for this connection

              This causes outstanding megaco:call/3 requests to return. The
              callback functions UserMod:handle_reply/4 and
              UserMod:handle_trans_ack/4 are also invoked where it applies.
              See the megaco_user module for more info about the callback
              arguments.

       pprroocceessss__rreecceeiivveedd__mmeessssaaggee((RReecceeiivveeHHaannddllee,, CCoonnttrroollPPiidd,, SSeennddHHaannddllee,, BBiinnMMssgg))
       -->> ookk
       pprroocceessss__rreecceeiivveedd__mmeessssaaggee((RReecceeiivveeHHaannddllee,, CCoonnttrroollPPiidd,, SSeennddHHaannddllee,, BBiinnMMssgg,,
       EExxttrraa)) -->> ookk

              Types:

                 ReceiveHandle = #megaco_receive_handle{}
                 ControlPid = pid()
                 SendHandle = term()
                 BinMsg = binary()
                 Extra = term()

              Process a received message

              This function is intended to be invoked by some transport
              modules when get an incoming message. Which transport that
              actually is used is up to the user to choose.

              The message is delivered as an Erlang binary and is decoded by
              the encoding module stated in the receive handle together with
              its encoding config (also in the receive handle). Depending of
              the outcome of the decoding various callback functions will be
              invoked. See megaco_user for more info about the callback
              arguments.

              The argument _E_x_t_r_a is just an opaque data structure passed to
              the user via the callback functions in the uusseerr ccaallllbbaacckk mmoodduullee.
              Note however that if _E_x_t_r_a has the value _e_x_t_r_a___u_n_d_e_f_i_n_e_d the
              argument will be ignored (same as if _p_r_o_c_e_s_s___r_e_c_e_i_v_e_d___m_e_s_s_a_g_e_/_4
              had been called). See the documentation for the behaviour of the
              callback module, mmeeggaaccoo__uusseerr, for more info.

              Note that all processing is done in the context of the calling
              process. A transport module could call this function via one of
              the _s_p_a_w_n functions (e.g. _s_p_a_w_n___o_p_t). See also
              _r_e_c_e_i_v_e___m_e_s_s_a_g_e_/_4_,_5.

              If the message cannot be decoded the following callback function
              will be invoked:

                * UserMod:handle_syntax_error/3

              If the decoded message instead of transactions contains a
              message error, the following callback function will be invoked:

                * UserMod:handle_message_error/3

              If the decoded message happens to be received before the
              connection is established, a new "virtual" connection is
              established. This is typically the case for the Media Gateway
              Controller (MGC) upon the first Service Change. When this occurs
              the following callback function will be invoked:

                * UserMod:handle_connect/2

              For each transaction request in the decoded message the
              following callback function will be invoked:

                * UserMod:handle_trans_request/3

              For each transaction reply in the decoded message the reply is
              returned to the user. Either the originating function
              megaco:call/3 will return. Or in case the originating function
              was megaco:case/3 the following callback function will be
              invoked:

                * UserMod:handle_trans_reply/4

              When a transaction acknowledgement is received it is possible
              that user has decided not to bother about the acknowledgement.
              But in case the return value from UserMod:handle_trans_request/3
              indicates that the acknowledgement is important the following
              callback function will be invoked:

                * UserMod:handle_trans_ack/4

              See the megaco_user module for more info about the callback
              arguments.

       rreecceeiivvee__mmeessssaaggee((RReecceeiivveeHHaannddllee,, CCoonnttrroollPPiidd,, SSeennddHHaannddllee,, BBiinnMMssgg)) -->> ookk
       rreecceeiivvee__mmeessssaaggee((RReecceeiivveeHHaannddllee,, CCoonnttrroollPPiidd,, SSeennddHHaannddllee,, BBiinnMMssgg,, EExxttrraa))
       -->> ookk

              Types:

                 ReceiveHandle = #megaco_receive_handle{}
                 ControlPid = pid()
                 SendHandle = term()
                 BinMsg = binary()
                 Extra = term()

              Process a received message

              This is a callback function intended to be invoked by some
              transport modules when get an incoming message. Which transport
              that actually is used is up to the user to choose.

              In principle, this function calls the _p_r_o_c_e_s_s___r_e_c_e_i_v_e_d___m_e_s_s_a_g_e_/_4
              function via a _s_p_a_w_n to perform the actual processing.

              For further information see the pprroocceessss__rreecceeiivveedd__mmeessssaaggee//44
              function.

       ppaarrssee__ddiiggiitt__mmaapp((DDiiggiittMMaappBBooddyy)) -->> {{ookk,, PPaarrsseeddDDiiggiittMMaapp}} || {{eerrrroorr,, RReeaassoonn}}

              Types:

                 DigitMapBody = string()
                 ParsedDigitMap = parsed_digit_map()
                 parsed_digit_map() = term()
                 Reason = term()

              Parses a digit map body

              Parses a digit map body, represented as a list of characters,
              into a list of state transitions suited to be evaluated by
              megaco:eval_digit_map/1,2.

       eevvaall__ddiiggiitt__mmaapp((DDiiggiittMMaapp)) -->> {{ookk,, MMaattcchhRReessuulltt}} || {{eerrrroorr,, RReeaassoonn}}
       eevvaall__ddiiggiitt__mmaapp((DDiiggiittMMaapp,, TTiimmeerrss)) -->> {{ookk,, MMaattcchhRReessuulltt}} || {{eerrrroorr,, RReeaassoonn}}

              Types:

                 DigitMap = #'DigitMapValue'{} | parsed_digit_map()
                 parsed_digit_map() = term()
                 ParsedDigitMap = term()
                 Timers = ignore() | reject()
                 ignore() = ignore | {ignore, digit_map_value()}
                 reject() = reject | {reject, digit_map_value()} |
                 digit_map_value()
                 MatchResult = {Kind, Letters} | {Kind, Letters, Extra}
                 Kind = kind()
                 kind() = full | unambiguous
                 Letters = [letter()]
                 letter() = $0..$9 | $a .. $k
                 Extra = letter()
                 Reason = term()

              Collect digit map letters according to the digit map.

              When evaluating a digit map, a state machine waits for timeouts
              and letters reported by megaco:report_digit_event/2. The length
              of the various timeouts are defined in the digit_map_value()
              record.

              When a complete sequence of valid events has been received, the
              result is returned as a list of letters.

              There are two options for handling syntax errors (that is when
              an unexpected event is received when the digit map evaluator is
              expecting some other event). The unexpected events may either be
              ignored or rejected. The latter means that the evaluation is
              aborted and an error is returned.

       rreeppoorrtt__ddiiggiitt__eevveenntt((DDiiggiittMMaappEEvvaallPPiidd,, EEvveennttss)) -->> ookk || {{eerrrroorr,, RReeaassoonn}}

              Types:

                 DigitMapEvalPid = pid()
                 Events = Event | [Event]
                 Event = letter() | pause() | cancel()
                 letter() = $0..$9 | $a .. $k | $A .. $K
                 pause() = one_second() | ten_seconds()
                 one_second() = $s | $S
                 ten_seconds() = $l | $L
                 cancel() = $z | $Z | cancel
                 Reason = term()

              Send one or more events to the event collector process.

              Send one or more events to a process that is evaluating a digit
              map, that is a process that is executing
              megaco:eval_digit_map/1,2.

              Note that the events _$_s _| _$_S, _l _| _$_L and _$_z _| _$_Z has nothing to
              do with the timers using the same characters.

       tteesstt__ddiiggiitt__eevveenntt((DDiiggiittMMaapp,, EEvveennttss)) -->> {{ookk,, KKiinndd,, LLeetttteerrss}} || {{eerrrroorr,,
       RReeaassoonn}}

              Types:

                 DigitMap = #'DigitMapValue'{} | parsed_digit_map()
                 parsed_digit_map() = term()
                 ParsedDigitMap = term()
                 Timers = ignore() | reject()
                 ignore() = ignore | {ignore, digit_map_value()}
                 reject() = reject | {reject, digit_map_value()} |
                 digit_map_value()
                 DigitMapEvalPid = pid()
                 Events = Event | [Event]
                 Event = letter() | pause() | cancel()
                 Kind = kind()
                 kind() = full | unambiguous
                 Letters = [letter()]
                 letter() = $0..$9 | $a .. $k | $A .. $K
                 pause() = one_second() | ten_seconds()
                 one_second() = $s | $S
                 ten_seconds() = $l | $L
                 cancel () = $z | $Z | cancel
                 Reason = term()

              Feed digit map collector with events and return the result

              This function starts the evaluation of a digit map with
              megaco:eval_digit_map/1 and sends a sequence of events to it
              megaco:report_digit_event/2 in order to simplify testing of
              digit maps.

       eennccooddee__ssddpp((SSDDPP)) -->> {{ookk,, PPPP}} || {{eerrrroorr,, RReeaassoonn}}

              Types:

                 SDP = sdp_property_parm() | sdp_property_group() |
                 sdp_property_groups() | asn1_NOVALUE
                 PP = property_parm() | property_group() | property_groups() |
                 asn1_NOVALUE
                 Reason = term()

              Encode (generate) an SDP construct.

              If a _p_r_o_p_e_r_t_y___p_a_r_m_(_) is found as part of the input (_S_D_P) then it
              is left unchanged.

              This function performs the following transformation:

                * sdp() -> property_parm()

                * sdp_property_group() -> property_group()

                * sdp_property_groups() -> property_groups()

       ddeeccooddee__ssddpp((PPPP)) -->> {{ookk,, SSDDPP}} || {{eerrrroorr,, RReeaassoonn}}

              Types:

                 PP = property_parm() | property_group() | property_groups() |
                 asn1_NOVALUE
                 SDP = sdp() | decode_sdp_property_group() |
                 decode_sdp_property_groups() | asn1_NOVALUE
                 decode_sdp() = sdp() | {property_parm(), DecodeError}
                 decode_sdp_property_group() = [decode_sdp()]
                 decode_sdp_property_groups() = [decode_sdp_property_group()]
                 DecodeError = term()
                 Reason = term()

              Decode (parse) a property parameter construct.

              When decoding _p_r_o_p_e_r_t_y___g_r_o_u_p_(_) or _p_r_o_p_e_r_t_y___g_r_o_u_p_s_(_), those
              property parameter constructs that cannot be decoded (either
              because of decode error or because they are unknown), will be
              returned as a two-tuple. The first element of which will be the
              (undecoded) property parameter and the other the actual reason.
              This means that the caller of this function has to expect not
              only sdp-records, but also this two-tuple construct.

              This function performs the following transformation:

                * property_parm() -> sdp()

                * property_group() -> sdp_property_group()

                * property_groups() -> sdp_property_groups()

       ggeett__ssddpp__rreeccoorrdd__ffrroomm__PPrrooppeerrttGGrroouupp((TTyyppee,, PPGG)) -->> [[ssddpp(())]]

              Types:

                 Type = v | c | m | o | a | b | t | r | z | k | s | i | u | e
                 | p
                 PG = sdp_property_group()
                 Reason = term()

              Retreive all the sdp records of type _T_y_p_e from the property
              group _P_G.

       vveerrssiioonnss11(()) -->> {{ookk,, VVeerrssiioonnIInnffoo}} || {{eerrrroorr,, RReeaassoonn}}
       vveerrssiioonnss22(()) -->> {{ookk,, IInnffoo}} || {{eerrrroorr,, RReeaassoonn}}

              Types:

                 VersionInfo = [version_info()]
                 version_info() = term()
                 Reason = term()

              Utility functions used to retrieve some system and application
              info.

              The difference between the two functions is in how they get the
              modules to check. _v_e_r_s_i_o_n_s_1 uses the app-file and _v_e_r_s_i_o_n_s_2 uses
              the function _a_p_p_l_i_c_a_t_i_o_n_:_g_e_t___k_e_y.

       pprriinntt__vveerrssiioonn__iinnffoo(()) -->> vvooiidd(())
       pprriinntt__vveerrssiioonn__iinnffoo((VVeerrssiioonnIInnffoo)) -->> vvooiidd(())

              Types:

                 VersionInfo = [version_info()]
                 version_info() = term()

              Utility function to produce a formated printout of the versions
              info generated by the _v_e_r_s_i_o_n_s_1 and _v_e_r_s_i_o_n_s_2 functions.

              The function print_version_info/0 uses the result of function
              version1/0 as _V_e_r_s_i_o_n_I_n_f_o.

              Example:

                         {ok, V} = megaco:versions1(), megaco:format_versions(V).


       eennaabbllee__ttrraaccee((LLeevveell,, DDeessttiinnaattiioonn)) -->> vvooiidd(())

              Types:

                 Level = max | min | 0 <= integer() <= 100
                 Destination = File | Port | HandlerSpec | io
                 File = string()
                 Port = integer()
                 HandleSpec = {HandlerFun, Data}
                 HandleFun = fun() (two arguments)
                 Data = term()

              This function is used to start megaco tracing at a given _L_e_v_e_l
              and direct result to the given _D_e_s_t_i_n_a_t_i_o_n.

              It starts a tracer server and then sets the proper match spec
              (according to _L_e_v_e_l).

              In the case when _D_e_s_t_i_n_a_t_i_o_n is _F_i_l_e, the printable megaco trace
              events will be printed to the file _F_i_l_e using plain _i_o_:_f_o_r_m_a_t_/_2.

              In the case when _D_e_s_t_i_n_a_t_i_o_n is _i_o, the printable megaco trace
              events will be printed on stdout using plain _i_o_:_f_o_r_m_a_t_/_2.

              See _d_b_g for further information.

       ddiissaabbllee__ttrraaccee(()) -->> vvooiidd(())

              This function is used to stop megaco tracing.

       sseett__ttrraaccee((LLeevveell)) -->> vvooiidd(())

              Types:

                 Level = max | min | 0 <= integer() <= 100

              This function is used to change the megaco trace level.

              It is assumed that tracing has already been enabled (see
              _e_n_a_b_l_e___t_r_a_c_e above).

       ggeett__ssttaattss(()) -->> {{ookk,, TToottaallSSttaattss}} || {{eerrrroorr,, RReeaassoonn}}
       ggeett__ssttaattss((GGlloobbaallCCoouunntteerr)) -->> {{ookk,, CCoouunntteerrSSttaattss}} || {{eerrrroorr,, RReeaassoonn}}
       ggeett__ssttaattss((CCoonnnnHHaannddllee)) -->> {{ookk,, CCoonnnnHHaannddlleeSSttaattss}} || {{eerrrroorr,, RReeaassoonn}}
       ggeett__ssttaattss((CCoonnnnHHaannddllee,, CCoouunntteerr)) -->> {{ookk,, iinntteeggeerr(())}} || {{eerrrroorr,, RReeaassoonn}}

              Types:

                 TotalStats = [total_stats()]
                 total_stats() = {conn_handle(), [stats()]} |
                 {global_counter(), integer()}
                 GlobalCounter = global_counter()
                 GlobalCounterStats = integer()
                 ConnHandle = conn_handle()
                 ConnHandleStats = [stats()]
                 stats() = {counter(), integer()}
                 Counter = counter()
                 counter() = medGwyGatewayNumTimerRecovery |
                 medGwyGatewayNumErrors
                 global_counter() = medGwyGatewayNumErrors
                 Reason = term()

              Retreive the (SNMP) statistic counters maintained by the megaco
              application. The global counters handle events that cannot be
              attributed to a single connection (e.g. protocol errors that
              occur before the connection has been properly setup).

       rreesseett__ssttaattss(()) -->> vvooiidd(())
       rreesseett__ssttaattss((CCoonnnnHHaannddllee)) -->> vvooiidd(())

              Types:

                 ConnHandle = conn_handle()

              Reset all related (SNMP) statistics counters.

       tteesstt__rreeqquueesstt((CCoonnnnHHaannddllee,, VVeerrssiioonn,, EEnnccooddiinnggMMoodd,, EEnnccooddiinnggCCoonnffiigg,, AAccttiioonnss))
       -->> {{MMeeggaaMMssgg,, EEnnccooddeeRReess}}

              Types:

                 ConnHandle = conn_handle()
                 Version = integer()
                 EncodingMod = atom()
                 EncodingConfig = Encoding configuration
                 Actions = A list
                 MegaMsg = #'MegacoMessage'{}
                 EncodeRes = {ok, Bin} | {error, Reason}
                 Bin = binary()
                 Reason = term()

              Tests if the Actions argument is correctly composed.

              This function is only intended for testing purposes. It's
              supposed to have a same kind of interface as the ccaallll or ccaasstt
              functions (with the additions of the _E_n_c_o_d_i_n_g_M_o_d and
              _E_n_c_o_d_i_n_g_C_o_n_f_i_g arguments). It composes a complete megaco message
              end attempts to encode it. The return value, will be a tuple of
              the composed megaco message and the encode result.

       tteesstt__rreeppllyy((CCoonnnnHHaannddllee,, VVeerrssiioonn,, EEnnccooddiinnggMMoodd,, EEnnccooddiinnggCCoonnffiigg,, RReeppllyy)) -->>
       {{MMeeggaaMMssgg,, EEnnccooddeeRReess}}

              Types:

                 ConnHandle = conn_handle()
                 Version = integer()
                 EncodingMod = atom()
                 EncodingConfig = A list
                 Reply = actual_reply()
                 MegaMsg = #'MegacoMessage'{}
                 EncodeRes = {ok, Bin} | {error, Reason}
                 Bin = binary()
                 Reason = term()

              Tests if the Reply argument is correctly composed.

              This function is only intended for testing purposes. It's
              supposed to test the _a_c_t_u_a_l___r_e_p_l_y_(_) return value of the callback
              functions hhaannddllee__ttrraannss__rreeqquueesstt and hhaannddllee__ttrraannss__lloonngg__rreeqquueesstt
              functions (with the additions of the _E_n_c_o_d_i_n_g_M_o_d and
              _E_n_c_o_d_i_n_g_C_o_n_f_i_g arguments). It composes a complete megaco message
              end attempts to encode it. The return value, will be a tuple of
              the composed megaco message and the encode result.



Ericsson AB                     megaco 3.16.0.2                      megaco(3)
