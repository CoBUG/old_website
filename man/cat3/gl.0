gl(3)                      Erlang Module Definition                      gl(3)



NNAAMMEE
       gl -  Standard OpenGL api.

DDEESSCCRRIIPPTTIIOONN
       Standard OpenGL api. See www.opengl.org

       Booleans are represented by integers 0 and 1.

DDAATTAA TTYYPPEESS
         _c_l_a_m_p_(_) _= _f_l_o_a_t_(_):


           0.0..1.0

         _e_n_u_m_(_) _= _n_o_n___n_e_g___i_n_t_e_g_e_r_(_):


           See wx/include/gl.hrl

         _m_a_t_r_i_x_(_) _= _{_f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_,
         _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_,
         _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_, _f_l_o_a_t_(_)_}:


         _m_e_m_(_) _= _b_i_n_a_r_y_(_) _| _t_u_p_l_e_(_):


           Memory block

         _o_f_f_s_e_t_(_) _= _n_o_n___n_e_g___i_n_t_e_g_e_r_(_):


           Offset in memory block

EEXXPPOORRTTSS
       cclleeaarrIInnddeexx((CC)) -->> ookk

              Types:

                 C = float()

              Specify the clear value for the color index buffers

              _g_l_:_c_l_e_a_r_I_n_d_e_x specifies the index used by ggll::cclleeaarr//11 to clear
              the color index buffers. _C is not clamped. Rather, _C is
              converted to a fixed-point value with unspecified precision to
              the right of the binary point. The integer part of this value is
              then masked with 2 m-1, where m is the number of bits in a color
              index stored in the frame buffer.

              See external documentation.

       cclleeaarrCCoolloorr((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)) -->> ookk

              Types:

                 Red = clamp()
                 Green = clamp()
                 Blue = clamp()
                 Alpha = clamp()

              Specify clear values for the color buffers

              _g_l_:_c_l_e_a_r_C_o_l_o_r specifies the red, green, blue, and alpha values
              used by ggll::cclleeaarr//11 to clear the color buffers. Values specified
              by _g_l_:_c_l_e_a_r_C_o_l_o_r are clamped to the range [0 1].

              See external documentation.

       cclleeaarr((MMaasskk)) -->> ookk

              Types:

                 Mask = integer()

              Clear buffers to preset values

              _g_l_:_c_l_e_a_r sets the bitplane area of the window to values
              previously selected by _g_l_:_c_l_e_a_r_C_o_l_o_r , _g_l_:_c_l_e_a_r_D_e_p_t_h, and
              _g_l_:_c_l_e_a_r_S_t_e_n_c_i_l. Multiple color buffers can be cleared
              simultaneously by selecting more than one buffer at a time using
              ggll::ddrraawwBBuuffffeerr//11 .

              The pixel ownership test, the scissor test, dithering, and the
              buffer writemasks affect the operation of _g_l_:_c_l_e_a_r. The scissor
              box bounds the cleared region. Alpha function, blend function,
              logical operation, stenciling, texture mapping, and depth-
              buffering are ignored by _g_l_:_c_l_e_a_r.

              _g_l_:_c_l_e_a_r takes a single argument that is the bitwise OR of
              several values indicating which buffer is to be cleared.

              The values are as follows:

              _?_G_L___C_O_L_O_R___B_U_F_F_E_R___B_I_T: Indicates the buffers currently enabled
              for color writing.

              _?_G_L___D_E_P_T_H___B_U_F_F_E_R___B_I_T: Indicates the depth buffer.

              _?_G_L___S_T_E_N_C_I_L___B_U_F_F_E_R___B_I_T: Indicates the stencil buffer.

              The value to which each buffer is cleared depends on the setting
              of the clear value for that buffer.

              See external documentation.

       iinnddeexxMMaasskk((MMaasskk)) -->> ookk

              Types:

                 Mask = integer()

              Control the writing of individual bits in the color index
              buffers

              _g_l_:_i_n_d_e_x_M_a_s_k controls the writing of individual bits in the
              color index buffers. The least significant n bits of _M_a_s_k ,
              where n is the number of bits in a color index buffer, specify a
              mask. Where a 1 (one) appears in the mask, it's possible to
              write to the corresponding bit in the color index buffer (or
              buffers). Where a 0 (zero) appears, the corresponding bit is
              write-protected.

              This mask is used only in color index mode, and it affects only
              the buffers currently selected for writing (see ggll::ddrraawwBBuuffffeerr//11
              ). Initially, all bits are enabled for writing.

              See external documentation.

       ccoolloorrMMaasskk((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)) -->> ookk

              Types:

                 Red = 0 | 1
                 Green = 0 | 1
                 Blue = 0 | 1
                 Alpha = 0 | 1

              Enable and disable writing of frame buffer color components

              _g_l_:_c_o_l_o_r_M_a_s_k and _g_l_:_c_o_l_o_r_M_a_s_k_i specify whether the individual
              color components in the frame buffer can or cannot be written.
              _g_l_:_c_o_l_o_r_M_a_s_k_i sets the mask for a specific draw buffer, whereas
              _g_l_:_c_o_l_o_r_M_a_s_k sets the mask for all draw buffers. If _R_e_d is
              _?_G_L___F_A_L_S_E, for example, no change is made to the red component
              of any pixel in any of the color buffers, regardless of the
              drawing operation attempted.

              Changes to individual bits of components cannot be controlled.
              Rather, changes are either enabled or disabled for entire color
              components.

              See external documentation.

       aallpphhaaFFuunncc((FFuunncc,, RReeff)) -->> ookk

              Types:

                 Func = enum()
                 Ref = clamp()

              Specify the alpha test function

              The alpha test discards fragments depending on the outcome of a
              comparison between an incoming fragment's alpha value and a
              constant reference value. _g_l_:_a_l_p_h_a_F_u_n_c specifies the reference
              value and the comparison function. The comparison is performed
              only if alpha testing is enabled. By default, it is not enabled.
              (See ggll::eennaabbllee//11 and ggll::eennaabbllee//11 of _?_G_L___A_L_P_H_A___T_E_S_T.)

              _F_u_n_c and _R_e_f specify the conditions under which the pixel is
              drawn. The incoming alpha value is compared to _R_e_f using the
              function specified by _F_u_n_c . If the value passes the comparison,
              the incoming fragment is drawn if it also passes subsequent
              stencil and depth buffer tests. If the value fails the
              comparison, no change is made to the frame buffer at that pixel
              location. The comparison functions are as follows:

              _?_G_L___N_E_V_E_R: Never passes.

              _?_G_L___L_E_S_S: Passes if the incoming alpha value is less than the
              reference value.

              _?_G_L___E_Q_U_A_L: Passes if the incoming alpha value is equal to the
              reference value.

              _?_G_L___L_E_Q_U_A_L: Passes if the incoming alpha value is less than or
              equal to the reference value.

              _?_G_L___G_R_E_A_T_E_R: Passes if the incoming alpha value is greater than
              the reference value.

              _?_G_L___N_O_T_E_Q_U_A_L: Passes if the incoming alpha value is not equal to
              the reference value.

              _?_G_L___G_E_Q_U_A_L: Passes if the incoming alpha value is greater than
              or equal to the reference value.

              _?_G_L___A_L_W_A_Y_S: Always passes (initial value).

              _g_l_:_a_l_p_h_a_F_u_n_c operates on all pixel write operations, including
              those resulting from the scan conversion of points, lines,
              polygons, and bitmaps, and from pixel draw and copy operations.
              _g_l_:_a_l_p_h_a_F_u_n_c does not affect screen clear operations.

              See external documentation.

       bblleennddFFuunncc((SSffaaccttoorr,, DDffaaccttoorr)) -->> ookk

              Types:

                 Sfactor = enum()
                 Dfactor = enum()

              Specify pixel arithmetic

              Pixels can be drawn using a function that blends the incoming
              (source) RGBA values with the RGBA values that are already in
              the frame buffer (the destination values). Blending is initially
              disabled. Use ggll::eennaabbllee//11 and ggll::eennaabbllee//11 with argument
              _?_G_L___B_L_E_N_D to enable and disable blending.

              _g_l_:_b_l_e_n_d_F_u_n_c defines the operation of blending for all draw
              buffers when it is enabled. _g_l_:_b_l_e_n_d_F_u_n_c_i defines the operation
              of blending for a single draw buffer specified by _B_u_f when
              enabled for that draw buffer. _S_f_a_c_t_o_r specifies which method is
              used to scale the source color components. _D_f_a_c_t_o_r specifies
              which method is used to scale the destination color components.
              Both parameters must be one of the following symbolic constants:
              _?_G_L___Z_E_R_O, _?_G_L___O_N_E, _?_G_L___S_R_C___C_O_L_O_R, _?_G_L___O_N_E___M_I_N_U_S___S_R_C___C_O_L_O_R ,
              _?_G_L___D_S_T___C_O_L_O_R, _?_G_L___O_N_E___M_I_N_U_S___D_S_T___C_O_L_O_R, _?_G_L___S_R_C___A_L_P_H_A,
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___A_L_P_H_A , _?_G_L___D_S_T___A_L_P_H_A,
              _?_G_L___O_N_E___M_I_N_U_S___D_S_T___A_L_P_H_A, _?_G_L___C_O_N_S_T_A_N_T___C_O_L_O_R,
              _?_G_L___O_N_E___M_I_N_U_S___C_O_N_S_T_A_N_T___C_O_L_O_R , _?_G_L___C_O_N_S_T_A_N_T___A_L_P_H_A,
              _?_G_L___O_N_E___M_I_N_U_S___C_O_N_S_T_A_N_T___A_L_P_H_A, _?_G_L___S_R_C___A_L_P_H_A___S_A_T_U_R_A_T_E ,
              _?_G_L___S_R_C_1___C_O_L_O_R, _?_G_L___O_N_E___M_I_N_U_S___S_R_C_1___C_O_L_O_R, _?_G_L___S_R_C_1___A_L_P_H_A, and
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C_1___A_L_P_H_A . The possible methods are described in
              the following table. Each method defines four scale factors, one
              each for red, green, blue, and alpha. In the table and in
              subsequent equations, first source, second source and
              destination color components are referred to as (R s0 G s0 B s0
              A s0), (R s1 G s1 B s1 A s1) and (R d G d B d A d),
              respectively. The color specified by ggll::bblleennddCCoolloorr//44 is referred
              to as (R c G c B c A c). They are understood to have integer
              values between 0 and (k R k G k B k A), where

              k c= 2(m c)-1

              and (m R m G m B m A) is the number of red, green, blue, and
              alpha bitplanes.

              Source and destination scale factors are referred to as (s R s G
              s B s A) and (d R d G d B d A). The scale factors described in
              the table, denoted (f R f G f B f A), represent either source or
              destination factors. All scale factors have range [0
              1]._P_a_r_a_m_e_t_e_r(f R f G f B f A)
              _?_G_L___Z_E_R_O (0 0 0 0)
              _?_G_L___O_N_E(1 1 1 1)
              _?_G_L___S_R_C___C_O_L_O_R (R s0 k/R G s0 k/G B s0 k/B A s0 k/A)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___C_O_L_O_R(1 1 1 1)-(R s0 k/R G s0 k/G B s0 k/B A
              s0 k/A)
              _?_G_L___D_S_T___C_O_L_O_R (R d k/R G d k/G B d k/B A d k/A)
              _?_G_L___O_N_E___M_I_N_U_S___D_S_T___C_O_L_O_R(1 1 1 1)-(R d k/R G d k/G B d k/B A d
              k/A)
              _?_G_L___S_R_C___A_L_P_H_A (A s0 k/A A s0 k/A A s0 k/A A s0 k/A)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___A_L_P_H_A(1 1 1 1)-(A s0 k/A A s0 k/A A s0 k/A A
              s0 k/A)
              _?_G_L___D_S_T___A_L_P_H_A (A d k/A A d k/A A d k/A A d k/A)
              _?_G_L___O_N_E___M_I_N_U_S___D_S_T___A_L_P_H_A(1 1 1 1)-(A d k/A A d k/A A d k/A A d
              k/A)
              _?_G_L___C_O_N_S_T_A_N_T___C_O_L_O_R (R c G c B c A c)
              _?_G_L___O_N_E___M_I_N_U_S___C_O_N_S_T_A_N_T___C_O_L_O_R(1 1 1 1)-(R c G c B c A c)
              _?_G_L___C_O_N_S_T_A_N_T___A_L_P_H_A(A c A c A c A c)
              _?_G_L___O_N_E___M_I_N_U_S___C_O_N_S_T_A_N_T___A_L_P_H_A (1 1 1 1)-(A c A c A c A c)
              _?_G_L___S_R_C___A_L_P_H_A___S_A_T_U_R_A_T_E(i i i 1)
              _?_G_L___S_R_C_1___C_O_L_O_R (R s1 k/R G s1 k/G B s1 k/B A s1 k/A)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C_1___C_O_L_O_R(1 1 1 1)-(R s1 k/R G s1 k/G B s1 k/B A
              s1 k/A)
              _?_G_L___S_R_C_1___A_L_P_H_A (A s1 k/A A s1 k/A A s1 k/A A s1 k/A)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C_1___A_L_P_H_A(1 1 1 1)-(A s1 k/A A s1 k/A A s1 k/A A
              s1 k/A)


              In the table,

              i= min(A s k A-A d) k/A

              To determine the blended RGBA values of a pixel, the system uses
              the following equations:

              R d= min(k R R s s R+R d d R) G d= min(k G G s s G+G d d G) B d=
              min(k B B s s B+B d d B) A d= min(k A A s s A+A d d A)

              Despite the apparent precision of the above equations, blending
              arithmetic is not exactly specified, because blending operates
              with imprecise integer color values. However, a blend factor
              that should be equal to 1 is guaranteed not to modify its
              multiplicand, and a blend factor equal to 0 reduces its
              multiplicand to 0. For example, when _S_f_a_c_t_o_r is _?_G_L___S_R_C___A_L_P_H_A ,
              _D_f_a_c_t_o_r is _?_G_L___O_N_E___M_I_N_U_S___S_R_C___A_L_P_H_A, and A s is equal to k A, the
              equations reduce to simple replacement:

              R d= R s G d= G s B d= B s A d= A s

              See external documentation.

       llooggiiccOOpp((OOppccooddee)) -->> ookk

              Types:

                 Opcode = enum()

              Specify a logical pixel operation for rendering

              _g_l_:_l_o_g_i_c_O_p specifies a logical operation that, when enabled, is
              applied between the incoming RGBA color and the RGBA color at
              the corresponding location in the frame buffer. To enable or
              disable the logical operation, call ggll::eennaabbllee//11 and ggll::eennaabbllee//11
              using the symbolic constant _?_G_L___C_O_L_O_R___L_O_G_I_C___O_P. The initial
              value is disabled._O_p_c_o_d_e_R_e_s_u_l_t_i_n_g _O_p_e_r_a_t_i_o_n
              _?_G_L___C_L_E_A_R 0
              _?_G_L___S_E_T 1
              _?_G_L___C_O_P_Y s
              _?_G_L___C_O_P_Y___I_N_V_E_R_T_E_D ~s
              _?_G_L___N_O_O_P d
              _?_G_L___I_N_V_E_R_T ~d
              _?_G_L___A_N_D s & d
              _?_G_L___N_A_N_D ~(s & d)
              _?_G_L___O_R s | d
              _?_G_L___N_O_R ~(s | d)
              _?_G_L___X_O_R s ^ d
              _?_G_L___E_Q_U_I_V ~(s ^ d)
              _?_G_L___A_N_D___R_E_V_E_R_S_E s & ~d
              _?_G_L___A_N_D___I_N_V_E_R_T_E_D ~s & d
              _?_G_L___O_R___R_E_V_E_R_S_E s | ~d
              _?_G_L___O_R___I_N_V_E_R_T_E_D ~s | d


              _O_p_c_o_d_e is a symbolic constant chosen from the list above. In the
              explanation of the logical operations, _s represents the incoming
              color and _d represents the color in the frame buffer. Standard
              C-language operators are used. As these bitwise operators
              suggest, the logical operation is applied independently to each
              bit pair of the source and destination colors.

              See external documentation.

       ccuullllFFaaccee((MMooddee)) -->> ookk

              Types:

                 Mode = enum()

              Specify whether front- or back-facing facets can be culled

              _g_l_:_c_u_l_l_F_a_c_e specifies whether front- or back-facing facets are
              culled (as specified by _m_o_d_e) when facet culling is enabled.
              Facet culling is initially disabled. To enable and disable facet
              culling, call the ggll::eennaabbllee//11 and ggll::eennaabbllee//11 commands with the
              argument _?_G_L___C_U_L_L___F_A_C_E. Facets include triangles,
              quadrilaterals, polygons, and rectangles.

              ggll::ffrroonnttFFaaccee//11 specifies which of the clockwise and
              counterclockwise facets are front-facing and back-facing. See
              ggll::ffrroonnttFFaaccee//11 .

              See external documentation.

       ffrroonnttFFaaccee((MMooddee)) -->> ookk

              Types:

                 Mode = enum()

              Define front- and back-facing polygons

              In a scene composed entirely of opaque closed surfaces, back-
              facing polygons are never visible. Eliminating these invisible
              polygons has the obvious benefit of speeding up the rendering of
              the image. To enable and disable elimination of back-facing
              polygons, call ggll::eennaabbllee//11 and ggll::eennaabbllee//11 with argument
              _?_G_L___C_U_L_L___F_A_C_E.

              The projection of a polygon to window coordinates is said to
              have clockwise winding if an imaginary object following the path
              from its first vertex, its second vertex, and so on, to its last
              vertex, and finally back to its first vertex, moves in a
              clockwise direction about the interior of the polygon. The
              polygon's winding is said to be counterclockwise if the
              imaginary object following the same path moves in a
              counterclockwise direction about the interior of the polygon.
              _g_l_:_f_r_o_n_t_F_a_c_e specifies whether polygons with clockwise winding
              in window coordinates, or counterclockwise winding in window
              coordinates, are taken to be front-facing. Passing _?_G_L___C_C_W to
              _M_o_d_e selects counterclockwise polygons as front-facing; _?_G_L___C_W
              selects clockwise polygons as front-facing. By default,
              counterclockwise polygons are taken to be front-facing.

              See external documentation.

       ppooiinnttSSiizzee((SSiizzee)) -->> ookk

              Types:

                 Size = float()

              Specify the diameter of rasterized points

              _g_l_:_p_o_i_n_t_S_i_z_e specifies the rasterized diameter of points. If
              point size mode is disabled (see ggll::eennaabbllee//11 with parameter
              _?_G_L___P_R_O_G_R_A_M___P_O_I_N_T___S_I_Z_E), this value will be used to rasterize
              points. Otherwise, the value written to the shading language
              built-in variable gl_PointSize will be used.

              See external documentation.

       lliinneeWWiiddtthh((WWiiddtthh)) -->> ookk

              Types:

                 Width = float()

              Specify the width of rasterized lines

              _g_l_:_l_i_n_e_W_i_d_t_h specifies the rasterized width of both aliased and
              antialiased lines. Using a line width other than 1 has different
              effects, depending on whether line antialiasing is enabled. To
              enable and disable line antialiasing, call ggll::eennaabbllee//11 and
              ggll::eennaabbllee//11 with argument _?_G_L___L_I_N_E___S_M_O_O_T_H. Line antialiasing is
              initially disabled.

              If line antialiasing is disabled, the actual width is determined
              by rounding the supplied width to the nearest integer. (If the
              rounding results in the value 0, it is as if the line width were
              1.) If |&Delta; x|>=|&Delta; y|, _i pixels are filled in each
              column that is rasterized, where _i is the rounded value of _W_i_d_t_h
              . Otherwise, _i pixels are filled in each row that is rasterized.

              If antialiasing is enabled, line rasterization produces a
              fragment for each pixel square that intersects the region lying
              within the rectangle having width equal to the current line
              width, length equal to the actual length of the line, and
              centered on the mathematical line segment. The coverage value
              for each fragment is the window coordinate area of the
              intersection of the rectangular region with the corresponding
              pixel square. This value is saved and used in the final
              rasterization step.

              Not all widths can be supported when line antialiasing is
              enabled. If an unsupported width is requested, the nearest
              supported width is used. Only width 1 is guaranteed to be
              supported; others depend on the implementation. Likewise, there
              is a range for aliased line widths as well. To query the range
              of supported widths and the size difference between supported
              widths within the range, call ggll::ggeettBBoooolleeaannvv//11 with arguments
              _?_G_L___A_L_I_A_S_E_D___L_I_N_E___W_I_D_T_H___R_A_N_G_E , _?_G_L___S_M_O_O_T_H___L_I_N_E___W_I_D_T_H___R_A_N_G_E, and
              _?_G_L___S_M_O_O_T_H___L_I_N_E___W_I_D_T_H___G_R_A_N_U_L_A_R_I_T_Y.

              See external documentation.

       lliinneeSSttiippppllee((FFaaccttoorr,, PPaatttteerrnn)) -->> ookk

              Types:

                 Factor = integer()
                 Pattern = integer()

              Specify the line stipple pattern

              Line stippling masks out certain fragments produced by
              rasterization; those fragments will not be drawn. The masking is
              achieved by using three parameters: the 16-bit line stipple
              pattern _P_a_t_t_e_r_n , the repeat count _F_a_c_t_o_r , and an integer
              stipple counter s.

              Counter s is reset to 0 whenever ggll::''bbeeggiinn''//11 is called and
              before each line segment of a ggll::''bbeeggiinn''//11 (_?_G_L___L_I_N_E_S)/
              ggll::''bbeeggiinn''//11 sequence is generated. It is incremented after each
              fragment of a unit width aliased line segment is generated or
              after each i fragments of an i width line segment are generated.
              The i fragments associated with count s are masked out if

              _P_a_t_t_e_r_n bit (s/factor)% 16

              is 0, otherwise these fragments are sent to the frame buffer.
              Bit zero of _P_a_t_t_e_r_n is the least significant bit.

              Antialiased lines are treated as a sequence of 1*width
              rectangles for purposes of stippling. Whether rectangle s is
              rasterized or not depends on the fragment rule described for
              aliased lines, counting rectangles rather than groups of
              fragments.

              To enable and disable line stippling, call ggll::eennaabbllee//11 and
              ggll::eennaabbllee//11 with argument _?_G_L___L_I_N_E___S_T_I_P_P_L_E. When enabled, the
              line stipple pattern is applied as described above. When
              disabled, it is as if the pattern were all 1's. Initially, line
              stippling is disabled.

              See external documentation.

       ppoollyyggoonnMMooddee((FFaaccee,, MMooddee)) -->> ookk

              Types:

                 Face = enum()
                 Mode = enum()

              Select a polygon rasterization mode

              _g_l_:_p_o_l_y_g_o_n_M_o_d_e controls the interpretation of polygons for
              rasterization. _F_a_c_e describes which polygons _M_o_d_e applies to:
              both front and back-facing polygons (_?_G_L___F_R_O_N_T___A_N_D___B_A_C_K ). The
              polygon mode affects only the final rasterization of polygons.
              In particular, a polygon's vertices are lit and the polygon is
              clipped and possibly culled before these modes are applied.

              Three modes are defined and can be specified in _M_o_d_e :

              _?_G_L___P_O_I_N_T: Polygon vertices that are marked as the start of a
              boundary edge are drawn as points. Point attributes such as
              _?_G_L___P_O_I_N_T___S_I_Z_E and _?_G_L___P_O_I_N_T___S_M_O_O_T_H control the rasterization of
              the points. Polygon rasterization attributes other than
              _?_G_L___P_O_L_Y_G_O_N___M_O_D_E have no effect.

              _?_G_L___L_I_N_E: Boundary edges of the polygon are drawn as line
              segments. Line attributes such as _?_G_L___L_I_N_E___W_I_D_T_H and
              _?_G_L___L_I_N_E___S_M_O_O_T_H control the rasterization of the lines. Polygon
              rasterization attributes other than _?_G_L___P_O_L_Y_G_O_N___M_O_D_E have no
              effect.

              _?_G_L___F_I_L_L: The interior of the polygon is filled. Polygon
              attributes such as _?_G_L___P_O_L_Y_G_O_N___S_M_O_O_T_H control the rasterization
              of the polygon.

              See external documentation.

       ppoollyyggoonnOOffffsseett((FFaaccttoorr,, UUnniittss)) -->> ookk

              Types:

                 Factor = float()
                 Units = float()

              Set the scale and units used to calculate depth values

              When _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___F_I_L_L, _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___L_I_N_E, or
              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___P_O_I_N_T is enabled, each fragment's _d_e_p_t_h value
              will be offset after it is interpolated from the _d_e_p_t_h values of
              the appropriate vertices. The value of the offset is
              factor*DZ+r*units, where DZ is a measurement of the change in
              depth relative to the screen area of the polygon, and r is the
              smallest value that is guaranteed to produce a resolvable offset
              for a given implementation. The offset is added before the depth
              test is performed and before the value is written into the depth
              buffer.

              _g_l_:_p_o_l_y_g_o_n_O_f_f_s_e_t is useful for rendering hidden-line images, for
              applying decals to surfaces, and for rendering solids with
              highlighted edges.

              See external documentation.

       ppoollyyggoonnSSttiippppllee((MMaasskk)) -->> ookk

              Types:

                 Mask = binary()

              Set the polygon stippling pattern

              Polygon stippling, like line stippling (see ggll::lliinneeSSttiippppllee//22 ),
              masks out certain fragments produced by rasterization, creating
              a pattern. Stippling is independent of polygon antialiasing.

              _P_a_t_t_e_r_n is a pointer to a 32*32 stipple pattern that is stored
              in memory just like the pixel data supplied to a ggll::ddrraawwPPiixxeellss//55
              call with height and _w_i_d_t_h both equal to 32, a pixel format of
              _?_G_L___C_O_L_O_R___I_N_D_E_X, and data type of _?_G_L___B_I_T_M_A_P . That is, the
              stipple pattern is represented as a 32*32 array of 1-bit color
              indices packed in unsigned bytes. ggll::ppiixxeellSSttoorreeff//22 parameters
              like _?_G_L___U_N_P_A_C_K___S_W_A_P___B_Y_T_E_S and _?_G_L___U_N_P_A_C_K___L_S_B___F_I_R_S_T affect the
              assembling of the bits into a stipple pattern. Pixel transfer
              operations (shift, offset, pixel map) are not applied to the
              stipple image, however.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              stipple pattern is specified, _P_a_t_t_e_r_n is treated as a byte
              offset into the buffer object's data store.

              To enable and disable polygon stippling, call ggll::eennaabbllee//11 and
              ggll::eennaabbllee//11 with argument _?_G_L___P_O_L_Y_G_O_N___S_T_I_P_P_L_E. Polygon stippling
              is initially disabled. If it's enabled, a rasterized polygon
              fragment with window coordinates x w and y w is sent to the next
              stage of the GL if and only if the ( x w% 32)th bit in the ( y
              w% 32)th row of the stipple pattern is 1 (one). When polygon
              stippling is disabled, it is as if the stipple pattern consists
              of all 1's.

              See external documentation.

       ggeettPPoollyyggoonnSSttiippppllee(()) -->> bbiinnaarryy(())

              Return the polygon stipple pattern

              _g_l_:_g_e_t_P_o_l_y_g_o_n_S_t_i_p_p_l_e returns to _P_a_t_t_e_r_n a 32*32 polygon stipple
              pattern. The pattern is packed into memory as if ggll::rreeaaddPPiixxeellss//77
              with both _h_e_i_g_h_t and _w_i_d_t_h of 32, _t_y_p_e of _?_G_L___B_I_T_M_A_P, and _f_o_r_m_a_t
              of _?_G_L___C_O_L_O_R___I_N_D_E_X were called, and the stipple pattern were
              stored in an internal 32*32 color index buffer. Unlike
              ggll::rreeaaddPPiixxeellss//77 , however, pixel transfer operations (shift,
              offset, pixel map) are not applied to the returned stipple
              image.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              polygon stipple pattern is requested, _P_a_t_t_e_r_n is treated as a
              byte offset into the buffer object's data store.

              See external documentation.

       eeddggeeFFllaagg((FFllaagg)) -->> ookk

              Types:

                 Flag = 0 | 1

              Flag edges as either boundary or nonboundary

              Each vertex of a polygon, separate triangle, or separate
              quadrilateral specified between a ggll::''bbeeggiinn''//11 / ggll::''bbeeggiinn''//11
              pair is marked as the start of either a boundary or nonboundary
              edge. If the current edge flag is true when the vertex is
              specified, the vertex is marked as the start of a boundary edge.
              Otherwise, the vertex is marked as the start of a nonboundary
              edge. _g_l_:_e_d_g_e_F_l_a_g sets the edge flag bit to _?_G_L___T_R_U_E if _F_l_a_g is
              _?_G_L___T_R_U_E and to _?_G_L___F_A_L_S_E otherwise.

              The vertices of connected triangles and connected quadrilaterals
              are always marked as boundary, regardless of the value of the
              edge flag.

              Boundary and nonboundary edge flags on vertices are significant
              only if _?_G_L___P_O_L_Y_G_O_N___M_O_D_E is set to _?_G_L___P_O_I_N_T or _?_G_L___L_I_N_E. See
              ggll::ppoollyyggoonnMMooddee//22 .

              See external documentation.

       eeddggeeFFllaaggvv((FFllaagg)) -->> ookk

              Types:

                 Flag = {Flag::0 | 1}

              Equivalent to eeddggeeFFllaagg((FFllaagg)).

       sscciissssoorr((XX,, YY,, WWiiddtthh,, HHeeiigghhtt)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()
                 Width = integer()
                 Height = integer()

              Define the scissor box

              _g_l_:_s_c_i_s_s_o_r defines a rectangle, called the scissor box, in
              window coordinates. The first two arguments, _X and _Y , specify
              the lower left corner of the box. _W_i_d_t_h and _H_e_i_g_h_t specify the
              width and height of the box.

              To enable and disable the scissor test, call ggll::eennaabbllee//11 and
              ggll::eennaabbllee//11 with argument _?_G_L___S_C_I_S_S_O_R___T_E_S_T. The test is
              initially disabled. While the test is enabled, only pixels that
              lie within the scissor box can be modified by drawing commands.
              Window coordinates have integer values at the shared corners of
              frame buffer pixels. glScissor(0,0,1,1) allows modification of
              only the lower left pixel in the window, and glScissor(0,0,0,0)
              doesn't allow modification of any pixels in the window.

              When the scissor test is disabled, it is as though the scissor
              box includes the entire window.

              See external documentation.

       cclliippPPllaannee((PPllaannee,, EEqquuaattiioonn)) -->> ookk

              Types:

                 Plane = enum()
                 Equation = {float(), float(), float(), float()}

              Specify a plane against which all geometry is clipped

              Geometry is always clipped against the boundaries of a six-plane
              frustum in _x, _y , and _z. _g_l_:_c_l_i_p_P_l_a_n_e allows the specification
              of additional planes, not necessarily perpendicular to the _x, _y,
              or _z axis, against which all geometry is clipped. To determine
              the maximum number of additional clipping planes, call
              ggll::ggeettBBoooolleeaannvv//11 with argument _?_G_L___M_A_X___C_L_I_P___P_L_A_N_E_S. All
              implementations support at least six such clipping planes.
              Because the resulting clipping region is the intersection of the
              defined half-spaces, it is always convex.

              _g_l_:_c_l_i_p_P_l_a_n_e specifies a half-space using a four-component plane
              equation. When _g_l_:_c_l_i_p_P_l_a_n_e is called, _E_q_u_a_t_i_o_n is transformed
              by the inverse of the modelview matrix and stored in the
              resulting eye coordinates. Subsequent changes to the modelview
              matrix have no effect on the stored plane-equation components.
              If the dot product of the eye coordinates of a vertex with the
              stored plane equation components is positive or zero, the vertex
              is _i_n with respect to that clipping plane. Otherwise, it is _o_u_t.

              To enable and disable clipping planes, call ggll::eennaabbllee//11 and
              ggll::eennaabbllee//11 with the argument _?_G_L___C_L_I_P___P_L_A_N_E_i, where _i is the
              plane number.

              All clipping planes are initially defined as (0, 0, 0, 0) in eye
              coordinates and are disabled.

              See external documentation.

       ggeettCClliippPPllaannee((PPllaannee)) -->> {{ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(())}}

              Types:

                 Plane = enum()

              Return the coefficients of the specified clipping plane

              _g_l_:_g_e_t_C_l_i_p_P_l_a_n_e returns in _E_q_u_a_t_i_o_n the four coefficients of the
              plane equation for _P_l_a_n_e .

              See external documentation.

       ddrraawwBBuuffffeerr((MMooddee)) -->> ookk

              Types:

                 Mode = enum()

              Specify which color buffers are to be drawn into

              When colors are written to the frame buffer, they are written
              into the color buffers specified by _g_l_:_d_r_a_w_B_u_f_f_e_r. The
              specifications are as follows:

              _?_G_L___N_O_N_E: No color buffers are written.

              _?_G_L___F_R_O_N_T___L_E_F_T: Only the front left color buffer is written.

              _?_G_L___F_R_O_N_T___R_I_G_H_T: Only the front right color buffer is written.

              _?_G_L___B_A_C_K___L_E_F_T: Only the back left color buffer is written.

              _?_G_L___B_A_C_K___R_I_G_H_T: Only the back right color buffer is written.

              _?_G_L___F_R_O_N_T: Only the front left and front right color buffers are
              written. If there is no front right color buffer, only the front
              left color buffer is written.

              _?_G_L___B_A_C_K: Only the back left and back right color buffers are
              written. If there is no back right color buffer, only the back
              left color buffer is written.

              _?_G_L___L_E_F_T: Only the front left and back left color buffers are
              written. If there is no back left color buffer, only the front
              left color buffer is written.

              _?_G_L___R_I_G_H_T: Only the front right and back right color buffers are
              written. If there is no back right color buffer, only the front
              right color buffer is written.

              _?_G_L___F_R_O_N_T___A_N_D___B_A_C_K: All the front and back color buffers (front
              left, front right, back left, back right) are written. If there
              are no back color buffers, only the front left and front right
              color buffers are written. If there are no right color buffers,
              only the front left and back left color buffers are written. If
              there are no right or back color buffers, only the front left
              color buffer is written.

              If more than one color buffer is selected for drawing, then
              blending or logical operations are computed and applied
              independently for each color buffer and can produce different
              results in each buffer.

              Monoscopic contexts include only _l_e_f_t buffers, and stereoscopic
              contexts include both _l_e_f_t and _r_i_g_h_t buffers. Likewise, single-
              buffered contexts include only _f_r_o_n_t buffers, and double-
              buffered contexts include both _f_r_o_n_t and _b_a_c_k buffers. The
              context is selected at GL initialization.

              See external documentation.

       rreeaaddBBuuffffeerr((MMooddee)) -->> ookk

              Types:

                 Mode = enum()

              Select a color buffer source for pixels

              _g_l_:_r_e_a_d_B_u_f_f_e_r specifies a color buffer as the source for
              subsequent ggll::rreeaaddPPiixxeellss//77 , ggll::ccooppyyTTeexxIImmaaggee11DD//77 ,
              ggll::ccooppyyTTeexxIImmaaggee22DD//88 , ggll::ccooppyyTTeexxSSuubbIImmaaggee11DD//66 ,
              ggll::ccooppyyTTeexxSSuubbIImmaaggee22DD//88 , and ggll::ccooppyyTTeexxSSuubbIImmaaggee33DD//99 commands.
              _M_o_d_e accepts one of twelve or more predefined values. In a fully
              configured system, _?_G_L___F_R_O_N_T, _?_G_L___L_E_F_T, and _?_G_L___F_R_O_N_T___L_E_F_T all
              name the front left buffer, _?_G_L___F_R_O_N_T___R_I_G_H_T and _?_G_L___R_I_G_H_T name
              the front right buffer, and _?_G_L___B_A_C_K___L_E_F_T and _?_G_L___B_A_C_K name the
              back left buffer. Further more, the constants
              _?_G_L___C_O_L_O_R___A_T_T_A_C_H_M_E_N_T_i may be used to indicate the _ith color
              attachment where _i ranges from zero to the value of
              _?_G_L___M_A_X___C_O_L_O_R___A_T_T_A_C_H_M_E_N_T_S minus one.

              Nonstereo double-buffered configurations have only a front left
              and a back left buffer. Single-buffered configurations have a
              front left and a front right buffer if stereo, and only a front
              left buffer if nonstereo. It is an error to specify a
              nonexistent buffer to _g_l_:_r_e_a_d_B_u_f_f_e_r .

              _M_o_d_e is initially _?_G_L___F_R_O_N_T in single-buffered configurations
              and _?_G_L___B_A_C_K in double-buffered configurations.

              See external documentation.

       eennaabbllee((CCaapp)) -->> ookk

              Types:

                 Cap = enum()

              Enable or disable server-side GL capabilities

              _g_l_:_e_n_a_b_l_e and ggll::eennaabbllee//11 enable and disable various
              capabilities. Use ggll::iissEEnnaabblleedd//11 or ggll::ggeettBBoooolleeaannvv//11 to
              determine the current setting of any capability. The initial
              value for each capability with the exception of _?_G_L___D_I_T_H_E_R and
              _?_G_L___M_U_L_T_I_S_A_M_P_L_E is _?_G_L___F_A_L_S_E. The initial value for _?_G_L___D_I_T_H_E_R
              and _?_G_L___M_U_L_T_I_S_A_M_P_L_E is _?_G_L___T_R_U_E.

              Both _g_l_:_e_n_a_b_l_e and ggll::eennaabbllee//11 take a single argument, _C_a_p ,
              which can assume one of the following values:

              Some of the GL's capabilities are indexed. _g_l_:_e_n_a_b_l_e_i and
              _g_l_:_d_i_s_a_b_l_e_i enable and disable indexed capabilities.

              _?_G_L___B_L_E_N_D: If enabled, blend the computed fragment color values
              with the values in the color buffers. See ggll::bblleennddFFuunncc//22 .

              _?_G_L___C_L_I_P___D_I_S_T_A_N_C_E_i: If enabled, clip geometry against user-
              defined half space _i.

              _?_G_L___C_O_L_O_R___L_O_G_I_C___O_P: If enabled, apply the currently selected
              logical operation to the computed fragment color and color
              buffer values. See ggll::llooggiiccOOpp//11 .

              _?_G_L___C_U_L_L___F_A_C_E: If enabled, cull polygons based on their winding
              in window coordinates. See ggll::ccuullllFFaaccee//11 .

              _?_G_L___D_E_P_T_H___C_L_A_M_P: If enabled, the -w c&le; z c&le; w c plane
              equation is ignored by view volume clipping (effectively, there
              is no near or far plane clipping). See ggll::ddeepptthhRRaannggee//22 .

              _?_G_L___D_E_P_T_H___T_E_S_T: If enabled, do depth comparisons and update the
              depth buffer. Note that even if the depth buffer exists and the
              depth mask is non-zero, the depth buffer is not updated if the
              depth test is disabled. See ggll::ddeepptthhFFuunncc//11 and ggll::ddeepptthhRRaannggee//22 .

              _?_G_L___D_I_T_H_E_R: If enabled, dither color components or indices
              before they are written to the color buffer.

              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___S_R_G_B: If enabled and the value of
              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___C_O_L_O_R___E_N_C_O_D_I_N_G for the framebuffer
              attachment corresponding to the destination buffer is _?_G_L___S_R_G_B,
              the R, G, and B destination color values (after conversion from
              fixed-point to floating-point) are considered to be encoded for
              the sRGB color space and hence are linearized prior to their use
              in blending.

              _?_G_L___L_I_N_E___S_M_O_O_T_H: If enabled, draw lines with correct filtering.
              Otherwise, draw aliased lines. See ggll::lliinneeWWiiddtthh//11 .

              _?_G_L___M_U_L_T_I_S_A_M_P_L_E: If enabled, use multiple fragment samples in
              computing the final color of a pixel. See ggll::ssaammpplleeCCoovveerraaggee//22 .

              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___F_I_L_L: If enabled, and if the polygon is
              rendered in _?_G_L___F_I_L_L mode, an offset is added to depth values of
              a polygon's fragments before the depth comparison is performed.
              See ggll::ppoollyyggoonnOOffffsseett//22 .

              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___L_I_N_E: If enabled, and if the polygon is
              rendered in _?_G_L___L_I_N_E mode, an offset is added to depth values of
              a polygon's fragments before the depth comparison is performed.
              See ggll::ppoollyyggoonnOOffffsseett//22 .

              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___P_O_I_N_T: If enabled, an offset is added to
              depth values of a polygon's fragments before the depth
              comparison is performed, if the polygon is rendered in _?_G_L___P_O_I_N_T
              mode. See ggll::ppoollyyggoonnOOffffsseett//22 .

              _?_G_L___P_O_L_Y_G_O_N___S_M_O_O_T_H: If enabled, draw polygons with proper
              filtering. Otherwise, draw aliased polygons. For correct
              antialiased polygons, an alpha buffer is needed and the polygons
              must be sorted front to back.

              _?_G_L___P_R_I_M_I_T_I_V_E___R_E_S_T_A_R_T: Enables primitive restarting. If enabled,
              any one of the draw commands which transfers a set of generic
              attribute array elements to the GL will restart the primitive
              when the index of the vertex is equal to the primitive restart
              index. See ggll::pprriimmiittiivveeRReessttaarrttIInnddeexx//11 .

              _?_G_L___S_A_M_P_L_E___A_L_P_H_A___T_O___C_O_V_E_R_A_G_E: If enabled, compute a temporary
              coverage value where each bit is determined by the alpha value
              at the corresponding sample location. The temporary coverage
              value is then ANDed with the fragment coverage value.

              _?_G_L___S_A_M_P_L_E___A_L_P_H_A___T_O___O_N_E: If enabled, each sample alpha value is
              replaced by the maximum representable alpha value.

              _?_G_L___S_A_M_P_L_E___C_O_V_E_R_A_G_E: If enabled, the fragment's coverage is
              ANDed with the temporary coverage value. If
              _?_G_L___S_A_M_P_L_E___C_O_V_E_R_A_G_E___I_N_V_E_R_T is set to _?_G_L___T_R_U_E, invert the
              coverage value. See ggll::ssaammpplleeCCoovveerraaggee//22 .

              _?_G_L___S_A_M_P_L_E___S_H_A_D_I_N_G: If enabled, the active fragment shader is
              run once for each covered sample, or at fraction of this rate as
              determined by the current value of _?_G_L___M_I_N___S_A_M_P_L_E___S_H_A_D_I_N_G___V_A_L_U_E
              . See ggll::mmiinnSSaammpplleeSShhaaddiinngg//11 .

              _?_G_L___S_A_M_P_L_E___M_A_S_K: If enabled, the sample coverage mask generated
              for a fragment during rasterization will be ANDed with the value
              of _?_G_L___S_A_M_P_L_E___M_A_S_K___V_A_L_U_E before shading occurs. See
              ggll::ssaammpplleeMMaasskkii//22 .

              _?_G_L___S_C_I_S_S_O_R___T_E_S_T: If enabled, discard fragments that are outside
              the scissor rectangle. See ggll::sscciissssoorr//44 .

              _?_G_L___S_T_E_N_C_I_L___T_E_S_T: If enabled, do stencil testing and update the
              stencil buffer. See ggll::sstteenncciillFFuunncc//33 and ggll::sstteenncciillOOpp//33 .

              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___S_E_A_M_L_E_S_S: If enabled, cubemap textures are
              sampled such that when linearly sampling from the border between
              two adjacent faces, texels from both faces are used to generate
              the final sample value. When disabled, texels from only a single
              face are used to construct the final sample value.

              _?_G_L___P_R_O_G_R_A_M___P_O_I_N_T___S_I_Z_E: If enabled and a vertex or geometry
              shader is active, then the derived point size is taken from the
              (potentially clipped) shader builtin _?_g_l___P_o_i_n_t_S_i_z_e and clamped
              to the implementation-dependent point size range.

              See external documentation.

       ddiissaabbllee((CCaapp)) -->> ookk

              Types:

                 Cap = enum()

              See eennaabbllee//11

       iissEEnnaabblleedd((CCaapp)) -->> 00 || 11

              Types:

                 Cap = enum()

              Test whether a capability is enabled

              _g_l_:_i_s_E_n_a_b_l_e_d returns _?_G_L___T_R_U_E if _C_a_p is an enabled capability
              and returns _?_G_L___F_A_L_S_E otherwise. Boolean states that are indexed
              may be tested with _g_l_:_i_s_E_n_a_b_l_e_d_i . For _g_l_:_i_s_E_n_a_b_l_e_d_i, _I_n_d_e_x
              specifies the index of the capability to test. _I_n_d_e_x must be
              between zero and the count of indexed capabilities for _C_a_p .
              Initially all capabilities except _?_G_L___D_I_T_H_E_R are disabled;
              _?_G_L___D_I_T_H_E_R is initially enabled.

              The following capabilities are accepted for _C_a_p :_C_o_n_s_t_a_n_t_S_e_e
              _?_G_L___B_L_E_N_Dggll::bblleennddFFuunncc//22 , ggll::llooggiiccOOpp//11
              _?_G_L___C_L_I_P___D_I_S_T_A_N_C_E_iggll::eennaabbllee//11
              _?_G_L___C_O_L_O_R___L_O_G_I_C___O_Pggll::llooggiiccOOpp//11
              _?_G_L___C_U_L_L___F_A_C_Eggll::ccuullllFFaaccee//11
              _?_G_L___D_E_P_T_H___C_L_A_M_Pggll::eennaabbllee//11
              _?_G_L___D_E_P_T_H___T_E_S_Tggll::ddeepptthhFFuunncc//11 , ggll::ddeepptthhRRaannggee//22
              _?_G_L___D_I_T_H_E_Rggll::eennaabbllee//11
              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___S_R_G_Bggll::eennaabbllee//11
              _?_G_L___L_I_N_E___S_M_O_O_T_Hggll::lliinneeWWiiddtthh//11
              _?_G_L___M_U_L_T_I_S_A_M_P_L_Eggll::ssaammpplleeCCoovveerraaggee//22
              _?_G_L___P_O_L_Y_G_O_N___S_M_O_O_T_Hggll::ppoollyyggoonnMMooddee//22
              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___F_I_L_Lggll::ppoollyyggoonnOOffffsseett//22
              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___L_I_N_Eggll::ppoollyyggoonnOOffffsseett//22
              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___P_O_I_N_Tggll::ppoollyyggoonnOOffffsseett//22
              _?_G_L___P_R_O_G_R_A_M___P_O_I_N_T___S_I_Z_Eggll::eennaabbllee//11
              _?_G_L___P_R_I_M_I_T_I_V_E___R_E_S_T_A_R_Tggll::eennaabbllee//11 , ggll::pprriimmiittiivveeRReessttaarrttIInnddeexx//11
              _?_G_L___S_A_M_P_L_E___A_L_P_H_A___T_O___C_O_V_E_R_A_G_Eggll::ssaammpplleeCCoovveerraaggee//22
              _?_G_L___S_A_M_P_L_E___A_L_P_H_A___T_O___O_N_Eggll::ssaammpplleeCCoovveerraaggee//22
              _?_G_L___S_A_M_P_L_E___C_O_V_E_R_A_G_Eggll::ssaammpplleeCCoovveerraaggee//22
              _?_G_L___S_A_M_P_L_E___M_A_S_Kggll::eennaabbllee//11
              _?_G_L___S_C_I_S_S_O_R___T_E_S_Tggll::sscciissssoorr//44
              _?_G_L___S_T_E_N_C_I_L___T_E_S_Tggll::sstteenncciillFFuunncc//33 , ggll::sstteenncciillOOpp//33
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E_M_A_P___S_E_A_M_L_E_S_Sggll::eennaabbllee//11


              See external documentation.

       eennaabblleeCClliieennttSSttaattee((CCaapp)) -->> ookk

              Types:

                 Cap = enum()

              Enable or disable client-side capability

              _g_l_:_e_n_a_b_l_e_C_l_i_e_n_t_S_t_a_t_e and ggll::eennaabblleeCClliieennttSSttaattee//11 enable or
              disable individual client-side capabilities. By default, all
              client-side capabilities are disabled. Both _g_l_:_e_n_a_b_l_e_C_l_i_e_n_t_S_t_a_t_e
              and ggll::eennaabblleeCClliieennttSSttaattee//11 take a single argument, _C_a_p , which
              can assume one of the following values:

              _?_G_L___C_O_L_O_R___A_R_R_A_Y: If enabled, the color array is enabled for
              writing and used during rendering when ggll::aarrrraayyEElleemmeenntt//11 ,
              ggll::ddrraawwAArrrraayyss//33 , ggll::ddrraawwEElleemmeennttss//44 , ggll::ddrraawwRRaannggeeEElleemmeennttss//66
              ggll::mmuullttiiDDrraawwAArrrraayyss//33 , or see _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s is called. See
              ggll::ccoolloorrPPooiinntteerr//44 .

              _?_G_L___E_D_G_E___F_L_A_G___A_R_R_A_Y: If enabled, the edge flag array is enabled
              for writing and used during rendering when ggll::aarrrraayyEElleemmeenntt//11 ,
              ggll::ddrraawwAArrrraayyss//33 , ggll::ddrraawwEElleemmeennttss//44 , ggll::ddrraawwRRaannggeeEElleemmeennttss//66
              ggll::mmuullttiiDDrraawwAArrrraayyss//33 , or see _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s is called. See
              ggll::eeddggeeFFllaaggPPooiinntteerr//22 .

              _?_G_L___F_O_G___C_O_O_R_D___A_R_R_A_Y: If enabled, the fog coordinate array is
              enabled for writing and used during rendering when
              ggll::aarrrraayyEElleemmeenntt//11 , ggll::ddrraawwAArrrraayyss//33 , ggll::ddrraawwEElleemmeennttss//44 ,
              ggll::ddrraawwRRaannggeeEElleemmeennttss//66 ggll::mmuullttiiDDrraawwAArrrraayyss//33 , or see
              _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s is called. See ggll::ffooggCCoooorrddPPooiinntteerr//33 .

              _?_G_L___I_N_D_E_X___A_R_R_A_Y: If enabled, the index array is enabled for
              writing and used during rendering when ggll::aarrrraayyEElleemmeenntt//11 ,
              ggll::ddrraawwAArrrraayyss//33 , ggll::ddrraawwEElleemmeennttss//44 , ggll::ddrraawwRRaannggeeEElleemmeennttss//66
              ggll::mmuullttiiDDrraawwAArrrraayyss//33 , or see _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s is called. See
              ggll::iinnddeexxPPooiinntteerr//33 .

              _?_G_L___N_O_R_M_A_L___A_R_R_A_Y: If enabled, the normal array is enabled for
              writing and used during rendering when ggll::aarrrraayyEElleemmeenntt//11 ,
              ggll::ddrraawwAArrrraayyss//33 , ggll::ddrraawwEElleemmeennttss//44 , ggll::ddrraawwRRaannggeeEElleemmeennttss//66
              ggll::mmuullttiiDDrraawwAArrrraayyss//33 , or see _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s is called. See
              ggll::nnoorrmmaallPPooiinntteerr//33 .

              _?_G_L___S_E_C_O_N_D_A_R_Y___C_O_L_O_R___A_R_R_A_Y: If enabled, the secondary color array
              is enabled for writing and used during rendering when
              ggll::aarrrraayyEElleemmeenntt//11 , ggll::ddrraawwAArrrraayyss//33 , ggll::ddrraawwEElleemmeennttss//44 ,
              ggll::ddrraawwRRaannggeeEElleemmeennttss//66 ggll::mmuullttiiDDrraawwAArrrraayyss//33 , or see
              _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s is called. See ggll::ccoolloorrPPooiinntteerr//44 .

              _?_G_L___T_E_X_T_U_R_E___C_O_O_R_D___A_R_R_A_Y: If enabled, the texture coordinate
              array is enabled for writing and used during rendering when
              ggll::aarrrraayyEElleemmeenntt//11 , ggll::ddrraawwAArrrraayyss//33 , ggll::ddrraawwEElleemmeennttss//44 ,
              ggll::ddrraawwRRaannggeeEElleemmeennttss//66 ggll::mmuullttiiDDrraawwAArrrraayyss//33 , or see
              _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s is called. See ggll::tteexxCCoooorrddPPooiinntteerr//44 .

              _?_G_L___V_E_R_T_E_X___A_R_R_A_Y: If enabled, the vertex array is enabled for
              writing and used during rendering when ggll::aarrrraayyEElleemmeenntt//11 ,
              ggll::ddrraawwAArrrraayyss//33 , ggll::ddrraawwEElleemmeennttss//44 , ggll::ddrraawwRRaannggeeEElleemmeennttss//66
              ggll::mmuullttiiDDrraawwAArrrraayyss//33 , or see _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s is called. See
              ggll::vveerrtteexxPPooiinntteerr//44 .

              See external documentation.

       ddiissaabblleeCClliieennttSSttaattee((CCaapp)) -->> ookk

              Types:

                 Cap = enum()

              See eennaabblleeCClliieennttSSttaattee//11

       ggeettBBoooolleeaannvv((PPnnaammee)) -->> [[00 || 11]]

              Types:

                 Pname = enum()

              Return the value or values of a selected parameter

              These four commands return values for simple state variables in
              GL. _P_n_a_m_e is a symbolic constant indicating the state variable
              to be returned, and _P_a_r_a_m_s is a pointer to an array of the
              indicated type in which to place the returned data.

              Type conversion is performed if _P_a_r_a_m_s has a different type than
              the state variable value being requested. If _g_l_:_g_e_t_B_o_o_l_e_a_n_v is
              called, a floating-point (or integer) value is converted to
              _?_G_L___F_A_L_S_E if and only if it is 0.0 (or 0). Otherwise, it is
              converted to _?_G_L___T_R_U_E. If _g_l_:_g_e_t_I_n_t_e_g_e_r_v is called, boolean
              values are returned as _?_G_L___T_R_U_E or _?_G_L___F_A_L_S_E, and most floating-
              point values are rounded to the nearest integer value. Floating-
              point colors and normals, however, are returned with a linear
              mapping that maps 1.0 to the most positive representable integer
              value and -1.0 to the most negative representable integer value.
              If _g_l_:_g_e_t_F_l_o_a_t_v or _g_l_:_g_e_t_D_o_u_b_l_e_v is called, boolean values are
              returned as _?_G_L___T_R_U_E or _?_G_L___F_A_L_S_E, and integer values are
              converted to floating-point values.

              The following symbolic constants are accepted by _P_n_a_m_e :

              _?_G_L___A_C_T_I_V_E___T_E_X_T_U_R_E: _P_a_r_a_m_s returns a single value indicating the
              active multitexture unit. The initial value is _?_G_L___T_E_X_T_U_R_E_0. See
              ggll::aaccttiivveeTTeexxttuurree//11 .

              _?_G_L___A_L_I_A_S_E_D___L_I_N_E___W_I_D_T_H___R_A_N_G_E: _P_a_r_a_m_s returns a pair of values
              indicating the range of widths supported for aliased lines. See
              ggll::lliinneeWWiiddtthh//11 .

              _?_G_L___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G: _P_a_r_a_m_s returns a single value, the
              name of the buffer object currently bound to the target
              _?_G_L___A_R_R_A_Y___B_U_F_F_E_R. If no buffer object is bound to this target, 0
              is returned. The initial value is 0. See ggll::bbiinnddBBuuffffeerr//22 .

              _?_G_L___B_L_E_N_D: _P_a_r_a_m_s returns a single boolean value indicating
              whether blending is enabled. The initial value is _?_G_L___F_A_L_S_E. See
              ggll::bblleennddFFuunncc//22 .

              _?_G_L___B_L_E_N_D___C_O_L_O_R: _P_a_r_a_m_s returns four values, the red, green,
              blue, and alpha values which are the components of the blend
              color. See ggll::bblleennddCCoolloorr//44 .

              _?_G_L___B_L_E_N_D___D_S_T___A_L_P_H_A: _P_a_r_a_m_s returns one value, the symbolic
              constant identifying the alpha destination blend function. The
              initial value is _?_G_L___Z_E_R_O. See ggll::bblleennddFFuunncc//22 and
              ggll::bblleennddFFuunnccSSeeppaarraattee//44 .

              _?_G_L___B_L_E_N_D___D_S_T___R_G_B: _P_a_r_a_m_s returns one value, the symbolic
              constant identifying the RGB destination blend function. The
              initial value is _?_G_L___Z_E_R_O. See ggll::bblleennddFFuunncc//22 and
              ggll::bblleennddFFuunnccSSeeppaarraattee//44 .

              _?_G_L___B_L_E_N_D___E_Q_U_A_T_I_O_N___R_G_B: _P_a_r_a_m_s returns one value, a symbolic
              constant indicating whether the RGB blend equation is
              _?_G_L___F_U_N_C___A_D_D, _?_G_L___F_U_N_C___S_U_B_T_R_A_C_T, _?_G_L___F_U_N_C___R_E_V_E_R_S_E___S_U_B_T_R_A_C_T ,
              _?_G_L___M_I_N or _?_G_L___M_A_X. See ggll::bblleennddEEqquuaattiioonnSSeeppaarraattee//22 .

              _?_G_L___B_L_E_N_D___E_Q_U_A_T_I_O_N___A_L_P_H_A: _P_a_r_a_m_s returns one value, a symbolic
              constant indicating whether the Alpha blend equation is
              _?_G_L___F_U_N_C___A_D_D, _?_G_L___F_U_N_C___S_U_B_T_R_A_C_T , _?_G_L___F_U_N_C___R_E_V_E_R_S_E___S_U_B_T_R_A_C_T,
              _?_G_L___M_I_N or _?_G_L___M_A_X. See ggll::bblleennddEEqquuaattiioonnSSeeppaarraattee//22 .

              _?_G_L___B_L_E_N_D___S_R_C___A_L_P_H_A: _P_a_r_a_m_s returns one value, the symbolic
              constant identifying the alpha source blend function. The
              initial value is _?_G_L___O_N_E. See ggll::bblleennddFFuunncc//22 and
              ggll::bblleennddFFuunnccSSeeppaarraattee//44 .

              _?_G_L___B_L_E_N_D___S_R_C___R_G_B: _P_a_r_a_m_s returns one value, the symbolic
              constant identifying the RGB source blend function. The initial
              value is _?_G_L___O_N_E. See ggll::bblleennddFFuunncc//22 and ggll::bblleennddFFuunnccSSeeppaarraattee//44
              .

              _?_G_L___C_O_L_O_R___C_L_E_A_R___V_A_L_U_E: _P_a_r_a_m_s returns four values: the red,
              green, blue, and alpha values used to clear the color buffers.
              Integer values, if requested, are linearly mapped from the
              internal floating-point representation such that 1.0 returns the
              most positive representable integer value, and -1.0 returns the
              most negative representable integer value. The initial value is
              (0, 0, 0, 0). See ggll::cclleeaarrCCoolloorr//44 .

              _?_G_L___C_O_L_O_R___L_O_G_I_C___O_P: _P_a_r_a_m_s returns a single boolean value
              indicating whether a fragment's RGBA color values are merged
              into the framebuffer using a logical operation. The initial
              value is _?_G_L___F_A_L_S_E. See ggll::llooggiiccOOpp//11 .

              _?_G_L___C_O_L_O_R___W_R_I_T_E_M_A_S_K: _P_a_r_a_m_s returns four boolean values: the
              red, green, blue, and alpha write enables for the color buffers.
              The initial value is (_?_G_L___T_R_U_E, _?_G_L___T_R_U_E, _?_G_L___T_R_U_E, _?_G_L___T_R_U_E).
              See ggll::ccoolloorrMMaasskk//44 .

              _?_G_L___C_O_M_P_R_E_S_S_E_D___T_E_X_T_U_R_E___F_O_R_M_A_T_S: _P_a_r_a_m_s returns a list of
              symbolic constants of length _?_G_L___N_U_M___C_O_M_P_R_E_S_S_E_D___T_E_X_T_U_R_E___F_O_R_M_A_T_S
              indicating which compressed texture formats are available. See
              ggll::ccoommpprreesssseeddTTeexxIImmaaggee22DD//88 .

              _?_G_L___C_O_N_T_E_X_T___F_L_A_G_S: _P_a_r_a_m_s returns one value, the flags with
              which the context was created (such as debugging functionality).

              _?_G_L___C_U_L_L___F_A_C_E: _P_a_r_a_m_s returns a single boolean value indicating
              whether polygon culling is enabled. The initial value is
              _?_G_L___F_A_L_S_E. See ggll::ccuullllFFaaccee//11 .

              _?_G_L___C_U_R_R_E_N_T___P_R_O_G_R_A_M: _P_a_r_a_m_s returns one value, the name of the
              program object that is currently active, or 0 if no program
              object is active. See ggll::uusseePPrrooggrraamm//11 .

              _?_G_L___D_E_P_T_H___C_L_E_A_R___V_A_L_U_E: _P_a_r_a_m_s returns one value, the value that
              is used to clear the depth buffer. Integer values, if requested,
              are linearly mapped from the internal floating-point
              representation such that 1.0 returns the most positive
              representable integer value, and -1.0 returns the most negative
              representable integer value. The initial value is 1. See
              ggll::cclleeaarrDDeepptthh//11 .

              _?_G_L___D_E_P_T_H___F_U_N_C: _P_a_r_a_m_s returns one value, the symbolic constant
              that indicates the depth comparison function. The initial value
              is _?_G_L___L_E_S_S. See ggll::ddeepptthhFFuunncc//11 .

              _?_G_L___D_E_P_T_H___R_A_N_G_E: _P_a_r_a_m_s returns two values: the near and far
              mapping limits for the depth buffer. Integer values, if
              requested, are linearly mapped from the internal floating-point
              representation such that 1.0 returns the most positive
              representable integer value, and -1.0 returns the most negative
              representable integer value. The initial value is (0, 1). See
              ggll::ddeepptthhRRaannggee//22 .

              _?_G_L___D_E_P_T_H___T_E_S_T: _P_a_r_a_m_s returns a single boolean value indicating
              whether depth testing of fragments is enabled. The initial value
              is _?_G_L___F_A_L_S_E. See ggll::ddeepptthhFFuunncc//11 and ggll::ddeepptthhRRaannggee//22 .

              _?_G_L___D_E_P_T_H___W_R_I_T_E_M_A_S_K: _P_a_r_a_m_s returns a single boolean value
              indicating if the depth buffer is enabled for writing. The
              initial value is _?_G_L___T_R_U_E. See ggll::ddeepptthhMMaasskk//11 .

              _?_G_L___D_I_T_H_E_R: _P_a_r_a_m_s returns a single boolean value indicating
              whether dithering of fragment colors and indices is enabled. The
              initial value is _?_G_L___T_R_U_E.

              _?_G_L___D_O_U_B_L_E_B_U_F_F_E_R: _P_a_r_a_m_s returns a single boolean value
              indicating whether double buffering is supported.

              _?_G_L___D_R_A_W___B_U_F_F_E_R: _P_a_r_a_m_s returns one value, a symbolic constant
              indicating which buffers are being drawn to. See ggll::ddrraawwBBuuffffeerr//11
              . The initial value is _?_G_L___B_A_C_K if there are back buffers,
              otherwise it is _?_G_L___F_R_O_N_T.

              _?_G_L___D_R_A_W___B_U_F_F_E_R_i: _P_a_r_a_m_s returns one value, a symbolic constant
              indicating which buffers are being drawn to by the corresponding
              output color. See ggll::ddrraawwBBuuffffeerrss//11 . The initial value of
              _?_G_L___D_R_A_W___B_U_F_F_E_R_0 is _?_G_L___B_A_C_K if there are back buffers,
              otherwise it is _?_G_L___F_R_O_N_T. The initial values of draw buffers
              for all other output colors is _?_G_L___N_O_N_E.

              _?_G_L___D_R_A_W___F_R_A_M_E_B_U_F_F_E_R___B_I_N_D_I_N_G: _P_a_r_a_m_s returns one value, the name
              of the framebuffer object currently bound to the
              _?_G_L___D_R_A_W___F_R_A_M_E_B_U_F_F_E_R target. If the default framebuffer is
              bound, this value will be zero. The initial value is zero. See
              ggll::bbiinnddFFrraammeebbuuffffeerr//22 .

              _?_G_L___R_E_A_D___F_R_A_M_E_B_U_F_F_E_R___B_I_N_D_I_N_G: _P_a_r_a_m_s returns one value, the name
              of the framebuffer object currently bound to the
              _?_G_L___R_E_A_D___F_R_A_M_E_B_U_F_F_E_R target. If the default framebuffer is
              bound, this value will be zero. The initial value is zero. See
              ggll::bbiinnddFFrraammeebbuuffffeerr//22 .

              _?_G_L___E_L_E_M_E_N_T___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G: _P_a_r_a_m_s returns a single value,
              the name of the buffer object currently bound to the target
              _?_G_L___E_L_E_M_E_N_T___A_R_R_A_Y___B_U_F_F_E_R. If no buffer object is bound to this
              target, 0 is returned. The initial value is 0. See
              ggll::bbiinnddBBuuffffeerr//22 .

              _?_G_L___F_R_A_G_M_E_N_T___S_H_A_D_E_R___D_E_R_I_V_A_T_I_V_E___H_I_N_T: _P_a_r_a_m_s returns one value, a
              symbolic constant indicating the mode of the derivative accuracy
              hint for fragment shaders. The initial value is _?_G_L___D_O_N_T___C_A_R_E.
              See ggll::hhiinntt//22 .

              _?_G_L___I_M_P_L_E_M_E_N_T_A_T_I_O_N___C_O_L_O_R___R_E_A_D___F_O_R_M_A_T: _P_a_r_a_m_s returns a single
              GLenum value indicating the implementation's preferred pixel
              data format. See ggll::rreeaaddPPiixxeellss//77 .

              _?_G_L___I_M_P_L_E_M_E_N_T_A_T_I_O_N___C_O_L_O_R___R_E_A_D___T_Y_P_E: _P_a_r_a_m_s returns a single
              GLenum value indicating the implementation's preferred pixel
              data type. See ggll::rreeaaddPPiixxeellss//77 .

              _?_G_L___L_I_N_E___S_M_O_O_T_H: _P_a_r_a_m_s returns a single boolean value
              indicating whether antialiasing of lines is enabled. The initial
              value is _?_G_L___F_A_L_S_E. See ggll::lliinneeWWiiddtthh//11 .

              _?_G_L___L_I_N_E___S_M_O_O_T_H___H_I_N_T: _P_a_r_a_m_s returns one value, a symbolic
              constant indicating the mode of the line antialiasing hint. The
              initial value is _?_G_L___D_O_N_T___C_A_R_E. See ggll::hhiinntt//22 .

              _?_G_L___L_I_N_E___W_I_D_T_H: _P_a_r_a_m_s returns one value, the line width as
              specified with ggll::lliinneeWWiiddtthh//11 . The initial value is 1.

              _?_G_L___L_A_Y_E_R___P_R_O_V_O_K_I_N_G___V_E_R_T_E_X: _P_a_r_a_m_s returns one value, the
              implementation dependent specifc vertex of a primitive that is
              used to select the rendering layer. If the value returned is
              equivalent to _?_G_L___P_R_O_V_O_K_I_N_G___V_E_R_T_E_X, then the vertex selection
              follows the convention specified by ggll::pprroovvookkiinnggVVeerrtteexx//11 . If
              the value returned is equivalent to _?_G_L___F_I_R_S_T___V_E_R_T_E_X___C_O_N_V_E_N_T_I_O_N,
              then the selection is always taken from the first vertex in the
              primitive. If the value returned is equivalent to
              _?_G_L___L_A_S_T___V_E_R_T_E_X___C_O_N_V_E_N_T_I_O_N , then the selection is always taken
              from the last vertex in the primitive. If the value returned is
              equivalent to _?_G_L___U_N_D_E_F_I_N_E_D___V_E_R_T_E_X, then the selection is not
              guaranteed to be taken from any specific vertex in the
              primitive.

              _?_G_L___L_I_N_E___W_I_D_T_H___G_R_A_N_U_L_A_R_I_T_Y: _P_a_r_a_m_s returns one value, the width
              difference between adjacent supported widths for antialiased
              lines. See ggll::lliinneeWWiiddtthh//11 .

              _?_G_L___L_I_N_E___W_I_D_T_H___R_A_N_G_E: _P_a_r_a_m_s returns two values: the smallest
              and largest supported widths for antialiased lines. See
              ggll::lliinneeWWiiddtthh//11 .

              _?_G_L___L_O_G_I_C___O_P___M_O_D_E: _P_a_r_a_m_s returns one value, a symbolic constant
              indicating the selected logic operation mode. The initial value
              is _?_G_L___C_O_P_Y. See ggll::llooggiiccOOpp//11 .

              _?_G_L___M_A_J_O_R___V_E_R_S_I_O_N: _P_a_r_a_m_s returns one value, the major version
              number of the OpenGL API supported by the current context.

              _?_G_L___M_A_X___3_D___T_E_X_T_U_R_E___S_I_Z_E: _P_a_r_a_m_s returns one value, a rough
              estimate of the largest 3D texture that the GL can handle. The
              value must be at least 64. Use _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___3_D to determine
              if a texture is too large. See ggll::tteexxIImmaaggee33DD//1100 .

              _?_G_L___M_A_X___A_R_R_A_Y___T_E_X_T_U_R_E___L_A_Y_E_R_S: _P_a_r_a_m_s returns one value. The
              value indicates the maximum number of layers allowed in an array
              texture, and must be at least 256. See ggll::tteexxIImmaaggee22DD//99 .

              _?_G_L___M_A_X___C_L_I_P___D_I_S_T_A_N_C_E_S: _P_a_r_a_m_s returns one value, the maximum
              number of application-defined clipping distances. The value must
              be at least 8.

              _?_G_L___M_A_X___C_O_L_O_R___T_E_X_T_U_R_E___S_A_M_P_L_E_S: _P_a_r_a_m_s returns one value, the
              maximum number of samples in a color multisample texture.

              _?_G_L___M_A_X___C_O_M_B_I_N_E_D___A_T_O_M_I_C___C_O_U_N_T_E_R_S: _P_a_r_a_m_s returns a single value,
              the maximum number of atomic counters available to all active
              shaders.

              _?_G_L___M_A_X___C_O_M_B_I_N_E_D___F_R_A_G_M_E_N_T___U_N_I_F_O_R_M___C_O_M_P_O_N_E_N_T_S: _P_a_r_a_m_s returns one
              value, the number of words for fragment shader uniform variables
              in all uniform blocks (including default). The value must be at
              least 1. See ggll::uunniiffoorrmm11ff//22 .

              _?_G_L___M_A_X___C_O_M_B_I_N_E_D___G_E_O_M_E_T_R_Y___U_N_I_F_O_R_M___C_O_M_P_O_N_E_N_T_S: _P_a_r_a_m_s returns one
              value, the number of words for geometry shader uniform variables
              in all uniform blocks (including default). The value must be at
              least 1. See ggll::uunniiffoorrmm11ff//22 .

              _?_G_L___M_A_X___C_O_M_B_I_N_E_D___T_E_X_T_U_R_E___I_M_A_G_E___U_N_I_T_S: _P_a_r_a_m_s returns one value,
              the maximum supported texture image units that can be used to
              access texture maps from the vertex shader and the fragment
              processor combined. If both the vertex shader and the fragment
              processing stage access the same texture image unit, then that
              counts as using two texture image units against this limit. The
              value must be at least 48. See ggll::aaccttiivveeTTeexxttuurree//11 .

              _?_G_L___M_A_X___C_O_M_B_I_N_E_D___U_N_I_F_O_R_M___B_L_O_C_K_S: _P_a_r_a_m_s returns one value, the
              maximum number of uniform blocks per program. The value must be
              at least 36. See ggll::uunniiffoorrmmBBlloocckkBBiinnddiinngg//33 .

              _?_G_L___M_A_X___C_O_M_B_I_N_E_D___V_E_R_T_E_X___U_N_I_F_O_R_M___C_O_M_P_O_N_E_N_T_S: _P_a_r_a_m_s returns one
              value, the number of words for vertex shader uniform variables
              in all uniform blocks (including default). The value must be at
              least 1. See ggll::uunniiffoorrmm11ff//22 .

              _?_G_L___M_A_X___C_U_B_E___M_A_P___T_E_X_T_U_R_E___S_I_Z_E: _P_a_r_a_m_s returns one value. The
              value gives a rough estimate of the largest cube-map texture
              that the GL can handle. The value must be at least 1024. Use
              _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___C_U_B_E___M_A_P to determine if a texture is too
              large. See ggll::tteexxIImmaaggee22DD//99 .

              _?_G_L___M_A_X___D_E_P_T_H___T_E_X_T_U_R_E___S_A_M_P_L_E_S: _P_a_r_a_m_s returns one value, the
              maximum number of samples in a multisample depth or depth-
              stencil texture.

              _?_G_L___M_A_X___D_R_A_W___B_U_F_F_E_R_S: _P_a_r_a_m_s returns one value, the maximum
              number of simultaneous outputs that may be written in a fragment
              shader. The value must be at least 8. See ggll::ddrraawwBBuuffffeerrss//11 .

              _?_G_L___M_A_X___D_U_A_L_S_O_U_R_C_E___D_R_A_W___B_U_F_F_E_R_S: _P_a_r_a_m_s returns one value, the
              maximum number of active draw buffers when using dual-source
              blending. The value must be at least 1. See ggll::bblleennddFFuunncc//22 and
              ggll::bblleennddFFuunnccSSeeppaarraattee//44 .

              _?_G_L___M_A_X___E_L_E_M_E_N_T_S___I_N_D_I_C_E_S: _P_a_r_a_m_s returns one value, the
              recommended maximum number of vertex array indices. See
              ggll::ddrraawwRRaannggeeEElleemmeennttss//66 .

              _?_G_L___M_A_X___E_L_E_M_E_N_T_S___V_E_R_T_I_C_E_S: _P_a_r_a_m_s returns one value, the
              recommended maximum number of vertex array vertices. See
              ggll::ddrraawwRRaannggeeEElleemmeennttss//66 .

              _?_G_L___M_A_X___F_R_A_G_M_E_N_T___A_T_O_M_I_C___C_O_U_N_T_E_R_S: _P_a_r_a_m_s returns a single value,
              the maximum number of atomic counters available to fragment
              shaders.

              _?_G_L___M_A_X___F_R_A_G_M_E_N_T___I_N_P_U_T___C_O_M_P_O_N_E_N_T_S: _P_a_r_a_m_s returns one value, the
              maximum number of components of the inputs read by the fragment
              shader, which must be at least 128.

              _?_G_L___M_A_X___F_R_A_G_M_E_N_T___U_N_I_F_O_R_M___C_O_M_P_O_N_E_N_T_S: _P_a_r_a_m_s returns one value,
              the maximum number of individual floating-point, integer, or
              boolean values that can be held in uniform variable storage for
              a fragment shader. The value must be at least 1024. See
              ggll::uunniiffoorrmm11ff//22 .

              _?_G_L___M_A_X___F_R_A_G_M_E_N_T___U_N_I_F_O_R_M___V_E_C_T_O_R_S: _P_a_r_a_m_s returns one value, the
              maximum number of individual 4-vectors of floating-point,
              integer, or boolean values that can be held in uniform variable
              storage for a fragment shader. The value is equal to the value
              of _?_G_L___M_A_X___F_R_A_G_M_E_N_T___U_N_I_F_O_R_M___C_O_M_P_O_N_E_N_T_S divided by 4 and must be
              at least 256. See ggll::uunniiffoorrmm11ff//22 .

              _?_G_L___M_A_X___F_R_A_G_M_E_N_T___U_N_I_F_O_R_M___B_L_O_C_K_S: _P_a_r_a_m_s returns one value, the
              maximum number of uniform blocks per fragment shader. The value
              must be at least 12. See ggll::uunniiffoorrmmBBlloocckkBBiinnddiinngg//33 .

              _?_G_L___M_A_X___G_E_O_M_E_T_R_Y___A_T_O_M_I_C___C_O_U_N_T_E_R_S: _P_a_r_a_m_s returns a single value,
              the maximum number of atomic counters available to geometry
              shaders.

              _?_G_L___M_A_X___G_E_O_M_E_T_R_Y___I_N_P_U_T___C_O_M_P_O_N_E_N_T_S: _P_a_r_a_m_s returns one value, the
              maximum number of components of inputs read by a geometry
              shader, which must be at least 64.

              _?_G_L___M_A_X___G_E_O_M_E_T_R_Y___O_U_T_P_U_T___C_O_M_P_O_N_E_N_T_S: _P_a_r_a_m_s returns one value,
              the maximum number of components of outputs written by a
              geometry shader, which must be at least 128.

              _?_G_L___M_A_X___G_E_O_M_E_T_R_Y___T_E_X_T_U_R_E___I_M_A_G_E___U_N_I_T_S: _P_a_r_a_m_s returns one value,
              the maximum supported texture image units that can be used to
              access texture maps from the geometry shader. The value must be
              at least 16. See ggll::aaccttiivveeTTeexxttuurree//11 .

              _?_G_L___M_A_X___G_E_O_M_E_T_R_Y___U_N_I_F_O_R_M___B_L_O_C_K_S: _P_a_r_a_m_s returns one value, the
              maximum number of uniform blocks per geometry shader. The value
              must be at least 12. See ggll::uunniiffoorrmmBBlloocckkBBiinnddiinngg//33 .

              _?_G_L___M_A_X___G_E_O_M_E_T_R_Y___U_N_I_F_O_R_M___C_O_M_P_O_N_E_N_T_S: _P_a_r_a_m_s returns one value,
              the maximum number of individual floating-point, integer, or
              boolean values that can be held in uniform variable storage for
              a geometry shader. The value must be at least 1024. See
              ggll::uunniiffoorrmm11ff//22 .

              _?_G_L___M_A_X___I_N_T_E_G_E_R___S_A_M_P_L_E_S: _P_a_r_a_m_s returns one value, the maximum
              number of samples supported in integer format multisample
              buffers.

              _?_G_L___M_I_N___M_A_P___B_U_F_F_E_R___A_L_I_G_N_M_E_N_T: _P_a_r_a_m_s returns one value, the
              minimum alignment in basic machine units of pointers returned
              fromsee _g_l_M_a_p_B_u_f_f_e_r and see _g_l_M_a_p_B_u_f_f_e_r_R_a_n_g_e . This value must
              be a power of two and must be at least 64.

              _?_G_L___M_A_X___P_R_O_G_R_A_M___T_E_X_E_L___O_F_F_S_E_T: _P_a_r_a_m_s returns one value, the
              maximum texel offset allowed in a texture lookup, which must be
              at least 7.

              _?_G_L___M_I_N___P_R_O_G_R_A_M___T_E_X_E_L___O_F_F_S_E_T: _P_a_r_a_m_s returns one value, the
              minimum texel offset allowed in a texture lookup, which must be
              at most -8.

              _?_G_L___M_A_X___R_E_C_T_A_N_G_L_E___T_E_X_T_U_R_E___S_I_Z_E: _P_a_r_a_m_s returns one value. The
              value gives a rough estimate of the largest rectangular texture
              that the GL can handle. The value must be at least 1024. Use
              _?_G_L___P_R_O_X_Y___R_E_C_T_A_N_G_L_E___T_E_X_T_U_R_E to determine if a texture is too
              large. See ggll::tteexxIImmaaggee22DD//99 .

              _?_G_L___M_A_X___R_E_N_D_E_R_B_U_F_F_E_R___S_I_Z_E: _P_a_r_a_m_s returns one value. The value
              indicates the maximum supported size for renderbuffers. See
              ggll::ffrraammeebbuuffffeerrRReennddeerrbbuuffffeerr//44 .

              _?_G_L___M_A_X___S_A_M_P_L_E___M_A_S_K___W_O_R_D_S: _P_a_r_a_m_s returns one value, the maximum
              number of sample mask words.

              _?_G_L___M_A_X___S_E_R_V_E_R___W_A_I_T___T_I_M_E_O_U_T: _P_a_r_a_m_s returns one value, the
              maximum ggll::wwaaiittSSyynncc//33 timeout interval.

              _?_G_L___M_A_X___T_E_S_S___C_O_N_T_R_O_L___A_T_O_M_I_C___C_O_U_N_T_E_R_S: _P_a_r_a_m_s returns a single
              value, the maximum number of atomic counters available to
              tessellation control shaders.

              _?_G_L___M_A_X___T_E_S_S___E_V_A_L_U_A_T_I_O_N___A_T_O_M_I_C___C_O_U_N_T_E_R_S: _P_a_r_a_m_s returns a single
              value, the maximum number of atomic counters available to
              tessellation evaluation shaders.

              _?_G_L___M_A_X___T_E_X_T_U_R_E___B_U_F_F_E_R___S_I_Z_E: _P_a_r_a_m_s returns one value. The value
              gives the maximum number of texels allowed in the texel array of
              a texture buffer object. Value must be at least 65536.

              _?_G_L___M_A_X___T_E_X_T_U_R_E___I_M_A_G_E___U_N_I_T_S: _P_a_r_a_m_s returns one value, the
              maximum supported texture image units that can be used to access
              texture maps from the fragment shader. The value must be at
              least 16. See ggll::aaccttiivveeTTeexxttuurree//11 .

              _?_G_L___M_A_X___T_E_X_T_U_R_E___L_O_D___B_I_A_S: _P_a_r_a_m_s returns one value, the maximum,
              absolute value of the texture level-of-detail bias. The value
              must be at least 2.0.

              _?_G_L___M_A_X___T_E_X_T_U_R_E___S_I_Z_E: _P_a_r_a_m_s returns one value. The value gives
              a rough estimate of the largest texture that the GL can handle.
              The value must be at least 1024. Use a proxy texture target such
              as _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___1_D or _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___2_D to determine if
              a texture is too large. See ggll::tteexxIImmaaggee11DD//88 and ggll::tteexxIImmaaggee22DD//99
              .

              _?_G_L___M_A_X___U_N_I_F_O_R_M___B_U_F_F_E_R___B_I_N_D_I_N_G_S: _P_a_r_a_m_s returns one value, the
              maximum number of uniform buffer binding points on the context,
              which must be at least 36.

              _?_G_L___M_A_X___U_N_I_F_O_R_M___B_L_O_C_K___S_I_Z_E: _P_a_r_a_m_s returns one value, the
              maximum size in basic machine units of a uniform block, which
              must be at least 16384.

              _?_G_L___M_A_X___V_A_R_Y_I_N_G___C_O_M_P_O_N_E_N_T_S: _P_a_r_a_m_s returns one value, the number
              components for varying variables, which must be at least 60.

              _?_G_L___M_A_X___V_A_R_Y_I_N_G___V_E_C_T_O_R_S: _P_a_r_a_m_s returns one value, the number
              4-vectors for varying variables, which is equal to the value of
              _?_G_L___M_A_X___V_A_R_Y_I_N_G___C_O_M_P_O_N_E_N_T_S and must be at least 15.

              _?_G_L___M_A_X___V_A_R_Y_I_N_G___F_L_O_A_T_S: _P_a_r_a_m_s returns one value, the maximum
              number of interpolators available for processing varying
              variables used by vertex and fragment shaders. This value
              represents the number of individual floating-point values that
              can be interpolated; varying variables declared as vectors,
              matrices, and arrays will all consume multiple interpolators.
              The value must be at least 32.

              _?_G_L___M_A_X___V_E_R_T_E_X___A_T_O_M_I_C___C_O_U_N_T_E_R_S: _P_a_r_a_m_s returns a single value,
              the maximum number of atomic counters available to vertex
              shaders.

              _?_G_L___M_A_X___V_E_R_T_E_X___A_T_T_R_I_B_S: _P_a_r_a_m_s returns one value, the maximum
              number of 4-component generic vertex attributes accessible to a
              vertex shader. The value must be at least 16. See
              ggll::vveerrtteexxAAttttrriibb11dd//22 .

              _?_G_L___M_A_X___V_E_R_T_E_X___T_E_X_T_U_R_E___I_M_A_G_E___U_N_I_T_S: _P_a_r_a_m_s returns one value,
              the maximum supported texture image units that can be used to
              access texture maps from the vertex shader. The value may be at
              least 16. See ggll::aaccttiivveeTTeexxttuurree//11 .

              _?_G_L___M_A_X___V_E_R_T_E_X___U_N_I_F_O_R_M___C_O_M_P_O_N_E_N_T_S: _P_a_r_a_m_s returns one value, the
              maximum number of individual floating-point, integer, or boolean
              values that can be held in uniform variable storage for a vertex
              shader. The value must be at least 1024. See ggll::uunniiffoorrmm11ff//22 .

              _?_G_L___M_A_X___V_E_R_T_E_X___U_N_I_F_O_R_M___V_E_C_T_O_R_S: _P_a_r_a_m_s returns one value, the
              maximum number of 4-vectors that may be held in uniform variable
              storage for the vertex shader. The value of
              _?_G_L___M_A_X___V_E_R_T_E_X___U_N_I_F_O_R_M___V_E_C_T_O_R_S is equal to the value of
              _?_G_L___M_A_X___V_E_R_T_E_X___U_N_I_F_O_R_M___C_O_M_P_O_N_E_N_T_S and must be at least 256.

              _?_G_L___M_A_X___V_E_R_T_E_X___O_U_T_P_U_T___C_O_M_P_O_N_E_N_T_S: _P_a_r_a_m_s returns one value, the
              maximum number of components of output written by a vertex
              shader, which must be at least 64.

              _?_G_L___M_A_X___V_E_R_T_E_X___U_N_I_F_O_R_M___B_L_O_C_K_S: _P_a_r_a_m_s returns one value, the
              maximum number of uniform blocks per vertex shader. The value
              must be at least 12. See ggll::uunniiffoorrmmBBlloocckkBBiinnddiinngg//33 .

              _?_G_L___M_A_X___V_I_E_W_P_O_R_T___D_I_M_S: _P_a_r_a_m_s returns two values: the maximum
              supported width and height of the viewport. These must be at
              least as large as the visible dimensions of the display being
              rendered to. See ggll::vviieewwppoorrtt//44 .

              _?_G_L___M_A_X___V_I_E_W_P_O_R_T_S: _P_a_r_a_m_s returns one value, the maximum number
              of simultaneous viewports that are supported. The value must be
              at least 16. See ggll::vviieewwppoorrttIInnddeexxeeddff//55 .

              _?_G_L___M_I_N_O_R___V_E_R_S_I_O_N: _P_a_r_a_m_s returns one value, the minor version
              number of the OpenGL API supported by the current context.

              _?_G_L___N_U_M___C_O_M_P_R_E_S_S_E_D___T_E_X_T_U_R_E___F_O_R_M_A_T_S: _P_a_r_a_m_s returns a single
              integer value indicating the number of available compressed
              texture formats. The minimum value is 4. See
              ggll::ccoommpprreesssseeddTTeexxIImmaaggee22DD//88 .

              _?_G_L___N_U_M___E_X_T_E_N_S_I_O_N_S: _P_a_r_a_m_s returns one value, the number of
              extensions supported by the GL implementation for the current
              context. See ggll::ggeettSSttrriinngg//11 .

              _?_G_L___N_U_M___P_R_O_G_R_A_M___B_I_N_A_R_Y___F_O_R_M_A_T_S: _P_a_r_a_m_s returns one value, the
              number of program binary formats supported by the
              implementation.

              _?_G_L___N_U_M___S_H_A_D_E_R___B_I_N_A_R_Y___F_O_R_M_A_T_S: _P_a_r_a_m_s returns one value, the
              number of binary shader formats supported by the implementation.
              If this value is greater than zero, then the implementation
              supports loading binary shaders. If it is zero, then the loading
              of binary shaders by the implementation is not supported.

              _?_G_L___P_A_C_K___A_L_I_G_N_M_E_N_T: _P_a_r_a_m_s returns one value, the byte alignment
              used for writing pixel data to memory. The initial value is 4.
              See ggll::ppiixxeellSSttoorreeff//22 .

              _?_G_L___P_A_C_K___I_M_A_G_E___H_E_I_G_H_T: _P_a_r_a_m_s returns one value, the image
              height used for writing pixel data to memory. The initial value
              is 0. See ggll::ppiixxeellSSttoorreeff//22 .

              _?_G_L___P_A_C_K___L_S_B___F_I_R_S_T: _P_a_r_a_m_s returns a single boolean value
              indicating whether single-bit pixels being written to memory are
              written first to the least significant bit of each unsigned
              byte. The initial value is _?_G_L___F_A_L_S_E. See ggll::ppiixxeellSSttoorreeff//22 .

              _?_G_L___P_A_C_K___R_O_W___L_E_N_G_T_H: _P_a_r_a_m_s returns one value, the row length
              used for writing pixel data to memory. The initial value is 0.
              See ggll::ppiixxeellSSttoorreeff//22 .

              _?_G_L___P_A_C_K___S_K_I_P___I_M_A_G_E_S: _P_a_r_a_m_s returns one value, the number of
              pixel images skipped before the first pixel is written into
              memory. The initial value is 0. See ggll::ppiixxeellSSttoorreeff//22 .

              _?_G_L___P_A_C_K___S_K_I_P___P_I_X_E_L_S: _P_a_r_a_m_s returns one value, the number of
              pixel locations skipped before the first pixel is written into
              memory. The initial value is 0. See ggll::ppiixxeellSSttoorreeff//22 .

              _?_G_L___P_A_C_K___S_K_I_P___R_O_W_S: _P_a_r_a_m_s returns one value, the number of rows
              of pixel locations skipped before the first pixel is written
              into memory. The initial value is 0. See ggll::ppiixxeellSSttoorreeff//22 .

              _?_G_L___P_A_C_K___S_W_A_P___B_Y_T_E_S: _P_a_r_a_m_s returns a single boolean value
              indicating whether the bytes of two-byte and four-byte pixel
              indices and components are swapped before being written to
              memory. The initial value is _?_G_L___F_A_L_S_E. See ggll::ppiixxeellSSttoorreeff//22 .

              _?_G_L___P_I_X_E_L___P_A_C_K___B_U_F_F_E_R___B_I_N_D_I_N_G: _P_a_r_a_m_s returns a single value,
              the name of the buffer object currently bound to the target
              _?_G_L___P_I_X_E_L___P_A_C_K___B_U_F_F_E_R. If no buffer object is bound to this
              target, 0 is returned. The initial value is 0. See
              ggll::bbiinnddBBuuffffeerr//22 .

              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R___B_I_N_D_I_N_G: _P_a_r_a_m_s returns a single value,
              the name of the buffer object currently bound to the target
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R. If no buffer object is bound to this
              target, 0 is returned. The initial value is 0. See
              ggll::bbiinnddBBuuffffeerr//22 .

              _?_G_L___P_O_I_N_T___F_A_D_E___T_H_R_E_S_H_O_L_D___S_I_Z_E: _P_a_r_a_m_s returns one value, the
              point size threshold for determining the point size. See
              ggll::ppooiinnttPPaarraammeetteerrff//22 .

              _?_G_L___P_R_I_M_I_T_I_V_E___R_E_S_T_A_R_T___I_N_D_E_X: _P_a_r_a_m_s returns one value, the
              current primitive restart index. The initial value is 0. See
              ggll::pprriimmiittiivveeRReessttaarrttIInnddeexx//11 .

              _?_G_L___P_R_O_G_R_A_M___B_I_N_A_R_Y___F_O_R_M_A_T_S: _P_a_r_a_m_s an array of
              _?_G_L___N_U_M___P_R_O_G_R_A_M___B_I_N_A_R_Y___F_O_R_M_A_T_S values, indicating the proram
              binary formats supported by the implementation.

              _?_G_L___P_R_O_G_R_A_M___P_I_P_E_L_I_N_E___B_I_N_D_I_N_G: _P_a_r_a_m_s a single value, the name of
              the currently bound program pipeline object, or zero if no
              program pipeline object is bound. See ggll::bbiinnddPPrrooggrraammPPiippeelliinnee//11 .

              _?_G_L___P_R_O_V_O_K_I_N_G___V_E_R_T_E_X: _P_a_r_a_m_s returns one value, the currently
              selected provoking vertex convention. The initial value is
              _?_G_L___L_A_S_T___V_E_R_T_E_X___C_O_N_V_E_N_T_I_O_N. See ggll::pprroovvookkiinnggVVeerrtteexx//11 .

              _?_G_L___P_O_I_N_T___S_I_Z_E: _P_a_r_a_m_s returns one value, the point size as
              specified by ggll::ppooiinnttSSiizzee//11 . The initial value is 1.

              _?_G_L___P_O_I_N_T___S_I_Z_E___G_R_A_N_U_L_A_R_I_T_Y: _P_a_r_a_m_s returns one value, the size
              difference between adjacent supported sizes for antialiased
              points. See ggll::ppooiinnttSSiizzee//11 .

              _?_G_L___P_O_I_N_T___S_I_Z_E___R_A_N_G_E: _P_a_r_a_m_s returns two values: the smallest
              and largest supported sizes for antialiased points. The smallest
              size must be at most 1, and the largest size must be at least 1.
              See ggll::ppooiinnttSSiizzee//11 .

              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___F_A_C_T_O_R: _P_a_r_a_m_s returns one value, the scaling
              factor used to determine the variable offset that is added to
              the depth value of each fragment generated when a polygon is
              rasterized. The initial value is 0. See ggll::ppoollyyggoonnOOffffsseett//22 .

              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___U_N_I_T_S: _P_a_r_a_m_s returns one value. This value
              is multiplied by an implementation-specific value and then added
              to the depth value of each fragment generated when a polygon is
              rasterized. The initial value is 0. See ggll::ppoollyyggoonnOOffffsseett//22 .

              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___F_I_L_L: _P_a_r_a_m_s returns a single boolean value
              indicating whether polygon offset is enabled for polygons in
              fill mode. The initial value is _?_G_L___F_A_L_S_E . See
              ggll::ppoollyyggoonnOOffffsseett//22 .

              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___L_I_N_E: _P_a_r_a_m_s returns a single boolean value
              indicating whether polygon offset is enabled for polygons in
              line mode. The initial value is _?_G_L___F_A_L_S_E . See
              ggll::ppoollyyggoonnOOffffsseett//22 .

              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___P_O_I_N_T: _P_a_r_a_m_s returns a single boolean value
              indicating whether polygon offset is enabled for polygons in
              point mode. The initial value is _?_G_L___F_A_L_S_E . See
              ggll::ppoollyyggoonnOOffffsseett//22 .

              _?_G_L___P_O_L_Y_G_O_N___S_M_O_O_T_H: _P_a_r_a_m_s returns a single boolean value
              indicating whether antialiasing of polygons is enabled. The
              initial value is _?_G_L___F_A_L_S_E. See ggll::ppoollyyggoonnMMooddee//22 .

              _?_G_L___P_O_L_Y_G_O_N___S_M_O_O_T_H___H_I_N_T: _P_a_r_a_m_s returns one value, a symbolic
              constant indicating the mode of the polygon antialiasing hint.
              The initial value is _?_G_L___D_O_N_T___C_A_R_E. See ggll::hhiinntt//22 .

              _?_G_L___R_E_A_D___B_U_F_F_E_R: _P_a_r_a_m_s returns one value, a symbolic constant
              indicating which color buffer is selected for reading. The
              initial value is _?_G_L___B_A_C_K if there is a back buffer, otherwise
              it is _?_G_L___F_R_O_N_T. See ggll::rreeaaddPPiixxeellss//77 .

              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___B_I_N_D_I_N_G: _P_a_r_a_m_s returns a single value, the
              name of the renderbuffer object currently bound to the target
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R. If no renderbuffer object is bound to this
              target, 0 is returned. The initial value is 0. See
              ggll::bbiinnddRReennddeerrbbuuffffeerr//22 .

              _?_G_L___S_A_M_P_L_E___B_U_F_F_E_R_S: _P_a_r_a_m_s returns a single integer value
              indicating the number of sample buffers associated with the
              framebuffer. See ggll::ssaammpplleeCCoovveerraaggee//22 .

              _?_G_L___S_A_M_P_L_E___C_O_V_E_R_A_G_E___V_A_L_U_E: _P_a_r_a_m_s returns a single positive
              floating-point value indicating the current sample coverage
              value. See ggll::ssaammpplleeCCoovveerraaggee//22 .

              _?_G_L___S_A_M_P_L_E___C_O_V_E_R_A_G_E___I_N_V_E_R_T: _P_a_r_a_m_s returns a single boolean
              value indicating if the temporary coverage value should be
              inverted. See ggll::ssaammpplleeCCoovveerraaggee//22 .

              _?_G_L___S_A_M_P_L_E_R___B_I_N_D_I_N_G: _P_a_r_a_m_s returns a single value, the name of
              the sampler object currently bound to the active texture unit.
              The initial value is 0. See ggll::bbiinnddSSaammpplleerr//22 .

              _?_G_L___S_A_M_P_L_E_S: _P_a_r_a_m_s returns a single integer value indicating
              the coverage mask size. See ggll::ssaammpplleeCCoovveerraaggee//22 .

              _?_G_L___S_C_I_S_S_O_R___B_O_X: _P_a_r_a_m_s returns four values: the x and y window
              coordinates of the scissor box, followed by its width and
              height. Initially the x and y window coordinates are both 0 and
              the width and height are set to the size of the window. See
              ggll::sscciissssoorr//44 .

              _?_G_L___S_C_I_S_S_O_R___T_E_S_T: _P_a_r_a_m_s returns a single boolean value
              indicating whether scissoring is enabled. The initial value is
              _?_G_L___F_A_L_S_E. See ggll::sscciissssoorr//44 .

              _?_G_L___S_H_A_D_E_R___C_O_M_P_I_L_E_R: _P_a_r_a_m_s returns a single boolean value
              indicating whether an online shader compiler is present in the
              implementation. All desktop OpenGL implementations must support
              online shader compilations, and therefore the value of
              _?_G_L___S_H_A_D_E_R___C_O_M_P_I_L_E_R will always be _?_G_L___T_R_U_E.

              _?_G_L___S_M_O_O_T_H___L_I_N_E___W_I_D_T_H___R_A_N_G_E: _P_a_r_a_m_s returns a pair of values
              indicating the range of widths supported for smooth
              (antialiased) lines. See ggll::lliinneeWWiiddtthh//11 .

              _?_G_L___S_M_O_O_T_H___L_I_N_E___W_I_D_T_H___G_R_A_N_U_L_A_R_I_T_Y: _P_a_r_a_m_s returns a single value
              indicating the level of quantization applied to smooth line
              width parameters.

              _?_G_L___S_T_E_N_C_I_L___B_A_C_K___F_A_I_L: _P_a_r_a_m_s returns one value, a symbolic
              constant indicating what action is taken for back-facing
              polygons when the stencil test fails. The initial value is
              _?_G_L___K_E_E_P. See ggll::sstteenncciillOOppSSeeppaarraattee//44 .

              _?_G_L___S_T_E_N_C_I_L___B_A_C_K___F_U_N_C: _P_a_r_a_m_s returns one value, a symbolic
              constant indicating what function is used for back-facing
              polygons to compare the stencil reference value with the stencil
              buffer value. The initial value is _?_G_L___A_L_W_A_Y_S. See
              ggll::sstteenncciillFFuunnccSSeeppaarraattee//44 .

              _?_G_L___S_T_E_N_C_I_L___B_A_C_K___P_A_S_S___D_E_P_T_H___F_A_I_L: _P_a_r_a_m_s returns one value, a
              symbolic constant indicating what action is taken for back-
              facing polygons when the stencil test passes, but the depth test
              fails. The initial value is _?_G_L___K_E_E_P. See ggll::sstteenncciillOOppSSeeppaarraattee//44
              .

              _?_G_L___S_T_E_N_C_I_L___B_A_C_K___P_A_S_S___D_E_P_T_H___P_A_S_S: _P_a_r_a_m_s returns one value, a
              symbolic constant indicating what action is taken for back-
              facing polygons when the stencil test passes and the depth test
              passes. The initial value is _?_G_L___K_E_E_P. See
              ggll::sstteenncciillOOppSSeeppaarraattee//44 .

              _?_G_L___S_T_E_N_C_I_L___B_A_C_K___R_E_F: _P_a_r_a_m_s returns one value, the reference
              value that is compared with the contents of the stencil buffer
              for back-facing polygons. The initial value is 0. See
              ggll::sstteenncciillFFuunnccSSeeppaarraattee//44 .

              _?_G_L___S_T_E_N_C_I_L___B_A_C_K___V_A_L_U_E___M_A_S_K: _P_a_r_a_m_s returns one value, the mask
              that is used for back-facing polygons to mask both the stencil
              reference value and the stencil buffer value before they are
              compared. The initial value is all 1's. See
              ggll::sstteenncciillFFuunnccSSeeppaarraattee//44 .

              _?_G_L___S_T_E_N_C_I_L___B_A_C_K___W_R_I_T_E_M_A_S_K: _P_a_r_a_m_s returns one value, the mask
              that controls writing of the stencil bitplanes for back-facing
              polygons. The initial value is all 1's. See
              ggll::sstteenncciillMMaasskkSSeeppaarraattee//22 .

              _?_G_L___S_T_E_N_C_I_L___C_L_E_A_R___V_A_L_U_E: _P_a_r_a_m_s returns one value, the index to
              which the stencil bitplanes are cleared. The initial value is 0.
              See ggll::cclleeaarrSStteenncciill//11 .

              _?_G_L___S_T_E_N_C_I_L___F_A_I_L: _P_a_r_a_m_s returns one value, a symbolic constant
              indicating what action is taken when the stencil test fails. The
              initial value is _?_G_L___K_E_E_P. See ggll::sstteenncciillOOpp//33 . This stencil
              state only affects non-polygons and front-facing polygons. Back-
              facing polygons use separate stencil state. See
              ggll::sstteenncciillOOppSSeeppaarraattee//44 .

              _?_G_L___S_T_E_N_C_I_L___F_U_N_C: _P_a_r_a_m_s returns one value, a symbolic constant
              indicating what function is used to compare the stencil
              reference value with the stencil buffer value. The initial value
              is _?_G_L___A_L_W_A_Y_S. See ggll::sstteenncciillFFuunncc//33 . This stencil state only
              affects non-polygons and front-facing polygons. Back-facing
              polygons use separate stencil state. See
              ggll::sstteenncciillFFuunnccSSeeppaarraattee//44 .

              _?_G_L___S_T_E_N_C_I_L___P_A_S_S___D_E_P_T_H___F_A_I_L: _P_a_r_a_m_s returns one value, a
              symbolic constant indicating what action is taken when the
              stencil test passes, but the depth test fails. The initial value
              is _?_G_L___K_E_E_P. See ggll::sstteenncciillOOpp//33 . This stencil state only
              affects non-polygons and front-facing polygons. Back-facing
              polygons use separate stencil state. See ggll::sstteenncciillOOppSSeeppaarraattee//44
              .

              _?_G_L___S_T_E_N_C_I_L___P_A_S_S___D_E_P_T_H___P_A_S_S: _P_a_r_a_m_s returns one value, a
              symbolic constant indicating what action is taken when the
              stencil test passes and the depth test passes. The initial value
              is _?_G_L___K_E_E_P. See ggll::sstteenncciillOOpp//33 . This stencil state only
              affects non-polygons and front-facing polygons. Back-facing
              polygons use separate stencil state. See ggll::sstteenncciillOOppSSeeppaarraattee//44
              .

              _?_G_L___S_T_E_N_C_I_L___R_E_F: _P_a_r_a_m_s returns one value, the reference value
              that is compared with the contents of the stencil buffer. The
              initial value is 0. See ggll::sstteenncciillFFuunncc//33 . This stencil state
              only affects non-polygons and front-facing polygons. Back-facing
              polygons use separate stencil state. See
              ggll::sstteenncciillFFuunnccSSeeppaarraattee//44 .

              _?_G_L___S_T_E_N_C_I_L___T_E_S_T: _P_a_r_a_m_s returns a single boolean value
              indicating whether stencil testing of fragments is enabled. The
              initial value is _?_G_L___F_A_L_S_E. See ggll::sstteenncciillFFuunncc//33 and
              ggll::sstteenncciillOOpp//33 .

              _?_G_L___S_T_E_N_C_I_L___V_A_L_U_E___M_A_S_K: _P_a_r_a_m_s returns one value, the mask that
              is used to mask both the stencil reference value and the stencil
              buffer value before they are compared. The initial value is all
              1's. See ggll::sstteenncciillFFuunncc//33 . This stencil state only affects non-
              polygons and front-facing polygons. Back-facing polygons use
              separate stencil state. See ggll::sstteenncciillFFuunnccSSeeppaarraattee//44 .

              _?_G_L___S_T_E_N_C_I_L___W_R_I_T_E_M_A_S_K: _P_a_r_a_m_s returns one value, the mask that
              controls writing of the stencil bitplanes. The initial value is
              all 1's. See ggll::sstteenncciillMMaasskk//11 . This stencil state only affects
              non-polygons and front-facing polygons. Back-facing polygons use
              separate stencil state. See ggll::sstteenncciillMMaasskkSSeeppaarraattee//22 .

              _?_G_L___S_T_E_R_E_O: _P_a_r_a_m_s returns a single boolean value indicating
              whether stereo buffers (left and right) are supported.

              _?_G_L___S_U_B_P_I_X_E_L___B_I_T_S: _P_a_r_a_m_s returns one value, an estimate of the
              number of bits of subpixel resolution that are used to position
              rasterized geometry in window coordinates. The value must be at
              least 4.

              _?_G_L___T_E_X_T_U_R_E___B_I_N_D_I_N_G___1_D: _P_a_r_a_m_s returns a single value, the name
              of the texture currently bound to the target _?_G_L___T_E_X_T_U_R_E___1_D. The
              initial value is 0. See ggll::bbiinnddTTeexxttuurree//22 .

              _?_G_L___T_E_X_T_U_R_E___B_I_N_D_I_N_G___1_D___A_R_R_A_Y: _P_a_r_a_m_s returns a single value, the
              name of the texture currently bound to the target
              _?_G_L___T_E_X_T_U_R_E___1_D___A_R_R_A_Y. The initial value is 0. See
              ggll::bbiinnddTTeexxttuurree//22 .

              _?_G_L___T_E_X_T_U_R_E___B_I_N_D_I_N_G___2_D: _P_a_r_a_m_s returns a single value, the name
              of the texture currently bound to the target _?_G_L___T_E_X_T_U_R_E___2_D. The
              initial value is 0. See ggll::bbiinnddTTeexxttuurree//22 .

              _?_G_L___T_E_X_T_U_R_E___B_I_N_D_I_N_G___2_D___A_R_R_A_Y: _P_a_r_a_m_s returns a single value, the
              name of the texture currently bound to the target
              _?_G_L___T_E_X_T_U_R_E___2_D___A_R_R_A_Y. The initial value is 0. See
              ggll::bbiinnddTTeexxttuurree//22 .

              _?_G_L___T_E_X_T_U_R_E___B_I_N_D_I_N_G___2_D___M_U_L_T_I_S_A_M_P_L_E: _P_a_r_a_m_s returns a single
              value, the name of the texture currently bound to the target
              _?_G_L___T_E_X_T_U_R_E___2_D___M_U_L_T_I_S_A_M_P_L_E. The initial value is 0. See
              ggll::bbiinnddTTeexxttuurree//22 .

              _?_G_L___T_E_X_T_U_R_E___B_I_N_D_I_N_G___2_D___M_U_L_T_I_S_A_M_P_L_E___A_R_R_A_Y: _P_a_r_a_m_s returns a
              single value, the name of the texture currently bound to the
              target _?_G_L___T_E_X_T_U_R_E___2_D___M_U_L_T_I_S_A_M_P_L_E___A_R_R_A_Y . The initial value is
              0. See ggll::bbiinnddTTeexxttuurree//22 .

              _?_G_L___T_E_X_T_U_R_E___B_I_N_D_I_N_G___3_D: _P_a_r_a_m_s returns a single value, the name
              of the texture currently bound to the target _?_G_L___T_E_X_T_U_R_E___3_D. The
              initial value is 0. See ggll::bbiinnddTTeexxttuurree//22 .

              _?_G_L___T_E_X_T_U_R_E___B_I_N_D_I_N_G___B_U_F_F_E_R: _P_a_r_a_m_s returns a single value, the
              name of the texture currently bound to the target
              _?_G_L___T_E_X_T_U_R_E___B_U_F_F_E_R. The initial value is 0. See ggll::bbiinnddTTeexxttuurree//22
              .

              _?_G_L___T_E_X_T_U_R_E___B_I_N_D_I_N_G___C_U_B_E___M_A_P: _P_a_r_a_m_s returns a single value, the
              name of the texture currently bound to the target
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P. The initial value is 0. See
              ggll::bbiinnddTTeexxttuurree//22 .

              _?_G_L___T_E_X_T_U_R_E___B_I_N_D_I_N_G___R_E_C_T_A_N_G_L_E: _P_a_r_a_m_s returns a single value,
              the name of the texture currently bound to the target
              _?_G_L___T_E_X_T_U_R_E___R_E_C_T_A_N_G_L_E. The initial value is 0. See
              ggll::bbiinnddTTeexxttuurree//22 .

              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_R_E_S_S_I_O_N___H_I_N_T: _P_a_r_a_m_s returns a single value
              indicating the mode of the texture compression hint. The initial
              value is _?_G_L___D_O_N_T___C_A_R_E.

              _?_G_L___T_E_X_T_U_R_E___B_U_F_F_E_R___B_I_N_D_I_N_G: _P_a_r_a_m_s returns a single value, the
              name of the texture buffer object currently bound. The initial
              value is 0. See ggll::bbiinnddBBuuffffeerr//22 .

              _?_G_L___T_I_M_E_S_T_A_M_P: _P_a_r_a_m_s returns a single value, the 64-bit value
              of the current GL time. See ggll::qquueerryyCCoouunntteerr//22 .

              _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___B_U_F_F_E_R___B_I_N_D_I_N_G: When used with non-
              indexed variants of _g_l_:_g_e_t (such as _g_l_:_g_e_t_I_n_t_e_g_e_r_v), _P_a_r_a_m_s
              returns a single value, the name of the buffer object currently
              bound to the target _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___B_U_F_F_E_R. If no buffer
              object is bound to this target, 0 is returned. When used with
              indexed variants of _g_l_:_g_e_t (such as _g_l_:_g_e_t_I_n_t_e_g_e_r_i___v), _P_a_r_a_m_s
              returns a single value, the name of the buffer object bound to
              the indexed transform feedback attribute stream. The initial
              value is 0 for all targets. See ggll::bbiinnddBBuuffffeerr//22 ,
              ggll::bbiinnddBBuuffffeerrBBaassee//33 , and ggll::bbiinnddBBuuffffeerrRRaannggee//55 .

              _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___B_U_F_F_E_R___S_T_A_R_T: When used with indexed
              variants of _g_l_:_g_e_t (such as _g_l_:_g_e_t_I_n_t_e_g_e_r_6_4_i___v), _P_a_r_a_m_s returns
              a single value, the start offset of the binding range for each
              transform feedback attribute stream. The initial value is 0 for
              all streams. See ggll::bbiinnddBBuuffffeerrRRaannggee//55 .

              _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___B_U_F_F_E_R___S_I_Z_E: When used with indexed
              variants of _g_l_:_g_e_t (such as _g_l_:_g_e_t_I_n_t_e_g_e_r_6_4_i___v), _P_a_r_a_m_s returns
              a single value, the size of the binding range for each transform
              feedback attribute stream. The initial value is 0 for all
              streams. See ggll::bbiinnddBBuuffffeerrRRaannggee//55 .

              _?_G_L___U_N_I_F_O_R_M___B_U_F_F_E_R___B_I_N_D_I_N_G: When used with non-indexed variants
              of _g_l_:_g_e_t (such as _g_l_:_g_e_t_I_n_t_e_g_e_r_v), _P_a_r_a_m_s returns a single
              value, the name of the buffer object currently bound to the
              target _?_G_L___U_N_I_F_O_R_M___B_U_F_F_E_R. If no buffer object is bound to this
              target, 0 is returned. When used with indexed variants of _g_l_:_g_e_t
              (such as _g_l_:_g_e_t_I_n_t_e_g_e_r_i___v), _P_a_r_a_m_s returns a single value, the
              name of the buffer object bound to the indexed uniform buffer
              binding point. The initial value is 0 for all targets. See
              ggll::bbiinnddBBuuffffeerr//22 , ggll::bbiinnddBBuuffffeerrBBaassee//33 , and ggll::bbiinnddBBuuffffeerrRRaannggee//55
              .

              _?_G_L___U_N_I_F_O_R_M___B_U_F_F_E_R___O_F_F_S_E_T___A_L_I_G_N_M_E_N_T: _P_a_r_a_m_s returns a single
              value, the minimum required alignment for uniform buffer sizes
              and offset. The initial value is 1. See ggll::uunniiffoorrmmBBlloocckkBBiinnddiinngg//33
              .

              _?_G_L___U_N_I_F_O_R_M___B_U_F_F_E_R___S_I_Z_E: When used with indexed variants of
              _g_l_:_g_e_t (such as _g_l_:_g_e_t_I_n_t_e_g_e_r_6_4_i___v), _P_a_r_a_m_s returns a single
              value, the size of the binding range for each indexed uniform
              buffer binding. The initial value is 0 for all bindings. See
              ggll::bbiinnddBBuuffffeerrRRaannggee//55 .

              _?_G_L___U_N_I_F_O_R_M___B_U_F_F_E_R___S_T_A_R_T: When used with indexed variants of
              _g_l_:_g_e_t (such as _g_l_:_g_e_t_I_n_t_e_g_e_r_6_4_i___v), _P_a_r_a_m_s returns a single
              value, the start offset of the binding range for each indexed
              uniform buffer binding. The initial value is 0 for all bindings.
              See ggll::bbiinnddBBuuffffeerrRRaannggee//55 .

              _?_G_L___U_N_P_A_C_K___A_L_I_G_N_M_E_N_T: _P_a_r_a_m_s returns one value, the byte
              alignment used for reading pixel data from memory. The initial
              value is 4. See ggll::ppiixxeellSSttoorreeff//22 .

              _?_G_L___U_N_P_A_C_K___I_M_A_G_E___H_E_I_G_H_T: _P_a_r_a_m_s returns one value, the image
              height used for reading pixel data from memory. The initial is
              0. See ggll::ppiixxeellSSttoorreeff//22 .

              _?_G_L___U_N_P_A_C_K___L_S_B___F_I_R_S_T: _P_a_r_a_m_s returns a single boolean value
              indicating whether single-bit pixels being read from memory are
              read first from the least significant bit of each unsigned byte.
              The initial value is _?_G_L___F_A_L_S_E. See ggll::ppiixxeellSSttoorreeff//22 .

              _?_G_L___U_N_P_A_C_K___R_O_W___L_E_N_G_T_H: _P_a_r_a_m_s returns one value, the row length
              used for reading pixel data from memory. The initial value is 0.
              See ggll::ppiixxeellSSttoorreeff//22 .

              _?_G_L___U_N_P_A_C_K___S_K_I_P___I_M_A_G_E_S: _P_a_r_a_m_s returns one value, the number of
              pixel images skipped before the first pixel is read from memory.
              The initial value is 0. See ggll::ppiixxeellSSttoorreeff//22 .

              _?_G_L___U_N_P_A_C_K___S_K_I_P___P_I_X_E_L_S: _P_a_r_a_m_s returns one value, the number of
              pixel locations skipped before the first pixel is read from
              memory. The initial value is 0. See ggll::ppiixxeellSSttoorreeff//22 .

              _?_G_L___U_N_P_A_C_K___S_K_I_P___R_O_W_S: _P_a_r_a_m_s returns one value, the number of
              rows of pixel locations skipped before the first pixel is read
              from memory. The initial value is 0. See ggll::ppiixxeellSSttoorreeff//22 .

              _?_G_L___U_N_P_A_C_K___S_W_A_P___B_Y_T_E_S: _P_a_r_a_m_s returns a single boolean value
              indicating whether the bytes of two-byte and four-byte pixel
              indices and components are swapped after being read from memory.
              The initial value is _?_G_L___F_A_L_S_E. See ggll::ppiixxeellSSttoorreeff//22 .

              _?_G_L___V_E_R_T_E_X___P_R_O_G_R_A_M___P_O_I_N_T___S_I_Z_E: _P_a_r_a_m_s returns a single boolean
              value indicating whether vertex program point size mode is
              enabled. If enabled, and a vertex shader is active, then the
              point size is taken from the shader built-in gl_PointSize. If
              disabled, and a vertex shader is active, then the point size is
              taken from the point state as specified by ggll::ppooiinnttSSiizzee//11 . The
              initial value is _?_G_L___F_A_L_S_E.

              _?_G_L___V_I_E_W_P_O_R_T: When used with non-indexed variants of _g_l_:_g_e_t
              (such as _g_l_:_g_e_t_I_n_t_e_g_e_r_v ), _P_a_r_a_m_s returns four values: the x and
              y window coordinates of the viewport, followed by its width and
              height. Initially the x and y window coordinates are both set to
              0, and the width and height are set to the width and height of
              the window into which the GL will do its rendering. See
              ggll::vviieewwppoorrtt//44 . When used with indexed variants of _g_l_:_g_e_t (such
              as _g_l_:_g_e_t_I_n_t_e_g_e_r_i___v), _P_a_r_a_m_s returns four values: the x and y
              window coordinates of the indexed viewport, followed by its
              width and height. Initially the x and y window coordinates are
              both set to 0, and the width and height are set to the width and
              height of the window into which the GL will do its rendering.
              See ggll::vviieewwppoorrttIInnddeexxeeddff//55 .

              _?_G_L___V_I_E_W_P_O_R_T___B_O_U_N_D_S___R_A_N_G_E: _P_a_r_a_m_s returns two values, the
              minimum and maximum viewport bounds range. The minimum range
              should be at least [-32768, 32767].

              _?_G_L___V_I_E_W_P_O_R_T___I_N_D_E_X___P_R_O_V_O_K_I_N_G___V_E_R_T_E_X: _P_a_r_a_m_s returns one value,
              the implementation dependent specifc vertex of a primitive that
              is used to select the viewport index. If the value returned is
              equivalent to _?_G_L___P_R_O_V_O_K_I_N_G___V_E_R_T_E_X, then the vertex selection
              follows the convention specified by ggll::pprroovvookkiinnggVVeerrtteexx//11 . If
              the value returned is equivalent to _?_G_L___F_I_R_S_T___V_E_R_T_E_X___C_O_N_V_E_N_T_I_O_N,
              then the selection is always taken from the first vertex in the
              primitive. If the value returned is equivalent to
              _?_G_L___L_A_S_T___V_E_R_T_E_X___C_O_N_V_E_N_T_I_O_N , then the selection is always taken
              from the last vertex in the primitive. If the value returned is
              equivalent to _?_G_L___U_N_D_E_F_I_N_E_D___V_E_R_T_E_X, then the selection is not
              guaranteed to be taken from any specific vertex in the
              primitive.

              _?_G_L___V_I_E_W_P_O_R_T___S_U_B_P_I_X_E_L___B_I_T_S: _P_a_r_a_m_s returns a single value, the
              number of bits of sub-pixel precision which the GL uses to
              interpret the floating point viewport bounds. The minimum value
              is 0.

              Many of the boolean parameters can also be queried more easily
              using ggll::iissEEnnaabblleedd//11 .

              See external documentation.

       ggeettDDoouubblleevv((PPnnaammee)) -->> [[ffllooaatt(())]]

              Types:

                 Pname = enum()

              See ggeettBBoooolleeaannvv//11

       ggeettFFllooaattvv((PPnnaammee)) -->> [[ffllooaatt(())]]

              Types:

                 Pname = enum()

              See ggeettBBoooolleeaannvv//11

       ggeettIInntteeggeerrvv((PPnnaammee)) -->> [[iinntteeggeerr(())]]

              Types:

                 Pname = enum()

              See ggeettBBoooolleeaannvv//11

       ppuusshhAAttttrriibb((MMaasskk)) -->> ookk

              Types:

                 Mask = integer()

              Push and pop the server attribute stack

              _g_l_:_p_u_s_h_A_t_t_r_i_b takes one argument, a mask that indicates which
              groups of state variables to save on the attribute stack.
              Symbolic constants are used to set bits in the mask. _M_a_s_k is
              typically constructed by specifying the bitwise-or of several of
              these constants together. The special mask _?_G_L___A_L_L___A_T_T_R_I_B___B_I_T_S
              can be used to save all stackable states.

              The symbolic mask constants and their associated GL state are as
              follows (the second column lists which attributes are
              saved):_?_G_L___A_C_C_U_M___B_U_F_F_E_R___B_I_T Accumulation buffer clear value
              _?_G_L___C_O_L_O_R___B_U_F_F_E_R___B_I_T_?_G_L___A_L_P_H_A___T_E_S_T enable bit
               Alpha test function and reference value
              _?_G_L___B_L_E_N_D enable bit
               Blending source and destination functions
               Constant blend color
               Blending equation
              _?_G_L___D_I_T_H_E_R enable bit
              _?_G_L___D_R_A_W___B_U_F_F_E_R setting
              _?_G_L___C_O_L_O_R___L_O_G_I_C___O_P enable bit
              _?_G_L___I_N_D_E_X___L_O_G_I_C___O_P enable bit
               Logic op function
               Color mode and index mode clear values
               Color mode and index mode writemasks
              _?_G_L___C_U_R_R_E_N_T___B_I_T Current RGBA color
               Current color index
               Current normal vector
               Current texture coordinates
               Current raster position
              _?_G_L___C_U_R_R_E_N_T___R_A_S_T_E_R___P_O_S_I_T_I_O_N___V_A_L_I_D flag
               RGBA color associated with current raster position
               Color index associated with current raster position
               Texture coordinates associated with current raster position
              _?_G_L___E_D_G_E___F_L_A_G flag
              _?_G_L___D_E_P_T_H___B_U_F_F_E_R___B_I_T_?_G_L___D_E_P_T_H___T_E_S_T enable bit
               Depth buffer test function
               Depth buffer clear value
              _?_G_L___D_E_P_T_H___W_R_I_T_E_M_A_S_K enable bit
              _?_G_L___E_N_A_B_L_E___B_I_T_?_G_L___A_L_P_H_A___T_E_S_T flag
              _?_G_L___A_U_T_O___N_O_R_M_A_L flag
              _?_G_L___B_L_E_N_D flag
               Enable bits for the user-definable clipping planes
              _?_G_L___C_O_L_O_R___M_A_T_E_R_I_A_L
              _?_G_L___C_U_L_L___F_A_C_E flag
              _?_G_L___D_E_P_T_H___T_E_S_T flag
              _?_G_L___D_I_T_H_E_R flag
              _?_G_L___F_O_G flag
              _?_G_L___L_I_G_H_T_i where _?_0 <= _i < _?_G_L___M_A_X___L_I_G_H_T_S
              _?_G_L___L_I_G_H_T_I_N_G flag
              _?_G_L___L_I_N_E___S_M_O_O_T_H flag
              _?_G_L___L_I_N_E___S_T_I_P_P_L_E flag
              _?_G_L___C_O_L_O_R___L_O_G_I_C___O_P flag
              _?_G_L___I_N_D_E_X___L_O_G_I_C___O_P flag
              _?_G_L___M_A_P_1___x where _x is a map type
              _?_G_L___M_A_P_2___x where _x is a map type
              _?_G_L___M_U_L_T_I_S_A_M_P_L_E flag
              _?_G_L___N_O_R_M_A_L_I_Z_E flag
              _?_G_L___P_O_I_N_T___S_M_O_O_T_H flag
              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___L_I_N_E flag
              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___F_I_L_L flag
              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___P_O_I_N_T flag
              _?_G_L___P_O_L_Y_G_O_N___S_M_O_O_T_H flag
              _?_G_L___P_O_L_Y_G_O_N___S_T_I_P_P_L_E flag
              _?_G_L___S_A_M_P_L_E___A_L_P_H_A___T_O___C_O_V_E_R_A_G_E flag
              _?_G_L___S_A_M_P_L_E___A_L_P_H_A___T_O___O_N_E flag
              _?_G_L___S_A_M_P_L_E___C_O_V_E_R_A_G_E flag
              _?_G_L___S_C_I_S_S_O_R___T_E_S_T flag
              _?_G_L___S_T_E_N_C_I_L___T_E_S_T flag
              _?_G_L___T_E_X_T_U_R_E___1_D flag
              _?_G_L___T_E_X_T_U_R_E___2_D flag
              _?_G_L___T_E_X_T_U_R_E___3_D flag
               Flags _?_G_L___T_E_X_T_U_R_E___G_E_N___x where _x is S, T, R, or Q
              _?_G_L___E_V_A_L___B_I_T_?_G_L___M_A_P_1___x enable bits, where _x is a map type
              _?_G_L___M_A_P_2___x enable bits, where _x is a map type
               1D grid endpoints and divisions
               2D grid endpoints and divisions
              _?_G_L___A_U_T_O___N_O_R_M_A_L enable bit
              _?_G_L___F_O_G___B_I_T_?_G_L___F_O_G enable bit
               Fog color
               Fog density
               Linear fog start
               Linear fog end
               Fog index
              _?_G_L___F_O_G___M_O_D_E value
              _?_G_L___H_I_N_T___B_I_T_?_G_L___P_E_R_S_P_E_C_T_I_V_E___C_O_R_R_E_C_T_I_O_N___H_I_N_T setting
              _?_G_L___P_O_I_N_T___S_M_O_O_T_H___H_I_N_T setting
              _?_G_L___L_I_N_E___S_M_O_O_T_H___H_I_N_T setting
              _?_G_L___P_O_L_Y_G_O_N___S_M_O_O_T_H___H_I_N_T setting
              _?_G_L___F_O_G___H_I_N_T setting
              _?_G_L___G_E_N_E_R_A_T_E___M_I_P_M_A_P___H_I_N_T setting
              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_R_E_S_S_I_O_N___H_I_N_T setting
              _?_G_L___L_I_G_H_T_I_N_G___B_I_T_?_G_L___C_O_L_O_R___M_A_T_E_R_I_A_L enable bit
              _?_G_L___C_O_L_O_R___M_A_T_E_R_I_A_L___F_A_C_E value
               Color material parameters that are tracking the current color
               Ambient scene color
              _?_G_L___L_I_G_H_T___M_O_D_E_L___L_O_C_A_L___V_I_E_W_E_R value
              _?_G_L___L_I_G_H_T___M_O_D_E_L___T_W_O___S_I_D_E setting
              _?_G_L___L_I_G_H_T_I_N_G enable bit
               Enable bit for each light
               Ambient, diffuse, and specular intensity for each light
               Direction, position, exponent, and cutoff angle for each light
               Constant, linear, and quadratic attenuation factors for each
              light
               Ambient, diffuse, specular, and emissive color for each
              material
               Ambient, diffuse, and specular color indices for each material
               Specular exponent for each material
              _?_G_L___S_H_A_D_E___M_O_D_E_L setting
              _?_G_L___L_I_N_E___B_I_T_?_G_L___L_I_N_E___S_M_O_O_T_H flag
              _?_G_L___L_I_N_E___S_T_I_P_P_L_E enable bit
               Line stipple pattern and repeat counter
               Line width
              _?_G_L___L_I_S_T___B_I_T_?_G_L___L_I_S_T___B_A_S_E setting
              _?_G_L___M_U_L_T_I_S_A_M_P_L_E___B_I_T_?_G_L___M_U_L_T_I_S_A_M_P_L_E flag
              _?_G_L___S_A_M_P_L_E___A_L_P_H_A___T_O___C_O_V_E_R_A_G_E flag
              _?_G_L___S_A_M_P_L_E___A_L_P_H_A___T_O___O_N_E flag
              _?_G_L___S_A_M_P_L_E___C_O_V_E_R_A_G_E flag
              _?_G_L___S_A_M_P_L_E___C_O_V_E_R_A_G_E___V_A_L_U_E value
              _?_G_L___S_A_M_P_L_E___C_O_V_E_R_A_G_E___I_N_V_E_R_T value
              _?_G_L___P_I_X_E_L___M_O_D_E___B_I_T_?_G_L___R_E_D___B_I_A_S and _?_G_L___R_E_D___S_C_A_L_E settings
              _?_G_L___G_R_E_E_N___B_I_A_S and _?_G_L___G_R_E_E_N___S_C_A_L_E values
              _?_G_L___B_L_U_E___B_I_A_S and _?_G_L___B_L_U_E___S_C_A_L_E
              _?_G_L___A_L_P_H_A___B_I_A_S and _?_G_L___A_L_P_H_A___S_C_A_L_E
              _?_G_L___D_E_P_T_H___B_I_A_S and _?_G_L___D_E_P_T_H___S_C_A_L_E
              _?_G_L___I_N_D_E_X___O_F_F_S_E_T and _?_G_L___I_N_D_E_X___S_H_I_F_T values
              _?_G_L___M_A_P___C_O_L_O_R and _?_G_L___M_A_P___S_T_E_N_C_I_L flags
              _?_G_L___Z_O_O_M___X and _?_G_L___Z_O_O_M___Y factors
              _?_G_L___R_E_A_D___B_U_F_F_E_R setting
              _?_G_L___P_O_I_N_T___B_I_T_?_G_L___P_O_I_N_T___S_M_O_O_T_H flag
               Point size
              _?_G_L___P_O_L_Y_G_O_N___B_I_T_?_G_L___C_U_L_L___F_A_C_E enable bit
              _?_G_L___C_U_L_L___F_A_C_E___M_O_D_E value
              _?_G_L___F_R_O_N_T___F_A_C_E indicator
              _?_G_L___P_O_L_Y_G_O_N___M_O_D_E setting
              _?_G_L___P_O_L_Y_G_O_N___S_M_O_O_T_H flag
              _?_G_L___P_O_L_Y_G_O_N___S_T_I_P_P_L_E enable bit
              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___F_I_L_L flag
              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___L_I_N_E flag
              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___P_O_I_N_T flag
              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___F_A_C_T_O_R
              _?_G_L___P_O_L_Y_G_O_N___O_F_F_S_E_T___U_N_I_T_S
              _?_G_L___P_O_L_Y_G_O_N___S_T_I_P_P_L_E___B_I_T Polygon stipple image
              _?_G_L___S_C_I_S_S_O_R___B_I_T_?_G_L___S_C_I_S_S_O_R___T_E_S_T flag
               Scissor box
              _?_G_L___S_T_E_N_C_I_L___B_U_F_F_E_R___B_I_T_?_G_L___S_T_E_N_C_I_L___T_E_S_T enable bit
               Stencil function and reference value
               Stencil value mask
               Stencil fail, pass, and depth buffer pass actions
               Stencil buffer clear value
               Stencil buffer writemask
              _?_G_L___T_E_X_T_U_R_E___B_I_T Enable bits for the four texture coordinates
               Border color for each texture image
               Minification function for each texture image
               Magnification function for each texture image
               Texture coordinates and wrap mode for each texture image
               Color and mode for each texture environment
               Enable bits _?_G_L___T_E_X_T_U_R_E___G_E_N___x, _x is S, T, R, and Q
              _?_G_L___T_E_X_T_U_R_E___G_E_N___M_O_D_E setting for S, T, R, and Q
              ggll::tteexxGGeenndd//33 plane equations for S, T, R, and Q
               Current texture bindings (for example, _?_G_L___T_E_X_T_U_R_E___B_I_N_D_I_N_G___2_D)
              _?_G_L___T_R_A_N_S_F_O_R_M___B_I_T Coefficients of the six clipping planes
               Enable bits for the user-definable clipping planes
              _?_G_L___M_A_T_R_I_X___M_O_D_E value
              _?_G_L___N_O_R_M_A_L_I_Z_E flag
              _?_G_L___R_E_S_C_A_L_E___N_O_R_M_A_L flag
              _?_G_L___V_I_E_W_P_O_R_T___B_I_T Depth range (near and far)
               Viewport origin and extent


              ggll::ppuusshhAAttttrriibb//11 restores the values of the state variables saved
              with the last _g_l_:_p_u_s_h_A_t_t_r_i_b command. Those not saved are left
              unchanged.

              It is an error to push attributes onto a full stack or to pop
              attributes off an empty stack. In either case, the error flag is
              set and no other change is made to GL state.

              Initially, the attribute stack is empty.

              See external documentation.

       ppooppAAttttrriibb(()) -->> ookk

              See ppuusshhAAttttrriibb//11

       ppuusshhCClliieennttAAttttrriibb((MMaasskk)) -->> ookk

              Types:

                 Mask = integer()

              Push and pop the client attribute stack

              _g_l_:_p_u_s_h_C_l_i_e_n_t_A_t_t_r_i_b takes one argument, a mask that indicates
              which groups of client-state variables to save on the client
              attribute stack. Symbolic constants are used to set bits in the
              mask. _M_a_s_k is typically constructed by specifying the bitwise-or
              of several of these constants together. The special mask
              _?_G_L___C_L_I_E_N_T___A_L_L___A_T_T_R_I_B___B_I_T_S can be used to save all stackable
              client state.

              The symbolic mask constants and their associated GL client state
              are as follows (the second column lists which attributes are
              saved):

              _?_G_L___C_L_I_E_N_T___P_I_X_E_L___S_T_O_R_E___B_I_T Pixel storage modes
              _?_G_L___C_L_I_E_N_T___V_E_R_T_E_X___A_R_R_A_Y___B_I_T Vertex arrays (and enables)

              ggll::ppuusshhCClliieennttAAttttrriibb//11 restores the values of the client-state
              variables saved with the last _g_l_:_p_u_s_h_C_l_i_e_n_t_A_t_t_r_i_b. Those not
              saved are left unchanged.

              It is an error to push attributes onto a full client attribute
              stack or to pop attributes off an empty stack. In either case,
              the error flag is set, and no other change is made to GL state.

              Initially, the client attribute stack is empty.

              See external documentation.

       ppooppCClliieennttAAttttrriibb(()) -->> ookk

              See ppuusshhCClliieennttAAttttrriibb//11

       rreennddeerrMMooddee((MMooddee)) -->> iinntteeggeerr(())

              Types:

                 Mode = enum()

              Set rasterization mode

              _g_l_:_r_e_n_d_e_r_M_o_d_e sets the rasterization mode. It takes one
              argument, _M_o_d_e , which can assume one of three predefined
              values:

              _?_G_L___R_E_N_D_E_R: Render mode. Primitives are rasterized, producing
              pixel fragments, which are written into the frame buffer. This
              is the normal mode and also the default mode.

              _?_G_L___S_E_L_E_C_T: Selection mode. No pixel fragments are produced, and
              no change to the frame buffer contents is made. Instead, a
              record of the names of primitives that would have been drawn if
              the render mode had been _?_G_L___R_E_N_D_E_R is returned in a select
              buffer, which must be created (see ggll::sseelleeccttBBuuffffeerr//22 ) before
              selection mode is entered.

              _?_G_L___F_E_E_D_B_A_C_K: Feedback mode. No pixel fragments are produced,
              and no change to the frame buffer contents is made. Instead, the
              coordinates and attributes of vertices that would have been
              drawn if the render mode had been _?_G_L___R_E_N_D_E_R is returned in a
              feedback buffer, which must be created (see ggll::ffeeeeddbbaacckkBBuuffffeerr//33
              ) before feedback mode is entered.

              The return value of _g_l_:_r_e_n_d_e_r_M_o_d_e is determined by the render
              mode at the time _g_l_:_r_e_n_d_e_r_M_o_d_e is called, rather than by _M_o_d_e .
              The values returned for the three render modes are as follows:

              _?_G_L___R_E_N_D_E_R: 0.

              _?_G_L___S_E_L_E_C_T: The number of hit records transferred to the select
              buffer.

              _?_G_L___F_E_E_D_B_A_C_K: The number of values (not vertices) transferred to
              the feedback buffer.

              See the ggll::sseelleeccttBBuuffffeerr//22 and ggll::ffeeeeddbbaacckkBBuuffffeerr//33 reference
              pages for more details concerning selection and feedback
              operation.

              See external documentation.

       ggeettEErrrroorr(()) -->> eennuumm(())

              Return error information

              _g_l_:_g_e_t_E_r_r_o_r returns the value of the error flag. Each detectable
              error is assigned a numeric code and symbolic name. When an
              error occurs, the error flag is set to the appropriate error
              code value. No other errors are recorded until _g_l_:_g_e_t_E_r_r_o_r is
              called, the error code is returned, and the flag is reset to
              _?_G_L___N_O___E_R_R_O_R. If a call to _g_l_:_g_e_t_E_r_r_o_r returns _?_G_L___N_O___E_R_R_O_R,
              there has been no detectable error since the last call to
              _g_l_:_g_e_t_E_r_r_o_r , or since the GL was initialized.

              To allow for distributed implementations, there may be several
              error flags. If any single error flag has recorded an error, the
              value of that flag is returned and that flag is reset to
              _?_G_L___N_O___E_R_R_O_R when _g_l_:_g_e_t_E_r_r_o_r is called. If more than one flag
              has recorded an error, _g_l_:_g_e_t_E_r_r_o_r returns and clears an
              arbitrary error flag value. Thus, _g_l_:_g_e_t_E_r_r_o_r should always be
              called in a loop, until it returns _?_G_L___N_O___E_R_R_O_R , if all error
              flags are to be reset.

              Initially, all error flags are set to _?_G_L___N_O___E_R_R_O_R.

              The following errors are currently defined:

              _?_G_L___N_O___E_R_R_O_R: No error has been recorded. The value of this
              symbolic constant is guaranteed to be 0.

              _?_G_L___I_N_V_A_L_I_D___E_N_U_M: An unacceptable value is specified for an
              enumerated argument. The offending command is ignored and has no
              other side effect than to set the error flag.

              _?_G_L___I_N_V_A_L_I_D___V_A_L_U_E: A numeric argument is out of range. The
              offending command is ignored and has no other side effect than
              to set the error flag.

              _?_G_L___I_N_V_A_L_I_D___O_P_E_R_A_T_I_O_N: The specified operation is not allowed in
              the current state. The offending command is ignored and has no
              other side effect than to set the error flag.

              _?_G_L___I_N_V_A_L_I_D___F_R_A_M_E_B_U_F_F_E_R___O_P_E_R_A_T_I_O_N: The framebuffer object is not
              complete. The offending command is ignored and has no other side
              effect than to set the error flag.

              _?_G_L___O_U_T___O_F___M_E_M_O_R_Y: There is not enough memory left to execute
              the command. The state of the GL is undefined, except for the
              state of the error flags, after this error is recorded.

              When an error flag is set, results of a GL operation are
              undefined only if _?_G_L___O_U_T___O_F___M_E_M_O_R_Y has occurred. In all other
              cases, the command generating the error is ignored and has no
              effect on the GL state or frame buffer contents. If the
              generating command returns a value, it returns 0. If _g_l_:_g_e_t_E_r_r_o_r
              itself generates an error, it returns 0.

              See external documentation.

       ggeettSSttrriinngg((NNaammee)) -->> ssttrriinngg(())

              Types:

                 Name = enum()

              Return a string describing the current GL connection

              _g_l_:_g_e_t_S_t_r_i_n_g returns a pointer to a static string describing
              some aspect of the current GL connection. _N_a_m_e can be one of the
              following:

              _?_G_L___V_E_N_D_O_R: Returns the company responsible for this GL
              implementation. This name does not change from release to
              release.

              _?_G_L___R_E_N_D_E_R_E_R: Returns the name of the renderer. This name is
              typically specific to a particular configuration of a hardware
              platform. It does not change from release to release.

              _?_G_L___V_E_R_S_I_O_N: Returns a version or release number.

              _?_G_L___S_H_A_D_I_N_G___L_A_N_G_U_A_G_E___V_E_R_S_I_O_N: Returns a version or release
              number for the shading language.

              _g_l_:_g_e_t_S_t_r_i_n_g_i returns a pointer to a static string indexed by
              _I_n_d_e_x . _N_a_m_e can be one of the following:

              _?_G_L___E_X_T_E_N_S_I_O_N_S: For _g_l_:_g_e_t_S_t_r_i_n_g_i only, returns the extension
              string supported by the implementation at _I_n_d_e_x .

              Strings _?_G_L___V_E_N_D_O_R and _?_G_L___R_E_N_D_E_R_E_R together uniquely specify a
              platform. They do not change from release to release and should
              be used by platform-recognition algorithms.

              The _?_G_L___V_E_R_S_I_O_N and _?_G_L___S_H_A_D_I_N_G___L_A_N_G_U_A_G_E___V_E_R_S_I_O_N strings begin
              with a version number. The version number uses one of these
              forms:

              _m_a_j_o_r___n_u_m_b_e_r_._m_i_n_o_r___n_u_m_b_e_r_m_a_j_o_r___n_u_m_b_e_r_._m_i_n_o_r___n_u_m_b_e_r_._r_e_l_e_a_s_e___n_u_m_b_e_r

              Vendor-specific information may follow the version number. Its
              format depends on the implementation, but a space always
              separates the version number and the vendor-specific
              information.

              All strings are null-terminated.

              See external documentation.

       ffiinniisshh(()) -->> ookk

              Block until all GL execution is complete

              _g_l_:_f_i_n_i_s_h does not return until the effects of all previously
              called GL commands are complete. Such effects include all
              changes to GL state, all changes to connection state, and all
              changes to the frame buffer contents.

              See external documentation.

       fflluusshh(()) -->> ookk

              Force execution of GL commands in finite time

              Different GL implementations buffer commands in several
              different locations, including network buffers and the graphics
              accelerator itself. _g_l_:_f_l_u_s_h empties all of these buffers,
              causing all issued commands to be executed as quickly as they
              are accepted by the actual rendering engine. Though this
              execution may not be completed in any particular time period, it
              does complete in finite time.

              Because any GL program might be executed over a network, or on
              an accelerator that buffers commands, all programs should call
              _g_l_:_f_l_u_s_h whenever they count on having all of their previously
              issued commands completed. For example, call _g_l_:_f_l_u_s_h before
              waiting for user input that depends on the generated image.

              See external documentation.

       hhiinntt((TTaarrggeett,, MMooddee)) -->> ookk

              Types:

                 Target = enum()
                 Mode = enum()

              Specify implementation-specific hints

              Certain aspects of GL behavior, when there is room for
              interpretation, can be controlled with hints. A hint is
              specified with two arguments. _T_a_r_g_e_t is a symbolic constant
              indicating the behavior to be controlled, and _M_o_d_e is another
              symbolic constant indicating the desired behavior. The initial
              value for each _T_a_r_g_e_t is _?_G_L___D_O_N_T___C_A_R_E . _M_o_d_e can be one of the
              following:

              _?_G_L___F_A_S_T_E_S_T: The most efficient option should be chosen.

              _?_G_L___N_I_C_E_S_T: The most correct, or highest quality, option should
              be chosen.

              _?_G_L___D_O_N_T___C_A_R_E: No preference.

              Though the implementation aspects that can be hinted are well
              defined, the interpretation of the hints depends on the
              implementation. The hint aspects that can be specified with
              _T_a_r_g_e_t , along with suggested semantics, are as follows:

              _?_G_L___F_R_A_G_M_E_N_T___S_H_A_D_E_R___D_E_R_I_V_A_T_I_V_E___H_I_N_T: Indicates the accuracy of
              the derivative calculation for the GL shading language fragment
              processing built-in functions: _?_d_F_d_x , _?_d_F_d_y, and _?_f_w_i_d_t_h.

              _?_G_L___L_I_N_E___S_M_O_O_T_H___H_I_N_T: Indicates the sampling quality of
              antialiased lines. If a larger filter function is applied,
              hinting _?_G_L___N_I_C_E_S_T can result in more pixel fragments being
              generated during rasterization.

              _?_G_L___P_O_L_Y_G_O_N___S_M_O_O_T_H___H_I_N_T: Indicates the sampling quality of
              antialiased polygons. Hinting _?_G_L___N_I_C_E_S_T can result in more
              pixel fragments being generated during rasterization, if a
              larger filter function is applied.

              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_R_E_S_S_I_O_N___H_I_N_T: Indicates the quality and
              performance of the compressing texture images. Hinting
              _?_G_L___F_A_S_T_E_S_T indicates that texture images should be compressed
              as quickly as possible, while _?_G_L___N_I_C_E_S_T indicates that texture
              images should be compressed with as little image quality loss as
              possible. _?_G_L___N_I_C_E_S_T should be selected if the texture is to be
              retrieved by ggll::ggeettCCoommpprreesssseeddTTeexxIImmaaggee//33 for reuse.

              See external documentation.

       cclleeaarrDDeepptthh((DDeepptthh)) -->> ookk

              Types:

                 Depth = clamp()

              Specify the clear value for the depth buffer

              _g_l_:_c_l_e_a_r_D_e_p_t_h specifies the depth value used by ggll::cclleeaarr//11 to
              clear the depth buffer. Values specified by _g_l_:_c_l_e_a_r_D_e_p_t_h are
              clamped to the range [0 1].

              See external documentation.

       ddeepptthhFFuunncc((FFuunncc)) -->> ookk

              Types:

                 Func = enum()

              Specify the value used for depth buffer comparisons

              _g_l_:_d_e_p_t_h_F_u_n_c specifies the function used to compare each
              incoming pixel depth value with the depth value present in the
              depth buffer. The comparison is performed only if depth testing
              is enabled. (See ggll::eennaabbllee//11 and ggll::eennaabbllee//11 of _?_G_L___D_E_P_T_H___T_E_S_T
              .)

              _F_u_n_c specifies the conditions under which the pixel will be
              drawn. The comparison functions are as follows:

              _?_G_L___N_E_V_E_R: Never passes.

              _?_G_L___L_E_S_S: Passes if the incoming depth value is less than the
              stored depth value.

              _?_G_L___E_Q_U_A_L: Passes if the incoming depth value is equal to the
              stored depth value.

              _?_G_L___L_E_Q_U_A_L: Passes if the incoming depth value is less than or
              equal to the stored depth value.

              _?_G_L___G_R_E_A_T_E_R: Passes if the incoming depth value is greater than
              the stored depth value.

              _?_G_L___N_O_T_E_Q_U_A_L: Passes if the incoming depth value is not equal to
              the stored depth value.

              _?_G_L___G_E_Q_U_A_L: Passes if the incoming depth value is greater than
              or equal to the stored depth value.

              _?_G_L___A_L_W_A_Y_S: Always passes.

              The initial value of _F_u_n_c is _?_G_L___L_E_S_S. Initially, depth testing
              is disabled. If depth testing is disabled or if no depth buffer
              exists, it is as if the depth test always passes.

              See external documentation.

       ddeepptthhMMaasskk((FFllaagg)) -->> ookk

              Types:

                 Flag = 0 | 1

              Enable or disable writing into the depth buffer

              _g_l_:_d_e_p_t_h_M_a_s_k specifies whether the depth buffer is enabled for
              writing. If _F_l_a_g is _?_G_L___F_A_L_S_E, depth buffer writing is disabled.
              Otherwise, it is enabled. Initially, depth buffer writing is
              enabled.

              See external documentation.

       ddeepptthhRRaannggee((NNeeaarr__vvaall,, FFaarr__vvaall)) -->> ookk

              Types:

                 Near_val = clamp()
                 Far_val = clamp()

              Specify mapping of depth values from normalized device
              coordinates to window coordinates

              After clipping and division by _w, depth coordinates range from
              -1 to 1, corresponding to the near and far clipping planes.
              _g_l_:_d_e_p_t_h_R_a_n_g_e specifies a linear mapping of the normalized depth
              coordinates in this range to window depth coordinates.
              Regardless of the actual depth buffer implementation, window
              coordinate depth values are treated as though they range from 0
              through 1 (like color components). Thus, the values accepted by
              _g_l_:_d_e_p_t_h_R_a_n_g_e are both clamped to this range before they are
              accepted.

              The setting of (0,1) maps the near plane to 0 and the far plane
              to 1. With this mapping, the depth buffer range is fully
              utilized.

              See external documentation.

       cclleeaarrAAccccuumm((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)) -->> ookk

              Types:

                 Red = float()
                 Green = float()
                 Blue = float()
                 Alpha = float()

              Specify clear values for the accumulation buffer

              _g_l_:_c_l_e_a_r_A_c_c_u_m specifies the red, green, blue, and alpha values
              used by ggll::cclleeaarr//11 to clear the accumulation buffer.

              Values specified by _g_l_:_c_l_e_a_r_A_c_c_u_m are clamped to the range [-1
              1].

              See external documentation.

       aaccccuumm((OOpp,, VVaalluuee)) -->> ookk

              Types:

                 Op = enum()
                 Value = float()

              Operate on the accumulation buffer

              The accumulation buffer is an extended-range color buffer.
              Images are not rendered into it. Rather, images rendered into
              one of the color buffers are added to the contents of the
              accumulation buffer after rendering. Effects such as
              antialiasing (of points, lines, and polygons), motion blur, and
              depth of field can be created by accumulating images generated
              with different transformation matrices.

              Each pixel in the accumulation buffer consists of red, green,
              blue, and alpha values. The number of bits per component in the
              accumulation buffer depends on the implementation. You can
              examine this number by calling ggll::ggeettBBoooolleeaannvv//11 four times, with
              arguments _?_G_L___A_C_C_U_M___R_E_D___B_I_T_S, _?_G_L___A_C_C_U_M___G_R_E_E_N___B_I_T_S,
              _?_G_L___A_C_C_U_M___B_L_U_E___B_I_T_S, and _?_G_L___A_C_C_U_M___A_L_P_H_A___B_I_T_S . Regardless of
              the number of bits per component, the range of values stored by
              each component is [-1 1]. The accumulation buffer pixels are
              mapped one-to-one with frame buffer pixels.

              _g_l_:_a_c_c_u_m operates on the accumulation buffer. The first
              argument, _O_p , is a symbolic constant that selects an
              accumulation buffer operation. The second argument, _V_a_l_u_e , is a
              floating-point value to be used in that operation. Five
              operations are specified: _?_G_L___A_C_C_U_M , _?_G_L___L_O_A_D, _?_G_L___A_D_D,
              _?_G_L___M_U_L_T, and _?_G_L___R_E_T_U_R_N.

              All accumulation buffer operations are limited to the area of
              the current scissor box and applied identically to the red,
              green, blue, and alpha components of each pixel. If a _g_l_:_a_c_c_u_m
              operation results in a value outside the range [-1 1], the
              contents of an accumulation buffer pixel component are
              undefined.

              The operations are as follows:

              _?_G_L___A_C_C_U_M: Obtains R, G, B, and A values from the buffer
              currently selected for reading (see ggll::rreeaaddBBuuffffeerr//11 ). Each
              component value is divided by 2 n-1, where n is the number of
              bits allocated to each color component in the currently selected
              buffer. The result is a floating-point value in the range [0 1],
              which is multiplied by _V_a_l_u_e and added to the corresponding
              pixel component in the accumulation buffer, thereby updating the
              accumulation buffer.

              _?_G_L___L_O_A_D: Similar to _?_G_L___A_C_C_U_M, except that the current value in
              the accumulation buffer is not used in the calculation of the
              new value. That is, the R, G, B, and A values from the currently
              selected buffer are divided by 2 n-1, multiplied by _V_a_l_u_e , and
              then stored in the corresponding accumulation buffer cell,
              overwriting the current value.

              _?_G_L___A_D_D: Adds _V_a_l_u_e to each R, G, B, and A in the accumulation
              buffer.

              _?_G_L___M_U_L_T: Multiplies each R, G, B, and A in the accumulation
              buffer by _V_a_l_u_e and returns the scaled component to its
              corresponding accumulation buffer location.

              _?_G_L___R_E_T_U_R_N: Transfers accumulation buffer values to the color
              buffer or buffers currently selected for writing. Each R, G, B,
              and A component is multiplied by _V_a_l_u_e , then multiplied by 2
              n-1, clamped to the range [0 2 n-1], and stored in the
              corresponding display buffer cell. The only fragment operations
              that are applied to this transfer are pixel ownership, scissor,
              dithering, and color writemasks.

              To clear the accumulation buffer, call ggll::cclleeaarrAAccccuumm//44 with R,
              G, B, and A values to set it to, then call ggll::cclleeaarr//11 with the
              accumulation buffer enabled.

              See external documentation.

       mmaattrriixxMMooddee((MMooddee)) -->> ookk

              Types:

                 Mode = enum()

              Specify which matrix is the current matrix

              _g_l_:_m_a_t_r_i_x_M_o_d_e sets the current matrix mode. _M_o_d_e can assume one
              of four values:

              _?_G_L___M_O_D_E_L_V_I_E_W: Applies subsequent matrix operations to the
              modelview matrix stack.

              _?_G_L___P_R_O_J_E_C_T_I_O_N: Applies subsequent matrix operations to the
              projection matrix stack.

              _?_G_L___T_E_X_T_U_R_E: Applies subsequent matrix operations to the texture
              matrix stack.

              _?_G_L___C_O_L_O_R: Applies subsequent matrix operations to the color
              matrix stack.

              To find out which matrix stack is currently the target of all
              matrix operations, call ggll::ggeettBBoooolleeaannvv//11 with argument
              _?_G_L___M_A_T_R_I_X___M_O_D_E. The initial value is _?_G_L___M_O_D_E_L_V_I_E_W.

              See external documentation.

       oorrtthhoo((LLeefftt,, RRiigghhtt,, BBoottttoomm,, TToopp,, NNeeaarr__vvaall,, FFaarr__vvaall)) -->> ookk

              Types:

                 Left = float()
                 Right = float()
                 Bottom = float()
                 Top = float()
                 Near_val = float()
                 Far_val = float()

              Multiply the current matrix with an orthographic matrix

              _g_l_:_o_r_t_h_o describes a transformation that produces a parallel
              projection. The current matrix (see ggll::mmaattrriixxMMooddee//11 ) is
              multiplied by this matrix and the result replaces the current
              matrix, as if ggll::mmuullttMMaattrriixxdd//11 were called with the following
              matrix as its argument:

              ((2/(right-left)) 0 0(t x) 0(2/(top-bottom)) 0(t y) 0
              0(-2/(farVal-nearVal))(t z) 0 0 0 1)

              where t x=-((right+left)/(right-left)) t y=-((top+bottom)/(top-
              bottom)) t z=-((farVal+nearVal)/(farVal-nearVal))

              Typically, the matrix mode is _?_G_L___P_R_O_J_E_C_T_I_O_N, and (left bottom-
              nearVal) and (right top-nearVal) specify the points on the near
              clipping plane that are mapped to the lower left and upper right
              corners of the window, respectively, assuming that the eye is
              located at (0, 0, 0). -farVal specifies the location of the far
              clipping plane. Both _N_e_a_r_V_a_l and _F_a_r_V_a_l can be either positive
              or negative.

              Use ggll::ppuusshhMMaattrriixx//00 and ggll::ppuusshhMMaattrriixx//00 to save and restore the
              current matrix stack.

              See external documentation.

       ffrruussttuumm((LLeefftt,, RRiigghhtt,, BBoottttoomm,, TToopp,, NNeeaarr__vvaall,, FFaarr__vvaall)) -->> ookk

              Types:

                 Left = float()
                 Right = float()
                 Bottom = float()
                 Top = float()
                 Near_val = float()
                 Far_val = float()

              Multiply the current matrix by a perspective matrix

              _g_l_:_f_r_u_s_t_u_m describes a perspective matrix that produces a
              perspective projection. The current matrix (see ggll::mmaattrriixxMMooddee//11
              ) is multiplied by this matrix and the result replaces the
              current matrix, as if ggll::mmuullttMMaattrriixxdd//11 were called with the
              following matrix as its argument:

              [((2 nearVal)/(right-left)) 0 A 0 0((2 nearVal)/(top-bottom)) B
              0 0 0 C D 0 0 -1 0]

              A=(right+left)/(right-left)

              B=(top+bottom)/(top-bottom)

              C=-((farVal+nearVal)/(farVal-nearVal))

              D=-((2 farVal nearVal)/(farVal-nearVal))

              Typically, the matrix mode is _?_G_L___P_R_O_J_E_C_T_I_O_N, and (left bottom-
              nearVal) and (right top-nearVal) specify the points on the near
              clipping plane that are mapped to the lower left and upper right
              corners of the window, assuming that the eye is located at (0,
              0, 0). -farVal specifies the location of the far clipping plane.
              Both _N_e_a_r_V_a_l and _F_a_r_V_a_l must be positive.

              Use ggll::ppuusshhMMaattrriixx//00 and ggll::ppuusshhMMaattrriixx//00 to save and restore the
              current matrix stack.

              See external documentation.

       vviieewwppoorrtt((XX,, YY,, WWiiddtthh,, HHeeiigghhtt)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()
                 Width = integer()
                 Height = integer()

              Set the viewport

              _g_l_:_v_i_e_w_p_o_r_t specifies the affine transformation of x and y from
              normalized device coordinates to window coordinates. Let (x nd y
              nd) be normalized device coordinates. Then the window
              coordinates (x w y w) are computed as follows:

              x w=(x nd+1) (width/2)+x

              y w=(y nd+1) (height/2)+y

              Viewport width and height are silently clamped to a range that
              depends on the implementation. To query this range, call
              ggll::ggeettBBoooolleeaannvv//11 with argument _?_G_L___M_A_X___V_I_E_W_P_O_R_T___D_I_M_S.

              See external documentation.

       ppuusshhMMaattrriixx(()) -->> ookk

              Push and pop the current matrix stack

              There is a stack of matrices for each of the matrix modes. In
              _?_G_L___M_O_D_E_L_V_I_E_W mode, the stack depth is at least 32. In the other
              modes, _?_G_L___C_O_L_O_R, _?_G_L___P_R_O_J_E_C_T_I_O_N , and _?_G_L___T_E_X_T_U_R_E, the depth is
              at least 2. The current matrix in any mode is the matrix on the
              top of the stack for that mode.

              _g_l_:_p_u_s_h_M_a_t_r_i_x pushes the current matrix stack down by one,
              duplicating the current matrix. That is, after a _g_l_:_p_u_s_h_M_a_t_r_i_x
              call, the matrix on top of the stack is identical to the one
              below it.

              ggll::ppuusshhMMaattrriixx//00 pops the current matrix stack, replacing the
              current matrix with the one below it on the stack.

              Initially, each of the stacks contains one matrix, an identity
              matrix.

              It is an error to push a full matrix stack or to pop a matrix
              stack that contains only a single matrix. In either case, the
              error flag is set and no other change is made to GL state.

              See external documentation.

       ppooppMMaattrriixx(()) -->> ookk

              See ppuusshhMMaattrriixx//00

       llooaaddIIddeennttiittyy(()) -->> ookk

              Replace the current matrix with the identity matrix

              _g_l_:_l_o_a_d_I_d_e_n_t_i_t_y replaces the current matrix with the identity
              matrix. It is semantically equivalent to calling
              ggll::llooaaddMMaattrriixxdd//11 with the identity matrix

              ((1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1))

              but in some cases it is more efficient.

              See external documentation.

       llooaaddMMaattrriixxdd((MM)) -->> ookk

              Types:

                 M = matrix()

              Replace the current matrix with the specified matrix

              _g_l_:_l_o_a_d_M_a_t_r_i_x replaces the current matrix with the one whose
              elements are specified by _M . The current matrix is the
              projection matrix, modelview matrix, or texture matrix,
              depending on the current matrix mode (see ggll::mmaattrriixxMMooddee//11 ).

              The current matrix, M, defines a transformation of coordinates.
              For instance, assume M refers to the modelview matrix. If
              v=(v[0] v[1] v[2] v[3]) is the set of object coordinates of a
              vertex, and _M points to an array of 16 single- or double-
              precision floating-point values m={m[0] m[1] ... m[15]}, then
              the modelview transformation M(v) does the following:

              M(v)=(m[0] m[4] m[8] m[12] m[1] m[5] m[9] m[13] m[2] m[6] m[10]
              m[14] m[3] m[7] m[11] m[15])*(v[0] v[1] v[2] v[3])

              Projection and texture transformations are similarly defined.

              See external documentation.

       llooaaddMMaattrriixxff((MM)) -->> ookk

              Types:

                 M = matrix()

              See llooaaddMMaattrriixxdd//11

       mmuullttMMaattrriixxdd((MM)) -->> ookk

              Types:

                 M = matrix()

              Multiply the current matrix with the specified matrix

              _g_l_:_m_u_l_t_M_a_t_r_i_x multiplies the current matrix with the one
              specified using _M , and replaces the current matrix with the
              product.

              The current matrix is determined by the current matrix mode (see
              ggll::mmaattrriixxMMooddee//11 ). It is either the projection matrix, modelview
              matrix, or the texture matrix.

              See external documentation.

       mmuullttMMaattrriixxff((MM)) -->> ookk

              Types:

                 M = matrix()

              See mmuullttMMaattrriixxdd//11

       rroottaatteedd((AAnnggllee,, XX,, YY,, ZZ)) -->> ookk

              Types:

                 Angle = float()
                 X = float()
                 Y = float()
                 Z = float()

              Multiply the current matrix by a rotation matrix

              _g_l_:_r_o_t_a_t_e produces a rotation of _A_n_g_l_e degrees around the vector
              (x y z). The current matrix (see ggll::mmaattrriixxMMooddee//11 ) is multiplied
              by a rotation matrix with the product replacing the current
              matrix, as if ggll::mmuullttMMaattrriixxdd//11 were called with the following
              matrix as its argument:

              (x 2(1-c)+c x y(1-c)-z s x z(1-c)+y s 0 y x(1-c)+z s y 2(1-c)+c
              y z(1-c)-x s 0 x z(1-c)-y s y z(1-c)+x s z 2(1-c)+c 0 0 0 0 1)

              Where c= cos(angle), s= sin(angle), and ||(x y z)||= 1 (if not,
              the GL will normalize this vector).

              If the matrix mode is either _?_G_L___M_O_D_E_L_V_I_E_W or _?_G_L___P_R_O_J_E_C_T_I_O_N,
              all objects drawn after _g_l_:_r_o_t_a_t_e is called are rotated. Use
              ggll::ppuusshhMMaattrriixx//00 and ggll::ppuusshhMMaattrriixx//00 to save and restore the
              unrotated coordinate system.

              See external documentation.

       rroottaatteeff((AAnnggllee,, XX,, YY,, ZZ)) -->> ookk

              Types:

                 Angle = float()
                 X = float()
                 Y = float()
                 Z = float()

              See rroottaatteedd//44

       ssccaalleedd((XX,, YY,, ZZ)) -->> ookk

              Types:

                 X = float()
                 Y = float()
                 Z = float()

              Multiply the current matrix by a general scaling matrix

              _g_l_:_s_c_a_l_e produces a nonuniform scaling along the _x, _y, and _z
              axes. The three parameters indicate the desired scale factor
              along each of the three axes.

              The current matrix (see ggll::mmaattrriixxMMooddee//11 ) is multiplied by this
              scale matrix, and the product replaces the current matrix as if
              ggll::mmuullttMMaattrriixxdd//11 were called with the following matrix as its
              argument:

              (x 0 0 0 0 y 0 0 0 0 z 0 0 0 0 1)

              If the matrix mode is either _?_G_L___M_O_D_E_L_V_I_E_W or _?_G_L___P_R_O_J_E_C_T_I_O_N,
              all objects drawn after _g_l_:_s_c_a_l_e is called are scaled.

              Use ggll::ppuusshhMMaattrriixx//00 and ggll::ppuusshhMMaattrriixx//00 to save and restore the
              unscaled coordinate system.

              See external documentation.

       ssccaalleeff((XX,, YY,, ZZ)) -->> ookk

              Types:

                 X = float()
                 Y = float()
                 Z = float()

              See ssccaalleedd//33

       ttrraannssllaatteedd((XX,, YY,, ZZ)) -->> ookk

              Types:

                 X = float()
                 Y = float()
                 Z = float()

              Multiply the current matrix by a translation matrix

              _g_l_:_t_r_a_n_s_l_a_t_e produces a translation by (x y z). The current
              matrix (see ggll::mmaattrriixxMMooddee//11 ) is multiplied by this translation
              matrix, with the product replacing the current matrix, as if
              ggll::mmuullttMMaattrriixxdd//11 were called with the following matrix for its
              argument:

              (1 0 0 x 0 1 0 y 0 0 1 z 0 0 0 1)

              If the matrix mode is either _?_G_L___M_O_D_E_L_V_I_E_W or _?_G_L___P_R_O_J_E_C_T_I_O_N,
              all objects drawn after a call to _g_l_:_t_r_a_n_s_l_a_t_e are translated.

              Use ggll::ppuusshhMMaattrriixx//00 and ggll::ppuusshhMMaattrriixx//00 to save and restore the
              untranslated coordinate system.

              See external documentation.

       ttrraannssllaatteeff((XX,, YY,, ZZ)) -->> ookk

              Types:

                 X = float()
                 Y = float()
                 Z = float()

              See ttrraannssllaatteedd//33

       iissLLiisstt((LLiisstt)) -->> 00 || 11

              Types:

                 List = integer()

              Determine if a name corresponds to a display list

              _g_l_:_i_s_L_i_s_t returns _?_G_L___T_R_U_E if _L_i_s_t is the name of a display list
              and returns _?_G_L___F_A_L_S_E if it is not, or if an error occurs.

              A name returned by ggll::ggeennLLiissttss//11 , but not yet associated with a
              display list by calling ggll::nneewwLLiisstt//22 , is not the name of a
              display list.

              See external documentation.

       ddeelleetteeLLiissttss((LLiisstt,, RRaannggee)) -->> ookk

              Types:

                 List = integer()
                 Range = integer()

              Delete a contiguous group of display lists

              _g_l_:_d_e_l_e_t_e_L_i_s_t_s causes a contiguous group of display lists to be
              deleted. _L_i_s_t is the name of the first display list to be
              deleted, and _R_a_n_g_e is the number of display lists to delete. All
              display lists d with list<= d<= list+range-1 are deleted.

              All storage locations allocated to the specified display lists
              are freed, and the names are available for reuse at a later
              time. Names within the range that do not have an associated
              display list are ignored. If _R_a_n_g_e is 0, nothing happens.

              See external documentation.

       ggeennLLiissttss((RRaannggee)) -->> iinntteeggeerr(())

              Types:

                 Range = integer()

              Generate a contiguous set of empty display lists

              _g_l_:_g_e_n_L_i_s_t_s has one argument, _R_a_n_g_e . It returns an integer _n
              such that _R_a_n_g_e contiguous empty display lists, named n, n+1,
              ..., n+range-1, are created. If _R_a_n_g_e is 0, if there is no group
              of _R_a_n_g_e contiguous names available, or if any error is
              generated, no display lists are generated, and 0 is returned.

              See external documentation.

       nneewwLLiisstt((LLiisstt,, MMooddee)) -->> ookk

              Types:

                 List = integer()
                 Mode = enum()

              Create or replace a display list

              Display lists are groups of GL commands that have been stored
              for subsequent execution. Display lists are created with
              _g_l_:_n_e_w_L_i_s_t. All subsequent commands are placed in the display
              list, in the order issued, until ggll::eennddLLiisstt//00 is called.

              _g_l_:_n_e_w_L_i_s_t has two arguments. The first argument, _L_i_s_t , is a
              positive integer that becomes the unique name for the display
              list. Names can be created and reserved with ggll::ggeennLLiissttss//11 and
              tested for uniqueness with ggll::iissLLiisstt//11 . The second argument,
              _M_o_d_e , is a symbolic constant that can assume one of two values:

              _?_G_L___C_O_M_P_I_L_E: Commands are merely compiled.

              _?_G_L___C_O_M_P_I_L_E___A_N_D___E_X_E_C_U_T_E: Commands are executed as they are
              compiled into the display list.

              Certain commands are not compiled into the display list but are
              executed immediately, regardless of the display-list mode. These
              commands are ggll::aarreeTTeexxttuurreessRReessiiddeenntt//11 , ggll::ccoolloorrPPooiinntteerr//44 ,
              ggll::ddeelleetteeLLiissttss//22 , ggll::ddeelleetteeTTeexxttuurreess//11 , ggll::eennaabblleeCClliieennttSSttaattee//11
              , ggll::eeddggeeFFllaaggPPooiinntteerr//22 , ggll::eennaabblleeCClliieennttSSttaattee//11 ,
              ggll::ffeeeeddbbaacckkBBuuffffeerr//33 , ggll::ffiinniisshh//00 , ggll::fflluusshh//00 , ggll::ggeennLLiissttss//11 ,
              ggll::ggeennTTeexxttuurreess//11 , ggll::iinnddeexxPPooiinntteerr//33 , ggll::iinntteerrlleeaavveeddAArrrraayyss//33 ,
              ggll::iissEEnnaabblleedd//11 , ggll::iissLLiisstt//11 , ggll::iissTTeexxttuurree//11 ,
              ggll::nnoorrmmaallPPooiinntteerr//33 , ggll::ppuusshhCClliieennttAAttttrriibb//11 , ggll::ppiixxeellSSttoorreeff//22 ,
              ggll::ppuusshhCClliieennttAAttttrriibb//11 , ggll::rreeaaddPPiixxeellss//77 , ggll::rreennddeerrMMooddee//11 ,
              ggll::sseelleeccttBBuuffffeerr//22 , ggll::tteexxCCoooorrddPPooiinntteerr//44 , ggll::vveerrtteexxPPooiinntteerr//44 ,
              and all of the ggll::ggeettBBoooolleeaannvv//11 commands.

              Similarly, ggll::tteexxIImmaaggee11DD//88 , ggll::tteexxIImmaaggee22DD//99 , and
              ggll::tteexxIImmaaggee33DD//1100 are executed immediately and not compiled into
              the display list when their first argument is
              _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___1_D, _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___1_D, or
              _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___3_D , respectively.

              When the ARB_imaging extension is supported, ggll::hhiissttooggrraamm//44
              executes immediately when its argument is _?_G_L___P_R_O_X_Y___H_I_S_T_O_G_R_A_M.
              Similarly, ggll::ccoolloorrTTaabbllee//66 executes immediately when its first
              argument is _?_G_L___P_R_O_X_Y___C_O_L_O_R___T_A_B_L_E,
              _?_G_L___P_R_O_X_Y___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___C_O_L_O_R___T_A_B_L_E , or
              _?_G_L___P_R_O_X_Y___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___C_O_L_O_R___T_A_B_L_E.

              For OpenGL versions 1.3 and greater, or when the
              ARB_multitexture extension is supported,
              ggll::cclliieennttAAccttiivveeTTeexxttuurree//11 is not compiled into display lists, but
              executed immediately.

              When ggll::eennddLLiisstt//00 is encountered, the display-list definition is
              completed by associating the list with the unique name _L_i_s_t
              (specified in the _g_l_:_n_e_w_L_i_s_t command). If a display list with
              name _L_i_s_t already exists, it is replaced only when ggll::eennddLLiisstt//00
              is called.

              See external documentation.

       eennddLLiisstt(()) -->> ookk

              glBeginList

              See external documentation.

       ccaallllLLiisstt((LLiisstt)) -->> ookk

              Types:

                 List = integer()

              Execute a display list

              _g_l_:_c_a_l_l_L_i_s_t causes the named display list to be executed. The
              commands saved in the display list are executed in order, just
              as if they were called without using a display list. If _L_i_s_t has
              not been defined as a display list, _g_l_:_c_a_l_l_L_i_s_t is ignored.

              _g_l_:_c_a_l_l_L_i_s_t can appear inside a display list. To avoid the
              possibility of infinite recursion resulting from display lists
              calling one another, a limit is placed on the nesting level of
              display lists during display-list execution. This limit is at
              least 64, and it depends on the implementation.

              GL state is not saved and restored across a call to _g_l_:_c_a_l_l_L_i_s_t.
              Thus, changes made to GL state during the execution of a display
              list remain after execution of the display list is completed.
              Use ggll::ppuusshhAAttttrriibb//11 , ggll::ppuusshhAAttttrriibb//11 , ggll::ppuusshhMMaattrriixx//00 , and
              ggll::ppuusshhMMaattrriixx//00 to preserve GL state across _g_l_:_c_a_l_l_L_i_s_t calls.

              See external documentation.

       ccaallllLLiissttss((LLiissttss)) -->> ookk

              Types:

                 Lists = [integer()]

              Execute a list of display lists

              _g_l_:_c_a_l_l_L_i_s_t_s causes each display list in the list of names
              passed as _L_i_s_t_s to be executed. As a result, the commands saved
              in each display list are executed in order, just as if they were
              called without using a display list. Names of display lists that
              have not been defined are ignored.

              _g_l_:_c_a_l_l_L_i_s_t_s provides an efficient means for executing more than
              one display list. _T_y_p_e allows lists with various name formats to
              be accepted. The formats are as follows:

              _?_G_L___B_Y_T_E: _L_i_s_t_s is treated as an array of signed bytes, each in
              the range -128 through 127.

              _?_G_L___U_N_S_I_G_N_E_D___B_Y_T_E: _L_i_s_t_s is treated as an array of unsigned
              bytes, each in the range 0 through 255.

              _?_G_L___S_H_O_R_T: _L_i_s_t_s is treated as an array of signed two-byte
              integers, each in the range -32768 through 32767.

              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T: _L_i_s_t_s is treated as an array of unsigned
              two-byte integers, each in the range 0 through 65535.

              _?_G_L___I_N_T: _L_i_s_t_s is treated as an array of signed four-byte
              integers.

              _?_G_L___U_N_S_I_G_N_E_D___I_N_T: _L_i_s_t_s is treated as an array of unsigned four-
              byte integers.

              _?_G_L___F_L_O_A_T: _L_i_s_t_s is treated as an array of four-byte floating-
              point values.

              _?_G_L___2___B_Y_T_E_S: _L_i_s_t_s is treated as an array of unsigned bytes.
              Each pair of bytes specifies a single display-list name. The
              value of the pair is computed as 256 times the unsigned value of
              the first byte plus the unsigned value of the second byte.

              _?_G_L___3___B_Y_T_E_S: _L_i_s_t_s is treated as an array of unsigned bytes.
              Each triplet of bytes specifies a single display-list name. The
              value of the triplet is computed as 65536 times the unsigned
              value of the first byte, plus 256 times the unsigned value of
              the second byte, plus the unsigned value of the third byte.

              _?_G_L___4___B_Y_T_E_S: _L_i_s_t_s is treated as an array of unsigned bytes.
              Each quadruplet of bytes specifies a single display-list name.
              The value of the quadruplet is computed as 16777216 times the
              unsigned value of the first byte, plus 65536 times the unsigned
              value of the second byte, plus 256 times the unsigned value of
              the third byte, plus the unsigned value of the fourth byte.

              The list of display-list names is not null-terminated. Rather, _N
              specifies how many names are to be taken from _L_i_s_t_s .

              An additional level of indirection is made available with the
              ggll::lliissttBBaassee//11 command, which specifies an unsigned offset that
              is added to each display-list name specified in _L_i_s_t_s before
              that display list is executed.

              _g_l_:_c_a_l_l_L_i_s_t_s can appear inside a display list. To avoid the
              possibility of infinite recursion resulting from display lists
              calling one another, a limit is placed on the nesting level of
              display lists during display-list execution. This limit must be
              at least 64, and it depends on the implementation.

              GL state is not saved and restored across a call to
              _g_l_:_c_a_l_l_L_i_s_t_s. Thus, changes made to GL state during the
              execution of the display lists remain after execution is
              completed. Use ggll::ppuusshhAAttttrriibb//11 , ggll::ppuusshhAAttttrriibb//11 ,
              ggll::ppuusshhMMaattrriixx//00 , and ggll::ppuusshhMMaattrriixx//00 to preserve GL state
              across _g_l_:_c_a_l_l_L_i_s_t_s calls.

              See external documentation.

       lliissttBBaassee((BBaassee)) -->> ookk

              Types:

                 Base = integer()

              set the display-list base for

              ggll::ccaallllLLiissttss//11

              ggll::ccaallllLLiissttss//11 specifies an array of offsets. Display-list names
              are generated by adding _B_a_s_e to each offset. Names that
              reference valid display lists are executed; the others are
              ignored.

              See external documentation.

       bbeeggiinn((MMooddee)) -->> ookk

              Types:

                 Mode = enum()

              Delimit the vertices of a primitive or a group of like
              primitives

              _g_l_:_'_b_e_g_i_n' and ggll::''bbeeggiinn''//11 delimit the vertices that define a
              primitive or a group of like primitives. _g_l_:_'_b_e_g_i_n' accepts a
              single argument that specifies in which of ten ways the vertices
              are interpreted. Taking n as an integer count starting at one,
              and N as the total number of vertices specified, the
              interpretations are as follows:

              _?_G_L___P_O_I_N_T_S: Treats each vertex as a single point. Vertex n
              defines point n. N points are drawn.

              _?_G_L___L_I_N_E_S: Treats each pair of vertices as an independent line
              segment. Vertices 2 n-1 and 2 n define line n. N/2 lines are
              drawn.

              _?_G_L___L_I_N_E___S_T_R_I_P: Draws a connected group of line segments from
              the first vertex to the last. Vertices n and n+1 define line n.
              N-1 lines are drawn.

              _?_G_L___L_I_N_E___L_O_O_P: Draws a connected group of line segments from the
              first vertex to the last, then back to the first. Vertices n and
              n+1 define line n. The last line, however, is defined by
              vertices N and 1. N lines are drawn.

              _?_G_L___T_R_I_A_N_G_L_E_S: Treats each triplet of vertices as an independent
              triangle. Vertices 3 n-2, 3 n-1, and 3 n define triangle n. N/3
              triangles are drawn.

              _?_G_L___T_R_I_A_N_G_L_E___S_T_R_I_P: Draws a connected group of triangles. One
              triangle is defined for each vertex presented after the first
              two vertices. For odd n, vertices n, n+1, and n+2 define
              triangle n. For even n, vertices n+1, n, and n+2 define triangle
              n. N-2 triangles are drawn.

              _?_G_L___T_R_I_A_N_G_L_E___F_A_N: Draws a connected group of triangles. One
              triangle is defined for each vertex presented after the first
              two vertices. Vertices 1, n+1, and n+2 define triangle n. N-2
              triangles are drawn.

              _?_G_L___Q_U_A_D_S: Treats each group of four vertices as an independent
              quadrilateral. Vertices 4 n-3, 4 n-2, 4 n-1, and 4 n define
              quadrilateral n. N/4 quadrilaterals are drawn.

              _?_G_L___Q_U_A_D___S_T_R_I_P: Draws a connected group of quadrilaterals. One
              quadrilateral is defined for each pair of vertices presented
              after the first pair. Vertices 2 n-1, 2 n, 2 n+2, and 2 n+1
              define quadrilateral n. N/2-1 quadrilaterals are drawn. Note
              that the order in which vertices are used to construct a
              quadrilateral from strip data is different from that used with
              independent data.

              _?_G_L___P_O_L_Y_G_O_N: Draws a single, convex polygon. Vertices 1 through
              N define this polygon.

              Only a subset of GL commands can be used between _g_l_:_'_b_e_g_i_n' and
              ggll::''bbeeggiinn''//11 . The commands are ggll::vveerrtteexx22dd//22 , ggll::ccoolloorr33bb//33 ,
              ggll::sseeccoonnddaarryyCCoolloorr33bb//33 , ggll::iinnddeexxdd//11 , ggll::nnoorrmmaall33bb//33 ,
              ggll::ffooggCCoooorrddff//11 , ggll::tteexxCCoooorrdd11dd//11 , ggll::mmuullttiiTTeexxCCoooorrdd11dd//22 ,
              ggll::vveerrtteexxAAttttrriibb11dd//22 , ggll::eevvaallCCoooorrdd11dd//11 , ggll::eevvaallPPooiinntt11//11 ,
              ggll::aarrrraayyEElleemmeenntt//11 , ggll::mmaatteerriiaallff//33 , and ggll::eeddggeeFFllaagg//11 . Also,
              it is acceptable to use ggll::ccaallllLLiisstt//11 or ggll::ccaallllLLiissttss//11 to
              execute display lists that include only the preceding commands.
              If any other GL command is executed between _g_l_:_'_b_e_g_i_n' and
              ggll::''bbeeggiinn''//11 , the error flag is set and the command is ignored.

              Regardless of the value chosen for _M_o_d_e , there is no limit to
              the number of vertices that can be defined between _g_l_:_'_b_e_g_i_n'
              and ggll::''bbeeggiinn''//11 . Lines, triangles, quadrilaterals, and
              polygons that are incompletely specified are not drawn.
              Incomplete specification results when either too few vertices
              are provided to specify even a single primitive or when an
              incorrect multiple of vertices is specified. The incomplete
              primitive is ignored; the rest are drawn.

              The minimum specification of vertices for each primitive is as
              follows: 1 for a point, 2 for a line, 3 for a triangle, 4 for a
              quadrilateral, and 3 for a polygon. Modes that require a certain
              multiple of vertices are _?_G_L___L_I_N_E_S (2), _?_G_L___T_R_I_A_N_G_L_E_S (3),
              _?_G_L___Q_U_A_D_S (4), and _?_G_L___Q_U_A_D___S_T_R_I_P (2).

              See external documentation.

       eenndd(()) -->> ookk

              See ''bbeeggiinn''//11

       vveerrtteexx22dd((XX,, YY)) -->> ookk

              Types:

                 X = float()
                 Y = float()

              Specify a vertex

              _g_l_:_v_e_r_t_e_x commands are used within ggll::''bbeeggiinn''//11 / ggll::''bbeeggiinn''//11
              pairs to specify point, line, and polygon vertices. The current
              color, normal, texture coordinates, and fog coordinate are
              associated with the vertex when _g_l_:_v_e_r_t_e_x is called.

              When only x and y are specified, z defaults to 0 and w defaults
              to 1. When x, y, and z are specified, w defaults to 1.

              See external documentation.

       vveerrtteexx22ff((XX,, YY)) -->> ookk

              Types:

                 X = float()
                 Y = float()

              See vveerrtteexx22dd//22

       vveerrtteexx22ii((XX,, YY)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()

              See vveerrtteexx22dd//22

       vveerrtteexx22ss((XX,, YY)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()

              See vveerrtteexx22dd//22

       vveerrtteexx33dd((XX,, YY,, ZZ)) -->> ookk

              Types:

                 X = float()
                 Y = float()
                 Z = float()

              See vveerrtteexx22dd//22

       vveerrtteexx33ff((XX,, YY,, ZZ)) -->> ookk

              Types:

                 X = float()
                 Y = float()
                 Z = float()

              See vveerrtteexx22dd//22

       vveerrtteexx33ii((XX,, YY,, ZZ)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()
                 Z = integer()

              See vveerrtteexx22dd//22

       vveerrtteexx33ss((XX,, YY,, ZZ)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()
                 Z = integer()

              See vveerrtteexx22dd//22

       vveerrtteexx44dd((XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 X = float()
                 Y = float()
                 Z = float()
                 W = float()

              See vveerrtteexx22dd//22

       vveerrtteexx44ff((XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 X = float()
                 Y = float()
                 Z = float()
                 W = float()

              See vveerrtteexx22dd//22

       vveerrtteexx44ii((XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()
                 Z = integer()
                 W = integer()

              See vveerrtteexx22dd//22

       vveerrtteexx44ss((XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()
                 Z = integer()
                 W = integer()

              See vveerrtteexx22dd//22

       vveerrtteexx22ddvv((VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float()}

              Equivalent to vveerrtteexx22dd((XX,, YY)).

       vveerrtteexx22ffvv((VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float()}

              Equivalent to vveerrtteexx22ff((XX,, YY)).

       vveerrtteexx22iivv((VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer()}

              Equivalent to vveerrtteexx22ii((XX,, YY)).

       vveerrtteexx22ssvv((VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer()}

              Equivalent to vveerrtteexx22ss((XX,, YY)).

       vveerrtteexx33ddvv((VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float(), Z::float()}

              Equivalent to vveerrtteexx33dd((XX,, YY,, ZZ)).

       vveerrtteexx33ffvv((VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float(), Z::float()}

              Equivalent to vveerrtteexx33ff((XX,, YY,, ZZ)).

       vveerrtteexx33iivv((VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer()}

              Equivalent to vveerrtteexx33ii((XX,, YY,, ZZ)).

       vveerrtteexx33ssvv((VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer()}

              Equivalent to vveerrtteexx33ss((XX,, YY,, ZZ)).

       vveerrtteexx44ddvv((VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float(), Z::float(), W::float()}

              Equivalent to vveerrtteexx44dd((XX,, YY,, ZZ,, WW)).

       vveerrtteexx44ffvv((VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float(), Z::float(), W::float()}

              Equivalent to vveerrtteexx44ff((XX,, YY,, ZZ,, WW)).

       vveerrtteexx44iivv((VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer(), W::integer()}

              Equivalent to vveerrtteexx44ii((XX,, YY,, ZZ,, WW)).

       vveerrtteexx44ssvv((VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer(), W::integer()}

              Equivalent to vveerrtteexx44ss((XX,, YY,, ZZ,, WW)).

       nnoorrmmaall33bb((NNxx,, NNyy,, NNzz)) -->> ookk

              Types:

                 Nx = integer()
                 Ny = integer()
                 Nz = integer()

              Set the current normal vector

              The current normal is set to the given coordinates whenever
              _g_l_:_n_o_r_m_a_l is issued. Byte, short, or integer arguments are
              converted to floating-point format with a linear mapping that
              maps the most positive representable integer value to 1.0 and
              the most negative representable integer value to -1.0.

              Normals specified with _g_l_:_n_o_r_m_a_l need not have unit length. If
              _?_G_L___N_O_R_M_A_L_I_Z_E is enabled, then normals of any length specified
              with _g_l_:_n_o_r_m_a_l are normalized after transformation. If
              _?_G_L___R_E_S_C_A_L_E___N_O_R_M_A_L is enabled, normals are scaled by a scaling
              factor derived from the modelview matrix. _?_G_L___R_E_S_C_A_L_E___N_O_R_M_A_L
              requires that the originally specified normals were of unit
              length, and that the modelview matrix contain only uniform
              scales for proper results. To enable and disable normalization,
              call ggll::eennaabbllee//11 and ggll::eennaabbllee//11 with either _?_G_L___N_O_R_M_A_L_I_Z_E or
              _?_G_L___R_E_S_C_A_L_E___N_O_R_M_A_L. Normalization is initially disabled.

              See external documentation.

       nnoorrmmaall33dd((NNxx,, NNyy,, NNzz)) -->> ookk

              Types:

                 Nx = float()
                 Ny = float()
                 Nz = float()

              See nnoorrmmaall33bb//33

       nnoorrmmaall33ff((NNxx,, NNyy,, NNzz)) -->> ookk

              Types:

                 Nx = float()
                 Ny = float()
                 Nz = float()

              See nnoorrmmaall33bb//33

       nnoorrmmaall33ii((NNxx,, NNyy,, NNzz)) -->> ookk

              Types:

                 Nx = integer()
                 Ny = integer()
                 Nz = integer()

              See nnoorrmmaall33bb//33

       nnoorrmmaall33ss((NNxx,, NNyy,, NNzz)) -->> ookk

              Types:

                 Nx = integer()
                 Ny = integer()
                 Nz = integer()

              See nnoorrmmaall33bb//33

       nnoorrmmaall33bbvv((VV)) -->> ookk

              Types:

                 V = {Nx::integer(), Ny::integer(), Nz::integer()}

              Equivalent to nnoorrmmaall33bb((NNxx,, NNyy,, NNzz)).

       nnoorrmmaall33ddvv((VV)) -->> ookk

              Types:

                 V = {Nx::float(), Ny::float(), Nz::float()}

              Equivalent to nnoorrmmaall33dd((NNxx,, NNyy,, NNzz)).

       nnoorrmmaall33ffvv((VV)) -->> ookk

              Types:

                 V = {Nx::float(), Ny::float(), Nz::float()}

              Equivalent to nnoorrmmaall33ff((NNxx,, NNyy,, NNzz)).

       nnoorrmmaall33iivv((VV)) -->> ookk

              Types:

                 V = {Nx::integer(), Ny::integer(), Nz::integer()}

              Equivalent to nnoorrmmaall33ii((NNxx,, NNyy,, NNzz)).

       nnoorrmmaall33ssvv((VV)) -->> ookk

              Types:

                 V = {Nx::integer(), Ny::integer(), Nz::integer()}

              Equivalent to nnoorrmmaall33ss((NNxx,, NNyy,, NNzz)).

       iinnddeexxdd((CC)) -->> ookk

              Types:

                 C = float()

              Set the current color index

              _g_l_:_i_n_d_e_x updates the current (single-valued) color index. It
              takes one argument, the new value for the current color index.

              The current index is stored as a floating-point value. Integer
              values are converted directly to floating-point values, with no
              special mapping. The initial value is 1.

              Index values outside the representable range of the color index
              buffer are not clamped. However, before an index is dithered (if
              enabled) and written to the frame buffer, it is converted to
              fixed-point format. Any bits in the integer portion of the
              resulting fixed-point value that do not correspond to bits in
              the frame buffer are masked out.

              See external documentation.

       iinnddeexxff((CC)) -->> ookk

              Types:

                 C = float()

              See iinnddeexxdd//11

       iinnddeexxii((CC)) -->> ookk

              Types:

                 C = integer()

              See iinnddeexxdd//11

       iinnddeexxss((CC)) -->> ookk

              Types:

                 C = integer()

              See iinnddeexxdd//11

       iinnddeexxuubb((CC)) -->> ookk

              Types:

                 C = integer()

              See iinnddeexxdd//11

       iinnddeexxddvv((CC)) -->> ookk

              Types:

                 C = {C::float()}

              Equivalent to iinnddeexxdd((CC)).

       iinnddeexxffvv((CC)) -->> ookk

              Types:

                 C = {C::float()}

              Equivalent to iinnddeexxff((CC)).

       iinnddeexxiivv((CC)) -->> ookk

              Types:

                 C = {C::integer()}

              Equivalent to iinnddeexxii((CC)).

       iinnddeexxssvv((CC)) -->> ookk

              Types:

                 C = {C::integer()}

              Equivalent to iinnddeexxss((CC)).

       iinnddeexxuubbvv((CC)) -->> ookk

              Types:

                 C = {C::integer()}

              Equivalent to iinnddeexxuubb((CC)).

       ccoolloorr33bb((RReedd,, GGrreeeenn,, BBlluuee)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()

              Set the current color

              The GL stores both a current single-valued color index and a
              current four-valued RGBA color. _g_l_:_c_o_l_o_r sets a new four-valued
              RGBA color. _g_l_:_c_o_l_o_r has two major variants: _g_l_:_c_o_l_o_r_3 and
              _g_l_:_c_o_l_o_r_4. _g_l_:_c_o_l_o_r_3 variants specify new red, green, and blue
              values explicitly and set the current alpha value to 1.0 (full
              intensity) implicitly. _g_l_:_c_o_l_o_r_4 variants specify all four color
              components explicitly.

              _g_l_:_c_o_l_o_r_3_b, _g_l_:_c_o_l_o_r_4_b, _g_l_:_c_o_l_o_r_3_s, _g_l_:_c_o_l_o_r_4_s, _g_l_:_c_o_l_o_r_3_i, and
              _g_l_:_c_o_l_o_r_4_i take three or four signed byte, short, or long
              integers as arguments. When _v is appended to the name, the color
              commands can take a pointer to an array of such values.

              Current color values are stored in floating-point format, with
              unspecified mantissa and exponent sizes. Unsigned integer color
              components, when specified, are linearly mapped to floating-
              point values such that the largest representable value maps to
              1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed
              integer color components, when specified, are linearly mapped to
              floating-point values such that the most positive representable
              value maps to 1.0, and the most negative representable value
              maps to -1.0. (Note that this mapping does not convert 0
              precisely to 0.0.) Floating-point values are mapped directly.

              Neither floating-point nor signed integer values are clamped to
              the range [0 1] before the current color is updated. However,
              color components are clamped to this range before they are
              interpolated or written into a color buffer.

              See external documentation.

       ccoolloorr33dd((RReedd,, GGrreeeenn,, BBlluuee)) -->> ookk

              Types:

                 Red = float()
                 Green = float()
                 Blue = float()

              See ccoolloorr33bb//33

       ccoolloorr33ff((RReedd,, GGrreeeenn,, BBlluuee)) -->> ookk

              Types:

                 Red = float()
                 Green = float()
                 Blue = float()

              See ccoolloorr33bb//33

       ccoolloorr33ii((RReedd,, GGrreeeenn,, BBlluuee)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()

              See ccoolloorr33bb//33

       ccoolloorr33ss((RReedd,, GGrreeeenn,, BBlluuee)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()

              See ccoolloorr33bb//33

       ccoolloorr33uubb((RReedd,, GGrreeeenn,, BBlluuee)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()

              See ccoolloorr33bb//33

       ccoolloorr33uuii((RReedd,, GGrreeeenn,, BBlluuee)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()

              See ccoolloorr33bb//33

       ccoolloorr33uuss((RReedd,, GGrreeeenn,, BBlluuee)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()

              See ccoolloorr33bb//33

       ccoolloorr44bb((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()
                 Alpha = integer()

              See ccoolloorr33bb//33

       ccoolloorr44dd((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)) -->> ookk

              Types:

                 Red = float()
                 Green = float()
                 Blue = float()
                 Alpha = float()

              See ccoolloorr33bb//33

       ccoolloorr44ff((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)) -->> ookk

              Types:

                 Red = float()
                 Green = float()
                 Blue = float()
                 Alpha = float()

              See ccoolloorr33bb//33

       ccoolloorr44ii((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()
                 Alpha = integer()

              See ccoolloorr33bb//33

       ccoolloorr44ss((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()
                 Alpha = integer()

              See ccoolloorr33bb//33

       ccoolloorr44uubb((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()
                 Alpha = integer()

              See ccoolloorr33bb//33

       ccoolloorr44uuii((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()
                 Alpha = integer()

              See ccoolloorr33bb//33

       ccoolloorr44uuss((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()
                 Alpha = integer()

              See ccoolloorr33bb//33

       ccoolloorr33bbvv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer()}

              Equivalent to ccoolloorr33bb((RReedd,, GGrreeeenn,, BBlluuee)).

       ccoolloorr33ddvv((VV)) -->> ookk

              Types:

                 V = {Red::float(), Green::float(), Blue::float()}

              Equivalent to ccoolloorr33dd((RReedd,, GGrreeeenn,, BBlluuee)).

       ccoolloorr33ffvv((VV)) -->> ookk

              Types:

                 V = {Red::float(), Green::float(), Blue::float()}

              Equivalent to ccoolloorr33ff((RReedd,, GGrreeeenn,, BBlluuee)).

       ccoolloorr33iivv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer()}

              Equivalent to ccoolloorr33ii((RReedd,, GGrreeeenn,, BBlluuee)).

       ccoolloorr33ssvv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer()}

              Equivalent to ccoolloorr33ss((RReedd,, GGrreeeenn,, BBlluuee)).

       ccoolloorr33uubbvv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer()}

              Equivalent to ccoolloorr33uubb((RReedd,, GGrreeeenn,, BBlluuee)).

       ccoolloorr33uuiivv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer()}

              Equivalent to ccoolloorr33uuii((RReedd,, GGrreeeenn,, BBlluuee)).

       ccoolloorr33uussvv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer()}

              Equivalent to ccoolloorr33uuss((RReedd,, GGrreeeenn,, BBlluuee)).

       ccoolloorr44bbvv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer(),
                 Alpha::integer()}

              Equivalent to ccoolloorr44bb((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)).

       ccoolloorr44ddvv((VV)) -->> ookk

              Types:

                 V = {Red::float(), Green::float(), Blue::float(),
                 Alpha::float()}

              Equivalent to ccoolloorr44dd((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)).

       ccoolloorr44ffvv((VV)) -->> ookk

              Types:

                 V = {Red::float(), Green::float(), Blue::float(),
                 Alpha::float()}

              Equivalent to ccoolloorr44ff((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)).

       ccoolloorr44iivv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer(),
                 Alpha::integer()}

              Equivalent to ccoolloorr44ii((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)).

       ccoolloorr44ssvv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer(),
                 Alpha::integer()}

              Equivalent to ccoolloorr44ss((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)).

       ccoolloorr44uubbvv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer(),
                 Alpha::integer()}

              Equivalent to ccoolloorr44uubb((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)).

       ccoolloorr44uuiivv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer(),
                 Alpha::integer()}

              Equivalent to ccoolloorr44uuii((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)).

       ccoolloorr44uussvv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer(),
                 Alpha::integer()}

              Equivalent to ccoolloorr44uuss((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)).

       tteexxCCoooorrdd11dd((SS)) -->> ookk

              Types:

                 S = float()

              Set the current texture coordinates

              _g_l_:_t_e_x_C_o_o_r_d specifies texture coordinates in one, two, three, or
              four dimensions. _g_l_:_t_e_x_C_o_o_r_d_1 sets the current texture
              coordinates to (s 0 0 1); a call to _g_l_:_t_e_x_C_o_o_r_d_2 sets them to (s
              t 0 1). Similarly, _g_l_:_t_e_x_C_o_o_r_d_3 specifies the texture
              coordinates as (s t r 1), and _g_l_:_t_e_x_C_o_o_r_d_4 defines all four
              components explicitly as (s t r q).

              The current texture coordinates are part of the data that is
              associated with each vertex and with the current raster
              position. Initially, the values for _s, _t, _r , and _q are (0, 0,
              0, 1).

              See external documentation.

       tteexxCCoooorrdd11ff((SS)) -->> ookk

              Types:

                 S = float()

              See tteexxCCoooorrdd11dd//11

       tteexxCCoooorrdd11ii((SS)) -->> ookk

              Types:

                 S = integer()

              See tteexxCCoooorrdd11dd//11

       tteexxCCoooorrdd11ss((SS)) -->> ookk

              Types:

                 S = integer()

              See tteexxCCoooorrdd11dd//11

       tteexxCCoooorrdd22dd((SS,, TT)) -->> ookk

              Types:

                 S = float()
                 T = float()

              See tteexxCCoooorrdd11dd//11

       tteexxCCoooorrdd22ff((SS,, TT)) -->> ookk

              Types:

                 S = float()
                 T = float()

              See tteexxCCoooorrdd11dd//11

       tteexxCCoooorrdd22ii((SS,, TT)) -->> ookk

              Types:

                 S = integer()
                 T = integer()

              See tteexxCCoooorrdd11dd//11

       tteexxCCoooorrdd22ss((SS,, TT)) -->> ookk

              Types:

                 S = integer()
                 T = integer()

              See tteexxCCoooorrdd11dd//11

       tteexxCCoooorrdd33dd((SS,, TT,, RR)) -->> ookk

              Types:

                 S = float()
                 T = float()
                 R = float()

              See tteexxCCoooorrdd11dd//11

       tteexxCCoooorrdd33ff((SS,, TT,, RR)) -->> ookk

              Types:

                 S = float()
                 T = float()
                 R = float()

              See tteexxCCoooorrdd11dd//11

       tteexxCCoooorrdd33ii((SS,, TT,, RR)) -->> ookk

              Types:

                 S = integer()
                 T = integer()
                 R = integer()

              See tteexxCCoooorrdd11dd//11

       tteexxCCoooorrdd33ss((SS,, TT,, RR)) -->> ookk

              Types:

                 S = integer()
                 T = integer()
                 R = integer()

              See tteexxCCoooorrdd11dd//11

       tteexxCCoooorrdd44dd((SS,, TT,, RR,, QQ)) -->> ookk

              Types:

                 S = float()
                 T = float()
                 R = float()
                 Q = float()

              See tteexxCCoooorrdd11dd//11

       tteexxCCoooorrdd44ff((SS,, TT,, RR,, QQ)) -->> ookk

              Types:

                 S = float()
                 T = float()
                 R = float()
                 Q = float()

              See tteexxCCoooorrdd11dd//11

       tteexxCCoooorrdd44ii((SS,, TT,, RR,, QQ)) -->> ookk

              Types:

                 S = integer()
                 T = integer()
                 R = integer()
                 Q = integer()

              See tteexxCCoooorrdd11dd//11

       tteexxCCoooorrdd44ss((SS,, TT,, RR,, QQ)) -->> ookk

              Types:

                 S = integer()
                 T = integer()
                 R = integer()
                 Q = integer()

              See tteexxCCoooorrdd11dd//11

       tteexxCCoooorrdd11ddvv((VV)) -->> ookk

              Types:

                 V = {S::float()}

              Equivalent to tteexxCCoooorrdd11dd((SS)).

       tteexxCCoooorrdd11ffvv((VV)) -->> ookk

              Types:

                 V = {S::float()}

              Equivalent to tteexxCCoooorrdd11ff((SS)).

       tteexxCCoooorrdd11iivv((VV)) -->> ookk

              Types:

                 V = {S::integer()}

              Equivalent to tteexxCCoooorrdd11ii((SS)).

       tteexxCCoooorrdd11ssvv((VV)) -->> ookk

              Types:

                 V = {S::integer()}

              Equivalent to tteexxCCoooorrdd11ss((SS)).

       tteexxCCoooorrdd22ddvv((VV)) -->> ookk

              Types:

                 V = {S::float(), T::float()}

              Equivalent to tteexxCCoooorrdd22dd((SS,, TT)).

       tteexxCCoooorrdd22ffvv((VV)) -->> ookk

              Types:

                 V = {S::float(), T::float()}

              Equivalent to tteexxCCoooorrdd22ff((SS,, TT)).

       tteexxCCoooorrdd22iivv((VV)) -->> ookk

              Types:

                 V = {S::integer(), T::integer()}

              Equivalent to tteexxCCoooorrdd22ii((SS,, TT)).

       tteexxCCoooorrdd22ssvv((VV)) -->> ookk

              Types:

                 V = {S::integer(), T::integer()}

              Equivalent to tteexxCCoooorrdd22ss((SS,, TT)).

       tteexxCCoooorrdd33ddvv((VV)) -->> ookk

              Types:

                 V = {S::float(), T::float(), R::float()}

              Equivalent to tteexxCCoooorrdd33dd((SS,, TT,, RR)).

       tteexxCCoooorrdd33ffvv((VV)) -->> ookk

              Types:

                 V = {S::float(), T::float(), R::float()}

              Equivalent to tteexxCCoooorrdd33ff((SS,, TT,, RR)).

       tteexxCCoooorrdd33iivv((VV)) -->> ookk

              Types:

                 V = {S::integer(), T::integer(), R::integer()}

              Equivalent to tteexxCCoooorrdd33ii((SS,, TT,, RR)).

       tteexxCCoooorrdd33ssvv((VV)) -->> ookk

              Types:

                 V = {S::integer(), T::integer(), R::integer()}

              Equivalent to tteexxCCoooorrdd33ss((SS,, TT,, RR)).

       tteexxCCoooorrdd44ddvv((VV)) -->> ookk

              Types:

                 V = {S::float(), T::float(), R::float(), Q::float()}

              Equivalent to tteexxCCoooorrdd44dd((SS,, TT,, RR,, QQ)).

       tteexxCCoooorrdd44ffvv((VV)) -->> ookk

              Types:

                 V = {S::float(), T::float(), R::float(), Q::float()}

              Equivalent to tteexxCCoooorrdd44ff((SS,, TT,, RR,, QQ)).

       tteexxCCoooorrdd44iivv((VV)) -->> ookk

              Types:

                 V = {S::integer(), T::integer(), R::integer(), Q::integer()}

              Equivalent to tteexxCCoooorrdd44ii((SS,, TT,, RR,, QQ)).

       tteexxCCoooorrdd44ssvv((VV)) -->> ookk

              Types:

                 V = {S::integer(), T::integer(), R::integer(), Q::integer()}

              Equivalent to tteexxCCoooorrdd44ss((SS,, TT,, RR,, QQ)).

       rraasstteerrPPooss22dd((XX,, YY)) -->> ookk

              Types:

                 X = float()
                 Y = float()

              Specify the raster position for pixel operations

              The GL maintains a 3D position in window coordinates. This
              position, called the raster position, is used to position pixel
              and bitmap write operations. It is maintained with subpixel
              accuracy. See ggll::bbiittmmaapp//77 , ggll::ddrraawwPPiixxeellss//55 , and
              ggll::ccooppyyPPiixxeellss//55 .

              The current raster position consists of three window coordinates
              ( x, y, z), a clip coordinate value ( w), an eye coordinate
              distance, a valid bit, and associated color data and texture
              coordinates. The w coordinate is a clip coordinate, because w is
              not projected to window coordinates. _g_l_:_r_a_s_t_e_r_P_o_s_4 specifies
              object coordinates x, y, z, and w explicitly. _g_l_:_r_a_s_t_e_r_P_o_s_3
              specifies object coordinate x, y, and z explicitly, while w is
              implicitly set to 1. _g_l_:_r_a_s_t_e_r_P_o_s_2 uses the argument values for
              x and y while implicitly setting z and w to 0 and 1.

              The object coordinates presented by _g_l_:_r_a_s_t_e_r_P_o_s are treated
              just like those of a ggll::vveerrtteexx22dd//22 command: They are transformed
              by the current modelview and projection matrices and passed to
              the clipping stage. If the vertex is not culled, then it is
              projected and scaled to window coordinates, which become the new
              current raster position, and the
              _?_G_L___C_U_R_R_E_N_T___R_A_S_T_E_R___P_O_S_I_T_I_O_N___V_A_L_I_D flag is set. If the vertex _i_s
              culled, then the valid bit is cleared and the current raster
              position and associated color and texture coordinates are
              undefined.

              The current raster position also includes some associated color
              data and texture coordinates. If lighting is enabled, then
              _?_G_L___C_U_R_R_E_N_T___R_A_S_T_E_R___C_O_L_O_R (in RGBA mode) or
              _?_G_L___C_U_R_R_E_N_T___R_A_S_T_E_R___I_N_D_E_X (in color index mode) is set to the
              color produced by the lighting calculation (see ggll::lliigghhttff//33 ,
              ggll::lliigghhttMMooddeellff//22 , and ggll::sshhaaddeeMMooddeell//11 ). If lighting is
              disabled, current color (in RGBA mode, state variable
              _?_G_L___C_U_R_R_E_N_T___C_O_L_O_R) or color index (in color index mode, state
              variable _?_G_L___C_U_R_R_E_N_T___I_N_D_E_X) is used to update the current raster
              color. _?_G_L___C_U_R_R_E_N_T___R_A_S_T_E_R___S_E_C_O_N_D_A_R_Y___C_O_L_O_R (in RGBA mode) is
              likewise updated.

              Likewise, _?_G_L___C_U_R_R_E_N_T___R_A_S_T_E_R___T_E_X_T_U_R_E___C_O_O_R_D_S is updated as a
              function of _?_G_L___C_U_R_R_E_N_T___T_E_X_T_U_R_E___C_O_O_R_D_S , based on the texture
              matrix and the texture generation functions (see ggll::tteexxGGeenndd//33 ).
              Finally, the distance from the origin of the eye coordinate
              system to the vertex as transformed by only the modelview matrix
              replaces _?_G_L___C_U_R_R_E_N_T___R_A_S_T_E_R___D_I_S_T_A_N_C_E.

              Initially, the current raster position is (0, 0, 0, 1), the
              current raster distance is 0, the valid bit is set, the
              associated RGBA color is (1, 1, 1, 1), the associated color
              index is 1, and the associated texture coordinates are (0, 0, 0,
              1). In RGBA mode, _?_G_L___C_U_R_R_E_N_T___R_A_S_T_E_R___I_N_D_E_X is always 1; in color
              index mode, the current raster RGBA color always maintains its
              initial value.

              See external documentation.

       rraasstteerrPPooss22ff((XX,, YY)) -->> ookk

              Types:

                 X = float()
                 Y = float()

              See rraasstteerrPPooss22dd//22

       rraasstteerrPPooss22ii((XX,, YY)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()

              See rraasstteerrPPooss22dd//22

       rraasstteerrPPooss22ss((XX,, YY)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()

              See rraasstteerrPPooss22dd//22

       rraasstteerrPPooss33dd((XX,, YY,, ZZ)) -->> ookk

              Types:

                 X = float()
                 Y = float()
                 Z = float()

              See rraasstteerrPPooss22dd//22

       rraasstteerrPPooss33ff((XX,, YY,, ZZ)) -->> ookk

              Types:

                 X = float()
                 Y = float()
                 Z = float()

              See rraasstteerrPPooss22dd//22

       rraasstteerrPPooss33ii((XX,, YY,, ZZ)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()
                 Z = integer()

              See rraasstteerrPPooss22dd//22

       rraasstteerrPPooss33ss((XX,, YY,, ZZ)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()
                 Z = integer()

              See rraasstteerrPPooss22dd//22

       rraasstteerrPPooss44dd((XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 X = float()
                 Y = float()
                 Z = float()
                 W = float()

              See rraasstteerrPPooss22dd//22

       rraasstteerrPPooss44ff((XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 X = float()
                 Y = float()
                 Z = float()
                 W = float()

              See rraasstteerrPPooss22dd//22

       rraasstteerrPPooss44ii((XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()
                 Z = integer()
                 W = integer()

              See rraasstteerrPPooss22dd//22

       rraasstteerrPPooss44ss((XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()
                 Z = integer()
                 W = integer()

              See rraasstteerrPPooss22dd//22

       rraasstteerrPPooss22ddvv((VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float()}

              Equivalent to rraasstteerrPPooss22dd((XX,, YY)).

       rraasstteerrPPooss22ffvv((VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float()}

              Equivalent to rraasstteerrPPooss22ff((XX,, YY)).

       rraasstteerrPPooss22iivv((VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer()}

              Equivalent to rraasstteerrPPooss22ii((XX,, YY)).

       rraasstteerrPPooss22ssvv((VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer()}

              Equivalent to rraasstteerrPPooss22ss((XX,, YY)).

       rraasstteerrPPooss33ddvv((VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float(), Z::float()}

              Equivalent to rraasstteerrPPooss33dd((XX,, YY,, ZZ)).

       rraasstteerrPPooss33ffvv((VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float(), Z::float()}

              Equivalent to rraasstteerrPPooss33ff((XX,, YY,, ZZ)).

       rraasstteerrPPooss33iivv((VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer()}

              Equivalent to rraasstteerrPPooss33ii((XX,, YY,, ZZ)).

       rraasstteerrPPooss33ssvv((VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer()}

              Equivalent to rraasstteerrPPooss33ss((XX,, YY,, ZZ)).

       rraasstteerrPPooss44ddvv((VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float(), Z::float(), W::float()}

              Equivalent to rraasstteerrPPooss44dd((XX,, YY,, ZZ,, WW)).

       rraasstteerrPPooss44ffvv((VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float(), Z::float(), W::float()}

              Equivalent to rraasstteerrPPooss44ff((XX,, YY,, ZZ,, WW)).

       rraasstteerrPPooss44iivv((VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer(), W::integer()}

              Equivalent to rraasstteerrPPooss44ii((XX,, YY,, ZZ,, WW)).

       rraasstteerrPPooss44ssvv((VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer(), W::integer()}

              Equivalent to rraasstteerrPPooss44ss((XX,, YY,, ZZ,, WW)).

       rreeccttdd((XX11,, YY11,, XX22,, YY22)) -->> ookk

              Types:

                 X1 = float()
                 Y1 = float()
                 X2 = float()
                 Y2 = float()

              Draw a rectangle

              _g_l_:_r_e_c_t supports efficient specification of rectangles as two
              corner points. Each rectangle command takes four arguments,
              organized either as two consecutive pairs of (x y) coordinates
              or as two pointers to arrays, each containing an (x y) pair. The
              resulting rectangle is defined in the z= 0 plane.

              _g_l_:_r_e_c_t( _X_1 , _Y_1 , _X_2 , _Y_2 ) is exactly equivalent to the
              following sequence: glBegin(_?_G_L___P_O_L_Y_G_O_N); glVertex2( _X_1 , _Y_1 );
              glVertex2( _X_2 , _Y_1 ); glVertex2( _X_2 , _Y_2 ); glVertex2( _X_1 , _Y_2
              ); glEnd(); Note that if the second vertex is above and to the
              right of the first vertex, the rectangle is constructed with a
              counterclockwise winding.

              See external documentation.

       rreeccttff((XX11,, YY11,, XX22,, YY22)) -->> ookk

              Types:

                 X1 = float()
                 Y1 = float()
                 X2 = float()
                 Y2 = float()

              See rreeccttdd//44

       rreeccttii((XX11,, YY11,, XX22,, YY22)) -->> ookk

              Types:

                 X1 = integer()
                 Y1 = integer()
                 X2 = integer()
                 Y2 = integer()

              See rreeccttdd//44

       rreeccttss((XX11,, YY11,, XX22,, YY22)) -->> ookk

              Types:

                 X1 = integer()
                 Y1 = integer()
                 X2 = integer()
                 Y2 = integer()

              See rreeccttdd//44

       rreeccttddvv((VV11,, VV22)) -->> ookk

              Types:

                 V1 = {float(), float()}
                 V2 = {float(), float()}

              See rreeccttdd//44

       rreeccttffvv((VV11,, VV22)) -->> ookk

              Types:

                 V1 = {float(), float()}
                 V2 = {float(), float()}

              See rreeccttdd//44

       rreeccttiivv((VV11,, VV22)) -->> ookk

              Types:

                 V1 = {integer(), integer()}
                 V2 = {integer(), integer()}

              See rreeccttdd//44

       rreeccttssvv((VV11,, VV22)) -->> ookk

              Types:

                 V1 = {integer(), integer()}
                 V2 = {integer(), integer()}

              See rreeccttdd//44

       vveerrtteexxPPooiinntteerr((SSiizzee,, TTyyppee,, SSttrriiddee,, PPttrr)) -->> ookk

              Types:

                 Size = integer()
                 Type = enum()
                 Stride = integer()
                 Ptr = offset() | mem()

              Define an array of vertex data

              _g_l_:_v_e_r_t_e_x_P_o_i_n_t_e_r specifies the location and data format of an
              array of vertex coordinates to use when rendering. _S_i_z_e
              specifies the number of coordinates per vertex, and must be 2,
              3, or 4. _T_y_p_e specifies the data type of each coordinate, and
              _S_t_r_i_d_e specifies the byte stride from one vertex to the next,
              allowing vertices and attributes to be packed into a single
              array or stored in separate arrays. (Single-array storage may be
              more efficient on some implementations; see
              ggll::iinntteerrlleeaavveeddAArrrraayyss//33 .)

              If a non-zero named buffer object is bound to the
              _?_G_L___A_R_R_A_Y___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a vertex
              array is specified, _P_o_i_n_t_e_r is treated as a byte offset into the
              buffer object's data store. Also, the buffer object binding
              (_?_G_L___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G ) is saved as vertex array client-side
              state (_?_G_L___V_E_R_T_E_X___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G).

              When a vertex array is specified, _S_i_z_e , _T_y_p_e , _S_t_r_i_d_e , and
              _P_o_i_n_t_e_r are saved as client-side state, in addition to the
              current vertex array buffer object binding.

              To enable and disable the vertex array, call
              ggll::eennaabblleeCClliieennttSSttaattee//11 and ggll::eennaabblleeCClliieennttSSttaattee//11 with the
              argument _?_G_L___V_E_R_T_E_X___A_R_R_A_Y. If enabled, the vertex array is used
              when ggll::aarrrraayyEElleemmeenntt//11 , ggll::ddrraawwAArrrraayyss//33 , ggll::mmuullttiiDDrraawwAArrrraayyss//33
              , ggll::ddrraawwEElleemmeennttss//44 , see _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s , or
              ggll::ddrraawwRRaannggeeEElleemmeennttss//66 is called.

              See external documentation.

       nnoorrmmaallPPooiinntteerr((TTyyppee,, SSttrriiddee,, PPttrr)) -->> ookk

              Types:

                 Type = enum()
                 Stride = integer()
                 Ptr = offset() | mem()

              Define an array of normals

              _g_l_:_n_o_r_m_a_l_P_o_i_n_t_e_r specifies the location and data format of an
              array of normals to use when rendering. _T_y_p_e specifies the data
              type of each normal coordinate, and _S_t_r_i_d_e specifies the byte
              stride from one normal to the next, allowing vertices and
              attributes to be packed into a single array or stored in
              separate arrays. (Single-array storage may be more efficient on
              some implementations; see ggll::iinntteerrlleeaavveeddAArrrraayyss//33 .)

              If a non-zero named buffer object is bound to the
              _?_G_L___A_R_R_A_Y___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a normal
              array is specified, _P_o_i_n_t_e_r is treated as a byte offset into the
              buffer object's data store. Also, the buffer object binding
              (_?_G_L___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G ) is saved as normal vertex array
              client-side state (_?_G_L___N_O_R_M_A_L___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G ).

              When a normal array is specified, _T_y_p_e , _S_t_r_i_d_e , and _P_o_i_n_t_e_r
              are saved as client-side state, in addition to the current
              vertex array buffer object binding.

              To enable and disable the normal array, call
              ggll::eennaabblleeCClliieennttSSttaattee//11 and ggll::eennaabblleeCClliieennttSSttaattee//11 with the
              argument _?_G_L___N_O_R_M_A_L___A_R_R_A_Y. If enabled, the normal array is used
              when ggll::ddrraawwAArrrraayyss//33 , ggll::mmuullttiiDDrraawwAArrrraayyss//33 , ggll::ddrraawwEElleemmeennttss//44
              , see _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s, ggll::ddrraawwRRaannggeeEElleemmeennttss//66 , or
              ggll::aarrrraayyEElleemmeenntt//11 is called.

              See external documentation.

       ccoolloorrPPooiinntteerr((SSiizzee,, TTyyppee,, SSttrriiddee,, PPttrr)) -->> ookk

              Types:

                 Size = integer()
                 Type = enum()
                 Stride = integer()
                 Ptr = offset() | mem()

              Define an array of colors

              _g_l_:_c_o_l_o_r_P_o_i_n_t_e_r specifies the location and data format of an
              array of color components to use when rendering. _S_i_z_e specifies
              the number of components per color, and must be 3 or 4. _T_y_p_e
              specifies the data type of each color component, and _S_t_r_i_d_e
              specifies the byte stride from one color to the next, allowing
              vertices and attributes to be packed into a single array or
              stored in separate arrays. (Single-array storage may be more
              efficient on some implementations; see ggll::iinntteerrlleeaavveeddAArrrraayyss//33 .)

              If a non-zero named buffer object is bound to the
              _?_G_L___A_R_R_A_Y___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a color
              array is specified, _P_o_i_n_t_e_r is treated as a byte offset into the
              buffer object's data store. Also, the buffer object binding
              (_?_G_L___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G ) is saved as color vertex array
              client-side state (_?_G_L___C_O_L_O_R___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G).

              When a color array is specified, _S_i_z_e , _T_y_p_e , _S_t_r_i_d_e , and
              _P_o_i_n_t_e_r are saved as client-side state, in addition to the
              current vertex array buffer object binding.

              To enable and disable the color array, call
              ggll::eennaabblleeCClliieennttSSttaattee//11 and ggll::eennaabblleeCClliieennttSSttaattee//11 with the
              argument _?_G_L___C_O_L_O_R___A_R_R_A_Y. If enabled, the color array is used
              when ggll::ddrraawwAArrrraayyss//33 , ggll::mmuullttiiDDrraawwAArrrraayyss//33 , ggll::ddrraawwEElleemmeennttss//44
              , see _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s, ggll::ddrraawwRRaannggeeEElleemmeennttss//66 , or
              ggll::aarrrraayyEElleemmeenntt//11 is called.

              See external documentation.

       iinnddeexxPPooiinntteerr((TTyyppee,, SSttrriiddee,, PPttrr)) -->> ookk

              Types:

                 Type = enum()
                 Stride = integer()
                 Ptr = offset() | mem()

              Define an array of color indexes

              _g_l_:_i_n_d_e_x_P_o_i_n_t_e_r specifies the location and data format of an
              array of color indexes to use when rendering. _T_y_p_e specifies the
              data type of each color index and _S_t_r_i_d_e specifies the byte
              stride from one color index to the next, allowing vertices and
              attributes to be packed into a single array or stored in
              separate arrays.

              If a non-zero named buffer object is bound to the
              _?_G_L___A_R_R_A_Y___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a color
              index array is specified, _P_o_i_n_t_e_r is treated as a byte offset
              into the buffer object's data store. Also, the buffer object
              binding (_?_G_L___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G ) is saved as color index
              vertex array client-side state (_?_G_L___I_N_D_E_X___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G
              ).

              When a color index array is specified, _T_y_p_e , _S_t_r_i_d_e , and
              _P_o_i_n_t_e_r are saved as client-side state, in addition to the
              current vertex array buffer object binding.

              To enable and disable the color index array, call
              ggll::eennaabblleeCClliieennttSSttaattee//11 and ggll::eennaabblleeCClliieennttSSttaattee//11 with the
              argument _?_G_L___I_N_D_E_X___A_R_R_A_Y. If enabled, the color index array is
              used when ggll::ddrraawwAArrrraayyss//33 , ggll::mmuullttiiDDrraawwAArrrraayyss//33 ,
              ggll::ddrraawwEElleemmeennttss//44 , see _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s ,
              ggll::ddrraawwRRaannggeeEElleemmeennttss//66 , or ggll::aarrrraayyEElleemmeenntt//11 is called.

              See external documentation.

       tteexxCCoooorrddPPooiinntteerr((SSiizzee,, TTyyppee,, SSttrriiddee,, PPttrr)) -->> ookk

              Types:

                 Size = integer()
                 Type = enum()
                 Stride = integer()
                 Ptr = offset() | mem()

              Define an array of texture coordinates

              _g_l_:_t_e_x_C_o_o_r_d_P_o_i_n_t_e_r specifies the location and data format of an
              array of texture coordinates to use when rendering. _S_i_z_e
              specifies the number of coordinates per texture coordinate set,
              and must be 1, 2, 3, or 4. _T_y_p_e specifies the data type of each
              texture coordinate, and _S_t_r_i_d_e specifies the byte stride from
              one texture coordinate set to the next, allowing vertices and
              attributes to be packed into a single array or stored in
              separate arrays. (Single-array storage may be more efficient on
              some implementations; see ggll::iinntteerrlleeaavveeddAArrrraayyss//33 .)

              If a non-zero named buffer object is bound to the
              _?_G_L___A_R_R_A_Y___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a texture
              coordinate array is specified, _P_o_i_n_t_e_r is treated as a byte
              offset into the buffer object's data store. Also, the buffer
              object binding (_?_G_L___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G ) is saved as texture
              coordinate vertex array client-side state
              (_?_G_L___T_E_X_T_U_R_E___C_O_O_R_D___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G ).

              When a texture coordinate array is specified, _S_i_z_e , _T_y_p_e ,
              _S_t_r_i_d_e , and _P_o_i_n_t_e_r are saved as client-side state, in addition
              to the current vertex array buffer object binding.

              To enable and disable a texture coordinate array, call
              ggll::eennaabblleeCClliieennttSSttaattee//11 and ggll::eennaabblleeCClliieennttSSttaattee//11 with the
              argument _?_G_L___T_E_X_T_U_R_E___C_O_O_R_D___A_R_R_A_Y. If enabled, the texture
              coordinate array is used when ggll::aarrrraayyEElleemmeenntt//11 ,
              ggll::ddrraawwAArrrraayyss//33 , ggll::mmuullttiiDDrraawwAArrrraayyss//33 , ggll::ddrraawwEElleemmeennttss//44 , see
              _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s, or ggll::ddrraawwRRaannggeeEElleemmeennttss//66 is called.

              See external documentation.

       eeddggeeFFllaaggPPooiinntteerr((SSttrriiddee,, PPttrr)) -->> ookk

              Types:

                 Stride = integer()
                 Ptr = offset() | mem()

              Define an array of edge flags

              _g_l_:_e_d_g_e_F_l_a_g_P_o_i_n_t_e_r specifies the location and data format of an
              array of boolean edge flags to use when rendering. _S_t_r_i_d_e
              specifies the byte stride from one edge flag to the next,
              allowing vertices and attributes to be packed into a single
              array or stored in separate arrays.

              If a non-zero named buffer object is bound to the
              _?_G_L___A_R_R_A_Y___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while an edge
              flag array is specified, _P_o_i_n_t_e_r is treated as a byte offset
              into the buffer object's data store. Also, the buffer object
              binding (_?_G_L___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G ) is saved as edge flag vertex
              array client-side state (_?_G_L___E_D_G_E___F_L_A_G___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G ).

              When an edge flag array is specified, _S_t_r_i_d_e and _P_o_i_n_t_e_r are
              saved as client-side state, in addition to the current vertex
              array buffer object binding.

              To enable and disable the edge flag array, call
              ggll::eennaabblleeCClliieennttSSttaattee//11 and ggll::eennaabblleeCClliieennttSSttaattee//11 with the
              argument _?_G_L___E_D_G_E___F_L_A_G___A_R_R_A_Y. If enabled, the edge flag array is
              used when ggll::ddrraawwAArrrraayyss//33 , ggll::mmuullttiiDDrraawwAArrrraayyss//33 ,
              ggll::ddrraawwEElleemmeennttss//44 , see _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s ,
              ggll::ddrraawwRRaannggeeEElleemmeennttss//66 , or ggll::aarrrraayyEElleemmeenntt//11 is called.

              See external documentation.

       aarrrraayyEElleemmeenntt((II)) -->> ookk

              Types:

                 I = integer()

              Render a vertex using the specified vertex array element

              _g_l_:_a_r_r_a_y_E_l_e_m_e_n_t commands are used within ggll::''bbeeggiinn''//11 /
              ggll::''bbeeggiinn''//11 pairs to specify vertex and attribute data for
              point, line, and polygon primitives. If _?_G_L___V_E_R_T_E_X___A_R_R_A_Y is
              enabled when _g_l_:_a_r_r_a_y_E_l_e_m_e_n_t is called, a single vertex is
              drawn, using vertex and attribute data taken from location _I of
              the enabled arrays. If _?_G_L___V_E_R_T_E_X___A_R_R_A_Y is not enabled, no
              drawing occurs but the attributes corresponding to the enabled
              arrays are modified.

              Use _g_l_:_a_r_r_a_y_E_l_e_m_e_n_t to construct primitives by indexing vertex
              data, rather than by streaming through arrays of data in first-
              to-last order. Because each call specifies only a single vertex,
              it is possible to explicitly specify per-primitive attributes
              such as a single normal for each triangle.

              Changes made to array data between the execution of ggll::''bbeeggiinn''//11
              and the corresponding execution of ggll::''bbeeggiinn''//11 may affect calls
              to _g_l_:_a_r_r_a_y_E_l_e_m_e_n_t that are made within the same ggll::''bbeeggiinn''//11 /
              ggll::''bbeeggiinn''//11 period in nonsequential ways. That is, a call to
              _g_l_:_a_r_r_a_y_E_l_e_m_e_n_t that precedes a change to array data may access
              the changed data, and a call that follows a change to array data
              may access original data.

              See external documentation.

       ddrraawwAArrrraayyss((MMooddee,, FFiirrsstt,, CCoouunntt)) -->> ookk

              Types:

                 Mode = enum()
                 First = integer()
                 Count = integer()

              Render primitives from array data

              _g_l_:_d_r_a_w_A_r_r_a_y_s specifies multiple geometric primitives with very
              few subroutine calls. Instead of calling a GL procedure to pass
              each individual vertex, normal, texture coordinate, edge flag,
              or color, you can prespecify separate arrays of vertices,
              normals, and colors and use them to construct a sequence of
              primitives with a single call to _g_l_:_d_r_a_w_A_r_r_a_y_s .

              When _g_l_:_d_r_a_w_A_r_r_a_y_s is called, it uses _C_o_u_n_t sequential elements
              from each enabled array to construct a sequence of geometric
              primitives, beginning with element _F_i_r_s_t . _M_o_d_e specifies what
              kind of primitives are constructed and how the array elements
              construct those primitives.

              Vertex attributes that are modified by _g_l_:_d_r_a_w_A_r_r_a_y_s have an
              unspecified value after _g_l_:_d_r_a_w_A_r_r_a_y_s returns. Attributes that
              aren't modified remain well defined.

              See external documentation.

       ddrraawwEElleemmeennttss((MMooddee,, CCoouunntt,, TTyyppee,, IInnddiicceess)) -->> ookk

              Types:

                 Mode = enum()
                 Count = integer()
                 Type = enum()
                 Indices = offset() | mem()

              Render primitives from array data

              _g_l_:_d_r_a_w_E_l_e_m_e_n_t_s specifies multiple geometric primitives with
              very few subroutine calls. Instead of calling a GL function to
              pass each individual vertex, normal, texture coordinate, edge
              flag, or color, you can prespecify separate arrays of vertices,
              normals, and so on, and use them to construct a sequence of
              primitives with a single call to _g_l_:_d_r_a_w_E_l_e_m_e_n_t_s .

              When _g_l_:_d_r_a_w_E_l_e_m_e_n_t_s is called, it uses _C_o_u_n_t sequential
              elements from an enabled array, starting at _I_n_d_i_c_e_s to construct
              a sequence of geometric primitives. _M_o_d_e specifies what kind of
              primitives are constructed and how the array elements construct
              these primitives. If more than one array is enabled, each is
              used.

              Vertex attributes that are modified by _g_l_:_d_r_a_w_E_l_e_m_e_n_t_s have an
              unspecified value after _g_l_:_d_r_a_w_E_l_e_m_e_n_t_s returns. Attributes that
              aren't modified maintain their previous values.

              See external documentation.

       iinntteerrlleeaavveeddAArrrraayyss((FFoorrmmaatt,, SSttrriiddee,, PPooiinntteerr)) -->> ookk

              Types:

                 Format = enum()
                 Stride = integer()
                 Pointer = offset() | mem()

              Simultaneously specify and enable several interleaved arrays

              _g_l_:_i_n_t_e_r_l_e_a_v_e_d_A_r_r_a_y_s lets you specify and enable individual
              color, normal, texture and vertex arrays whose elements are part
              of a larger aggregate array element. For some implementations,
              this is more efficient than specifying the arrays separately.

              If _S_t_r_i_d_e is 0, the aggregate elements are stored consecutively.
              Otherwise, _S_t_r_i_d_e bytes occur between the beginning of one
              aggregate array element and the beginning of the next aggregate
              array element.

              _F_o_r_m_a_t serves as a _k_e_y describing the extraction of individual
              arrays from the aggregate array. If _F_o_r_m_a_t contains a T, then
              texture coordinates are extracted from the interleaved array. If
              C is present, color values are extracted. If N is present,
              normal coordinates are extracted. Vertex coordinates are always
              extracted.

              The digits 2, 3, and 4 denote how many values are extracted. F
              indicates that values are extracted as floating-point values.
              Colors may also be extracted as 4 unsigned bytes if 4UB follows
              the C. If a color is extracted as 4 unsigned bytes, the vertex
              array element which follows is located at the first possible
              floating-point aligned address.

              See external documentation.

       sshhaaddeeMMooddeell((MMooddee)) -->> ookk

              Types:

                 Mode = enum()

              Select flat or smooth shading

              GL primitives can have either flat or smooth shading. Smooth
              shading, the default, causes the computed colors of vertices to
              be interpolated as the primitive is rasterized, typically
              assigning different colors to each resulting pixel fragment.
              Flat shading selects the computed color of just one vertex and
              assigns it to all the pixel fragments generated by rasterizing a
              single primitive. In either case, the computed color of a vertex
              is the result of lighting if lighting is enabled, or it is the
              current color at the time the vertex was specified if lighting
              is disabled.

              Flat and smooth shading are indistinguishable for points.
              Starting when ggll::''bbeeggiinn''//11 is issued and counting vertices and
              primitives from 1, the GL gives each flat-shaded line segment i
              the computed color of vertex i+1, its second vertex. Counting
              similarly from 1, the GL gives each flat-shaded polygon the
              computed color of the vertex listed in the following table. This
              is the last vertex to specify the polygon in all cases except
              single polygons, where the first vertex specifies the flat-
              shaded color._P_r_i_m_i_t_i_v_e _T_y_p_e _o_f _P_o_l_y_g_o_n i_V_e_r_t_e_x
               Single polygon ( i== 1) 1
               Triangle strip i+2
               Triangle fan i+2
               Independent triangle 3 i
               Quad strip 2 i+2
               Independent quad 4 i


              Flat and smooth shading are specified by _g_l_:_s_h_a_d_e_M_o_d_e_l with _M_o_d_e
              set to _?_G_L___F_L_A_T and _?_G_L___S_M_O_O_T_H, respectively.

              See external documentation.

       lliigghhttff((LLiigghhtt,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Light = enum()
                 Pname = enum()
                 Param = float()

              Set light source parameters

              _g_l_:_l_i_g_h_t sets the values of individual light source parameters.
              _L_i_g_h_t names the light and is a symbolic name of the form
              _?_G_L___L_I_G_H_T i, where i ranges from 0 to the value of
              _?_G_L___M_A_X___L_I_G_H_T_S - 1. _P_n_a_m_e specifies one of ten light source
              parameters, again by symbolic name. _P_a_r_a_m_s is either a single
              value or a pointer to an array that contains the new values.

              To enable and disable lighting calculation, call ggll::eennaabbllee//11 and
              ggll::eennaabbllee//11 with argument _?_G_L___L_I_G_H_T_I_N_G. Lighting is initially
              disabled. When it is enabled, light sources that are enabled
              contribute to the lighting calculation. Light source i is
              enabled and disabled using ggll::eennaabbllee//11 and ggll::eennaabbllee//11 with
              argument _?_G_L___L_I_G_H_T i.

              The ten light parameters are as follows:

              _?_G_L___A_M_B_I_E_N_T: _P_a_r_a_m_s contains four integer or floating-point
              values that specify the ambient RGBA intensity of the light.
              Integer values are mapped linearly such that the most positive
              representable value maps to 1.0, and the most negative
              representable value maps to -1.0. Floating-point values are
              mapped directly. Neither integer nor floating-point values are
              clamped. The initial ambient light intensity is (0, 0, 0, 1).

              _?_G_L___D_I_F_F_U_S_E: _P_a_r_a_m_s contains four integer or floating-point
              values that specify the diffuse RGBA intensity of the light.
              Integer values are mapped linearly such that the most positive
              representable value maps to 1.0, and the most negative
              representable value maps to -1.0. Floating-point values are
              mapped directly. Neither integer nor floating-point values are
              clamped. The initial value for _?_G_L___L_I_G_H_T_0 is (1, 1, 1, 1); for
              other lights, the initial value is (0, 0, 0, 1).

              _?_G_L___S_P_E_C_U_L_A_R: _P_a_r_a_m_s contains four integer or floating-point
              values that specify the specular RGBA intensity of the light.
              Integer values are mapped linearly such that the most positive
              representable value maps to 1.0, and the most negative
              representable value maps to -1.0. Floating-point values are
              mapped directly. Neither integer nor floating-point values are
              clamped. The initial value for _?_G_L___L_I_G_H_T_0 is (1, 1, 1, 1); for
              other lights, the initial value is (0, 0, 0, 1).

              _?_G_L___P_O_S_I_T_I_O_N: _P_a_r_a_m_s contains four integer or floating-point
              values that specify the position of the light in homogeneous
              object coordinates. Both integer and floating-point values are
              mapped directly. Neither integer nor floating-point values are
              clamped.

              The position is transformed by the modelview matrix when
              _g_l_:_l_i_g_h_t is called (just as if it were a point), and it is
              stored in eye coordinates. If the w component of the position is
              0, the light is treated as a directional source. Diffuse and
              specular lighting calculations take the light's direction, but
              not its actual position, into account, and attenuation is
              disabled. Otherwise, diffuse and specular lighting calculations
              are based on the actual location of the light in eye
              coordinates, and attenuation is enabled. The initial position is
              (0, 0, 1, 0); thus, the initial light source is directional,
              parallel to, and in the direction of the -z axis.

              _?_G_L___S_P_O_T___D_I_R_E_C_T_I_O_N: _P_a_r_a_m_s contains three integer or floating-
              point values that specify the direction of the light in
              homogeneous object coordinates. Both integer and floating-point
              values are mapped directly. Neither integer nor floating-point
              values are clamped.

              The spot direction is transformed by the upper 3x3 of the
              modelview matrix when _g_l_:_l_i_g_h_t is called, and it is stored in
              eye coordinates. It is significant only when _?_G_L___S_P_O_T___C_U_T_O_F_F is
              not 180, which it is initially. The initial direction is (0 0
              -1).

              _?_G_L___S_P_O_T___E_X_P_O_N_E_N_T: _P_a_r_a_m_s is a single integer or floating-point
              value that specifies the intensity distribution of the light.
              Integer and floating-point values are mapped directly. Only
              values in the range [0 128] are accepted.

              Effective light intensity is attenuated by the cosine of the
              angle between the direction of the light and the direction from
              the light to the vertex being lighted, raised to the power of
              the spot exponent. Thus, higher spot exponents result in a more
              focused light source, regardless of the spot cutoff angle (see
              _?_G_L___S_P_O_T___C_U_T_O_F_F, next paragraph). The initial spot exponent is
              0, resulting in uniform light distribution.

              _?_G_L___S_P_O_T___C_U_T_O_F_F: _P_a_r_a_m_s is a single integer or floating-point
              value that specifies the maximum spread angle of a light source.
              Integer and floating-point values are mapped directly. Only
              values in the range [0 90] and the special value 180 are
              accepted. If the angle between the direction of the light and
              the direction from the light to the vertex being lighted is
              greater than the spot cutoff angle, the light is completely
              masked. Otherwise, its intensity is controlled by the spot
              exponent and the attenuation factors. The initial spot cutoff is
              180, resulting in uniform light distribution.

              _?_G_L___C_O_N_S_T_A_N_T___A_T_T_E_N_U_A_T_I_O_N

              _?_G_L___L_I_N_E_A_R___A_T_T_E_N_U_A_T_I_O_N

              _?_G_L___Q_U_A_D_R_A_T_I_C___A_T_T_E_N_U_A_T_I_O_N: _P_a_r_a_m_s is a single integer or
              floating-point value that specifies one of the three light
              attenuation factors. Integer and floating-point values are
              mapped directly. Only nonnegative values are accepted. If the
              light is positional, rather than directional, its intensity is
              attenuated by the reciprocal of the sum of the constant factor,
              the linear factor times the distance between the light and the
              vertex being lighted, and the quadratic factor times the square
              of the same distance. The initial attenuation factors are (1, 0,
              0), resulting in no attenuation.

              See external documentation.

       lliigghhttii((LLiigghhtt,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Light = enum()
                 Pname = enum()
                 Param = integer()

              See lliigghhttff//33

       lliigghhttffvv((LLiigghhtt,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Light = enum()
                 Pname = enum()
                 Params = {float()}

              See lliigghhttff//33

       lliigghhttiivv((LLiigghhtt,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Light = enum()
                 Pname = enum()
                 Params = {integer()}

              See lliigghhttff//33

       ggeettLLiigghhttffvv((LLiigghhtt,, PPnnaammee)) -->> {{ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(())}}

              Types:

                 Light = enum()
                 Pname = enum()

              Return light source parameter values

              _g_l_:_g_e_t_L_i_g_h_t returns in _P_a_r_a_m_s the value or values of a light
              source parameter. _L_i_g_h_t names the light and is a symbolic name
              of the form _?_G_L___L_I_G_H_T i where i ranges from 0 to the value of
              _?_G_L___M_A_X___L_I_G_H_T_S - 1. _?_G_L___M_A_X___L_I_G_H_T_S is an implementation
              dependent constant that is greater than or equal to eight. _P_n_a_m_e
              specifies one of ten light source parameters, again by symbolic
              name.

              The following parameters are defined:

              _?_G_L___A_M_B_I_E_N_T: _P_a_r_a_m_s returns four integer or floating-point
              values representing the ambient intensity of the light source.
              Integer values, when requested, are linearly mapped from the
              internal floating-point representation such that 1.0 maps to the
              most positive representable integer value, and -1.0 maps to the
              most negative representable integer value. If the internal value
              is outside the range [-1 1], the corresponding integer return
              value is undefined. The initial value is (0, 0, 0, 1).

              _?_G_L___D_I_F_F_U_S_E: _P_a_r_a_m_s returns four integer or floating-point
              values representing the diffuse intensity of the light source.
              Integer values, when requested, are linearly mapped from the
              internal floating-point representation such that 1.0 maps to the
              most positive representable integer value, and -1.0 maps to the
              most negative representable integer value. If the internal value
              is outside the range [-1 1], the corresponding integer return
              value is undefined. The initial value for _?_G_L___L_I_G_H_T_0 is (1, 1,
              1, 1); for other lights, the initial value is (0, 0, 0, 0).

              _?_G_L___S_P_E_C_U_L_A_R: _P_a_r_a_m_s returns four integer or floating-point
              values representing the specular intensity of the light source.
              Integer values, when requested, are linearly mapped from the
              internal floating-point representation such that 1.0 maps to the
              most positive representable integer value, and -1.0 maps to the
              most negative representable integer value. If the internal value
              is outside the range [-1 1], the corresponding integer return
              value is undefined. The initial value for _?_G_L___L_I_G_H_T_0 is (1, 1,
              1, 1); for other lights, the initial value is (0, 0, 0, 0).

              _?_G_L___P_O_S_I_T_I_O_N: _P_a_r_a_m_s returns four integer or floating-point
              values representing the position of the light source. Integer
              values, when requested, are computed by rounding the internal
              floating-point values to the nearest integer value. The returned
              values are those maintained in eye coordinates. They will not be
              equal to the values specified using ggll::lliigghhttff//33 , unless the
              modelview matrix was identity at the time ggll::lliigghhttff//33 was
              called. The initial value is (0, 0, 1, 0).

              _?_G_L___S_P_O_T___D_I_R_E_C_T_I_O_N: _P_a_r_a_m_s returns three integer or floating-
              point values representing the direction of the light source.
              Integer values, when requested, are computed by rounding the
              internal floating-point values to the nearest integer value. The
              returned values are those maintained in eye coordinates. They
              will not be equal to the values specified using ggll::lliigghhttff//33 ,
              unless the modelview matrix was identity at the time ggll::lliigghhttff//33
              was called. Although spot direction is normalized before being
              used in the lighting equation, the returned values are the
              transformed versions of the specified values prior to
              normalization. The initial value is (0 0 -1).

              _?_G_L___S_P_O_T___E_X_P_O_N_E_N_T: _P_a_r_a_m_s returns a single integer or floating-
              point value representing the spot exponent of the light. An
              integer value, when requested, is computed by rounding the
              internal floating-point representation to the nearest integer.
              The initial value is 0.

              _?_G_L___S_P_O_T___C_U_T_O_F_F: _P_a_r_a_m_s returns a single integer or floating-
              point value representing the spot cutoff angle of the light. An
              integer value, when requested, is computed by rounding the
              internal floating-point representation to the nearest integer.
              The initial value is 180.

              _?_G_L___C_O_N_S_T_A_N_T___A_T_T_E_N_U_A_T_I_O_N: _P_a_r_a_m_s returns a single integer or
              floating-point value representing the constant (not distance-
              related) attenuation of the light. An integer value, when
              requested, is computed by rounding the internal floating-point
              representation to the nearest integer. The initial value is 1.

              _?_G_L___L_I_N_E_A_R___A_T_T_E_N_U_A_T_I_O_N: _P_a_r_a_m_s returns a single integer or
              floating-point value representing the linear attenuation of the
              light. An integer value, when requested, is computed by rounding
              the internal floating-point representation to the nearest
              integer. The initial value is 0.

              _?_G_L___Q_U_A_D_R_A_T_I_C___A_T_T_E_N_U_A_T_I_O_N: _P_a_r_a_m_s returns a single integer or
              floating-point value representing the quadratic attenuation of
              the light. An integer value, when requested, is computed by
              rounding the internal floating-point representation to the
              nearest integer. The initial value is 0.

              See external documentation.

       ggeettLLiigghhttiivv((LLiigghhtt,, PPnnaammee)) -->> {{iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(())}}

              Types:

                 Light = enum()
                 Pname = enum()

              See ggeettLLiigghhttffvv//22

       lliigghhttMMooddeellff((PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Pname = enum()
                 Param = float()

              Set the lighting model parameters

              _g_l_:_l_i_g_h_t_M_o_d_e_l sets the lighting model parameter. _P_n_a_m_e names a
              parameter and _P_a_r_a_m_s gives the new value. There are three
              lighting model parameters:

              _?_G_L___L_I_G_H_T___M_O_D_E_L___A_M_B_I_E_N_T: _P_a_r_a_m_s contains four integer or
              floating-point values that specify the ambient RGBA intensity of
              the entire scene. Integer values are mapped linearly such that
              the most positive representable value maps to 1.0, and the most
              negative representable value maps to -1.0. Floating-point values
              are mapped directly. Neither integer nor floating-point values
              are clamped. The initial ambient scene intensity is (0.2, 0.2,
              0.2, 1.0).

              _?_G_L___L_I_G_H_T___M_O_D_E_L___C_O_L_O_R___C_O_N_T_R_O_L: _P_a_r_a_m_s must be either
              _?_G_L___S_E_P_A_R_A_T_E___S_P_E_C_U_L_A_R___C_O_L_O_R or _?_G_L___S_I_N_G_L_E___C_O_L_O_R.
              _?_G_L___S_I_N_G_L_E___C_O_L_O_R specifies that a single color is generated from
              the lighting computation for a vertex.
              _?_G_L___S_E_P_A_R_A_T_E___S_P_E_C_U_L_A_R___C_O_L_O_R specifies that the specular color
              computation of lighting be stored separately from the remainder
              of the lighting computation. The specular color is summed into
              the generated fragment's color after the application of texture
              mapping (if enabled). The initial value is _?_G_L___S_I_N_G_L_E___C_O_L_O_R.

              _?_G_L___L_I_G_H_T___M_O_D_E_L___L_O_C_A_L___V_I_E_W_E_R: _P_a_r_a_m_s is a single integer or
              floating-point value that specifies how specular reflection
              angles are computed. If _P_a_r_a_m_s is 0 (or 0.0), specular
              reflection angles take the view direction to be parallel to and
              in the direction of the -_z axis, regardless of the location of
              the vertex in eye coordinates. Otherwise, specular reflections
              are computed from the origin of the eye coordinate system. The
              initial value is 0.

              _?_G_L___L_I_G_H_T___M_O_D_E_L___T_W_O___S_I_D_E: _P_a_r_a_m_s is a single integer or
              floating-point value that specifies whether one- or two-sided
              lighting calculations are done for polygons. It has no effect on
              the lighting calculations for points, lines, or bitmaps. If
              _P_a_r_a_m_s is 0 (or 0.0), one-sided lighting is specified, and only
              the _f_r_o_n_t material parameters are used in the lighting equation.
              Otherwise, two-sided lighting is specified. In this case,
              vertices of back-facing polygons are lighted using the _b_a_c_k
              material parameters and have their normals reversed before the
              lighting equation is evaluated. Vertices of front-facing
              polygons are always lighted using the _f_r_o_n_t material parameters,
              with no change to their normals. The initial value is 0.

              In RGBA mode, the lighted color of a vertex is the sum of the
              material emission intensity, the product of the material ambient
              reflectance and the lighting model full-scene ambient intensity,
              and the contribution of each enabled light source. Each light
              source contributes the sum of three terms: ambient, diffuse, and
              specular. The ambient light source contribution is the product
              of the material ambient reflectance and the light's ambient
              intensity. The diffuse light source contribution is the product
              of the material diffuse reflectance, the light's diffuse
              intensity, and the dot product of the vertex's normal with the
              normalized vector from the vertex to the light source. The
              specular light source contribution is the product of the
              material specular reflectance, the light's specular intensity,
              and the dot product of the normalized vertex-to-eye and vertex-
              to-light vectors, raised to the power of the shininess of the
              material. All three light source contributions are attenuated
              equally based on the distance from the vertex to the light
              source and on light source direction, spread exponent, and
              spread cutoff angle. All dot products are replaced with 0 if
              they evaluate to a negative value.

              The alpha component of the resulting lighted color is set to the
              alpha value of the material diffuse reflectance.

              In color index mode, the value of the lighted index of a vertex
              ranges from the ambient to the specular values passed to
              ggll::mmaatteerriiaallff//33 using _?_G_L___C_O_L_O_R___I_N_D_E_X_E_S. Diffuse and specular
              coefficients, computed with a (.30, .59, .11) weighting of the
              lights' colors, the shininess of the material, and the same
              reflection and attenuation equations as in the RGBA case,
              determine how much above ambient the resulting index is.

              See external documentation.

       lliigghhttMMooddeellii((PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Pname = enum()
                 Param = integer()

              See lliigghhttMMooddeellff//22

       lliigghhttMMooddeellffvv((PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Pname = enum()
                 Params = {float()}

              See lliigghhttMMooddeellff//22

       lliigghhttMMooddeelliivv((PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Pname = enum()
                 Params = {integer()}

              See lliigghhttMMooddeellff//22

       mmaatteerriiaallff((FFaaccee,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Face = enum()
                 Pname = enum()
                 Param = float()

              Specify material parameters for the lighting model

              _g_l_:_m_a_t_e_r_i_a_l assigns values to material parameters. There are two
              matched sets of material parameters. One, the _f_r_o_n_t_-_f_a_c_i_n_g set,
              is used to shade points, lines, bitmaps, and all polygons (when
              two-sided lighting is disabled), or just front-facing polygons
              (when two-sided lighting is enabled). The other set, _b_a_c_k_-
              _f_a_c_i_n_g, is used to shade back-facing polygons only when two-
              sided lighting is enabled. Refer to the ggll::lliigghhttMMooddeellff//22
              reference page for details concerning one- and two-sided
              lighting calculations.

              _g_l_:_m_a_t_e_r_i_a_l takes three arguments. The first, _F_a_c_e , specifies
              whether the _?_G_L___F_R_O_N_T materials, the _?_G_L___B_A_C_K materials, or both
              _?_G_L___F_R_O_N_T___A_N_D___B_A_C_K materials will be modified. The second, _P_n_a_m_e
              , specifies which of several parameters in one or both sets will
              be modified. The third, _P_a_r_a_m_s , specifies what value or values
              will be assigned to the specified parameter.

              Material parameters are used in the lighting equation that is
              optionally applied to each vertex. The equation is discussed in
              the ggll::lliigghhttMMooddeellff//22 reference page. The parameters that can be
              specified using _g_l_:_m_a_t_e_r_i_a_l, and their interpretations by the
              lighting equation, are as follows:

              _?_G_L___A_M_B_I_E_N_T: _P_a_r_a_m_s contains four integer or floating-point
              values that specify the ambient RGBA reflectance of the
              material. Integer values are mapped linearly such that the most
              positive representable value maps to 1.0, and the most negative
              representable value maps to -1.0. Floating-point values are
              mapped directly. Neither integer nor floating-point values are
              clamped. The initial ambient reflectance for both front- and
              back-facing materials is (0.2, 0.2, 0.2, 1.0).

              _?_G_L___D_I_F_F_U_S_E: _P_a_r_a_m_s contains four integer or floating-point
              values that specify the diffuse RGBA reflectance of the
              material. Integer values are mapped linearly such that the most
              positive representable value maps to 1.0, and the most negative
              representable value maps to -1.0. Floating-point values are
              mapped directly. Neither integer nor floating-point values are
              clamped. The initial diffuse reflectance for both front- and
              back-facing materials is (0.8, 0.8, 0.8, 1.0).

              _?_G_L___S_P_E_C_U_L_A_R: _P_a_r_a_m_s contains four integer or floating-point
              values that specify the specular RGBA reflectance of the
              material. Integer values are mapped linearly such that the most
              positive representable value maps to 1.0, and the most negative
              representable value maps to -1.0. Floating-point values are
              mapped directly. Neither integer nor floating-point values are
              clamped. The initial specular reflectance for both front- and
              back-facing materials is (0, 0, 0, 1).

              _?_G_L___E_M_I_S_S_I_O_N: _P_a_r_a_m_s contains four integer or floating-point
              values that specify the RGBA emitted light intensity of the
              material. Integer values are mapped linearly such that the most
              positive representable value maps to 1.0, and the most negative
              representable value maps to -1.0. Floating-point values are
              mapped directly. Neither integer nor floating-point values are
              clamped. The initial emission intensity for both front- and
              back-facing materials is (0, 0, 0, 1).

              _?_G_L___S_H_I_N_I_N_E_S_S: _P_a_r_a_m_s is a single integer or floating-point
              value that specifies the RGBA specular exponent of the material.
              Integer and floating-point values are mapped directly. Only
              values in the range [0 128] are accepted. The initial specular
              exponent for both front- and back-facing materials is 0.

              _?_G_L___A_M_B_I_E_N_T___A_N_D___D_I_F_F_U_S_E: Equivalent to calling _g_l_:_m_a_t_e_r_i_a_l twice
              with the same parameter values, once with _?_G_L___A_M_B_I_E_N_T and once
              with _?_G_L___D_I_F_F_U_S_E.

              _?_G_L___C_O_L_O_R___I_N_D_E_X_E_S: _P_a_r_a_m_s contains three integer or floating-
              point values specifying the color indices for ambient, diffuse,
              and specular lighting. These three values, and _?_G_L___S_H_I_N_I_N_E_S_S,
              are the only material values used by the color index mode
              lighting equation. Refer to the ggll::lliigghhttMMooddeellff//22 reference page
              for a discussion of color index lighting.

              See external documentation.

       mmaatteerriiaallii((FFaaccee,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Face = enum()
                 Pname = enum()
                 Param = integer()

              See mmaatteerriiaallff//33

       mmaatteerriiaallffvv((FFaaccee,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Face = enum()
                 Pname = enum()
                 Params = {float()}

              See mmaatteerriiaallff//33

       mmaatteerriiaalliivv((FFaaccee,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Face = enum()
                 Pname = enum()
                 Params = {integer()}

              See mmaatteerriiaallff//33

       ggeettMMaatteerriiaallffvv((FFaaccee,, PPnnaammee)) -->> {{ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(())}}

              Types:

                 Face = enum()
                 Pname = enum()

              Return material parameters

              _g_l_:_g_e_t_M_a_t_e_r_i_a_l returns in _P_a_r_a_m_s the value or values of
              parameter _P_n_a_m_e of material _F_a_c_e . Six parameters are defined:

              _?_G_L___A_M_B_I_E_N_T: _P_a_r_a_m_s returns four integer or floating-point
              values representing the ambient reflectance of the material.
              Integer values, when requested, are linearly mapped from the
              internal floating-point representation such that 1.0 maps to the
              most positive representable integer value, and -1.0 maps to the
              most negative representable integer value. If the internal value
              is outside the range [-1 1], the corresponding integer return
              value is undefined. The initial value is (0.2, 0.2, 0.2, 1.0)

              _?_G_L___D_I_F_F_U_S_E: _P_a_r_a_m_s returns four integer or floating-point
              values representing the diffuse reflectance of the material.
              Integer values, when requested, are linearly mapped from the
              internal floating-point representation such that 1.0 maps to the
              most positive representable integer value, and -1.0 maps to the
              most negative representable integer value. If the internal value
              is outside the range [-1 1], the corresponding integer return
              value is undefined. The initial value is (0.8, 0.8, 0.8, 1.0).

              _?_G_L___S_P_E_C_U_L_A_R: _P_a_r_a_m_s returns four integer or floating-point
              values representing the specular reflectance of the material.
              Integer values, when requested, are linearly mapped from the
              internal floating-point representation such that 1.0 maps to the
              most positive representable integer value, and -1.0 maps to the
              most negative representable integer value. If the internal value
              is outside the range [-1 1], the corresponding integer return
              value is undefined. The initial value is (0, 0, 0, 1).

              _?_G_L___E_M_I_S_S_I_O_N: _P_a_r_a_m_s returns four integer or floating-point
              values representing the emitted light intensity of the material.
              Integer values, when requested, are linearly mapped from the
              internal floating-point representation such that 1.0 maps to the
              most positive representable integer value, and -1.0 maps to the
              most negative representable integer value. If the internal value
              is outside the range [-1 1], the corresponding integer return
              value is undefined. The initial value is (0, 0, 0, 1).

              _?_G_L___S_H_I_N_I_N_E_S_S: _P_a_r_a_m_s returns one integer or floating-point
              value representing the specular exponent of the material.
              Integer values, when requested, are computed by rounding the
              internal floating-point value to the nearest integer value. The
              initial value is 0.

              _?_G_L___C_O_L_O_R___I_N_D_E_X_E_S: _P_a_r_a_m_s returns three integer or floating-
              point values representing the ambient, diffuse, and specular
              indices of the material. These indices are used only for color
              index lighting. (All the other parameters are used only for RGBA
              lighting.) Integer values, when requested, are computed by
              rounding the internal floating-point values to the nearest
              integer values.

              See external documentation.

       ggeettMMaatteerriiaalliivv((FFaaccee,, PPnnaammee)) -->> {{iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(())}}

              Types:

                 Face = enum()
                 Pname = enum()

              See ggeettMMaatteerriiaallffvv//22

       ccoolloorrMMaatteerriiaall((FFaaccee,, MMooddee)) -->> ookk

              Types:

                 Face = enum()
                 Mode = enum()

              Cause a material color to track the current color

              _g_l_:_c_o_l_o_r_M_a_t_e_r_i_a_l specifies which material parameters track the
              current color. When _?_G_L___C_O_L_O_R___M_A_T_E_R_I_A_L is enabled, the material
              parameter or parameters specified by _M_o_d_e , of the material or
              materials specified by _F_a_c_e , track the current color at all
              times.

              To enable and disable _?_G_L___C_O_L_O_R___M_A_T_E_R_I_A_L, call ggll::eennaabbllee//11 and
              ggll::eennaabbllee//11 with argument _?_G_L___C_O_L_O_R___M_A_T_E_R_I_A_L. _?_G_L___C_O_L_O_R___M_A_T_E_R_I_A_L
              is initially disabled.

              See external documentation.

       ppiixxeellZZoooomm((XXffaaccttoorr,, YYffaaccttoorr)) -->> ookk

              Types:

                 Xfactor = float()
                 Yfactor = float()

              Specify the pixel zoom factors

              _g_l_:_p_i_x_e_l_Z_o_o_m specifies values for the x and y zoom factors.
              During the execution of ggll::ddrraawwPPiixxeellss//55 or ggll::ccooppyyPPiixxeellss//55 , if
              ( xr, yr) is the current raster position, and a given element is
              in the mth row and nth column of the pixel rectangle, then
              pixels whose centers are in the rectangle with corners at

              ( xr+n. xfactor, yr+m. yfactor)

              ( xr+(n+1). xfactor, yr+(m+1). yfactor)

              are candidates for replacement. Any pixel whose center lies on
              the bottom or left edge of this rectangular region is also
              modified.

              Pixel zoom factors are not limited to positive values. Negative
              zoom factors reflect the resulting image about the current
              raster position.

              See external documentation.

       ppiixxeellSSttoorreeff((PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Pname = enum()
                 Param = float()

              Set pixel storage modes

              _g_l_:_p_i_x_e_l_S_t_o_r_e sets pixel storage modes that affect the operation
              of subsequent ggll::rreeaaddPPiixxeellss//77 as well as the unpacking of
              texture patterns (see ggll::tteexxIImmaaggee11DD//88 , ggll::tteexxIImmaaggee22DD//99 ,
              ggll::tteexxIImmaaggee33DD//1100 , ggll::tteexxSSuubbIImmaaggee11DD//77 , ggll::tteexxSSuubbIImmaaggee11DD//77 ,
              ggll::tteexxSSuubbIImmaaggee11DD//77 ), ggll::ccoommpprreesssseeddTTeexxIImmaaggee11DD//77 ,
              ggll::ccoommpprreesssseeddTTeexxIImmaaggee22DD//88 , ggll::ccoommpprreesssseeddTTeexxIImmaaggee33DD//99 ,
              ggll::ccoommpprreesssseeddTTeexxSSuubbIImmaaggee11DD//77 , ggll::ccoommpprreesssseeddTTeexxSSuubbIImmaaggee22DD//99 or
              ggll::ccoommpprreesssseeddTTeexxSSuubbIImmaaggee11DD//77 .

              _P_n_a_m_e is a symbolic constant indicating the parameter to be set,
              and _P_a_r_a_m is the new value. Six of the twelve storage parameters
              affect how pixel data is returned to client memory. They are as
              follows:

              _?_G_L___P_A_C_K___S_W_A_P___B_Y_T_E_S: If true, byte ordering for multibyte color
              components, depth components, or stencil indices is reversed.
              That is, if a four-byte component consists of bytes b 0, b 1, b
              2, b 3, it is stored in memory as b 3, b 2, b 1, b 0 if
              _?_G_L___P_A_C_K___S_W_A_P___B_Y_T_E_S is true. _?_G_L___P_A_C_K___S_W_A_P___B_Y_T_E_S has no effect
              on the memory order of components within a pixel, only on the
              order of bytes within components or indices. For example, the
              three components of a _?_G_L___R_G_B format pixel are always stored
              with red first, green second, and blue third, regardless of the
              value of _?_G_L___P_A_C_K___S_W_A_P___B_Y_T_E_S.

              _?_G_L___P_A_C_K___L_S_B___F_I_R_S_T: If true, bits are ordered within a byte from
              least significant to most significant; otherwise, the first bit
              in each byte is the most significant one.

              _?_G_L___P_A_C_K___R_O_W___L_E_N_G_T_H: If greater than 0, _?_G_L___P_A_C_K___R_O_W___L_E_N_G_T_H
              defines the number of pixels in a row. If the first pixel of a
              row is placed at location p in memory, then the location of the
              first pixel of the next row is obtained by skipping

              k={n l(a/s) |(s n l)/a| s>= a s< a)

              components or indices, where n is the number of components or
              indices in a pixel, l is the number of pixels in a row
              (_?_G_L___P_A_C_K___R_O_W___L_E_N_G_T_H if it is greater than 0, the width argument
              to the pixel routine otherwise), a is the value of
              _?_G_L___P_A_C_K___A_L_I_G_N_M_E_N_T , and s is the size, in bytes, of a single
              component (if a< s, then it is as if a= s). In the case of 1-bit
              values, the location of the next row is obtained by skipping

              k= 8 a |(n l)/(8 a)|

              components or indices.

              The word _c_o_m_p_o_n_e_n_t in this description refers to the nonindex
              values red, green, blue, alpha, and depth. Storage format
              _?_G_L___R_G_B, for example, has three components per pixel: first red,
              then green, and finally blue.

              _?_G_L___P_A_C_K___I_M_A_G_E___H_E_I_G_H_T: If greater than 0, _?_G_L___P_A_C_K___I_M_A_G_E___H_E_I_G_H_T
              defines the number of pixels in an image three-dimensional
              texture volume, where _i_m_a_g_e is defined by all pixels sharing the
              same third dimension index. If the first pixel of a row is
              placed at location p in memory, then the location of the first
              pixel of the next row is obtained by skipping

              k={n l h(a/s) |(s n l h)/a| s>= a s< a)

              components or indices, where n is the number of components or
              indices in a pixel, l is the number of pixels in a row
              (_?_G_L___P_A_C_K___R_O_W___L_E_N_G_T_H if it is greater than 0, the width argument
              to ggll::tteexxIImmaaggee33DD//1100 otherwise), h is the number of rows in a
              pixel image (_?_G_L___P_A_C_K___I_M_A_G_E___H_E_I_G_H_T if it is greater than 0, the
              height argument to the ggll::tteexxIImmaaggee33DD//1100 routine otherwise), a is
              the value of _?_G_L___P_A_C_K___A_L_I_G_N_M_E_N_T , and s is the size, in bytes,
              of a single component (if a< s, then it is as if a= s).

              The word _c_o_m_p_o_n_e_n_t in this description refers to the nonindex
              values red, green, blue, alpha, and depth. Storage format
              _?_G_L___R_G_B, for example, has three components per pixel: first red,
              then green, and finally blue.

              _?_G_L___P_A_C_K___S_K_I_P___P_I_X_E_L_S, _?_G_L___P_A_C_K___S_K_I_P___R_O_W_S, and
              _?_G_L___P_A_C_K___S_K_I_P___I_M_A_G_E_S

              These values are provided as a convenience to the programmer;
              they provide no functionality that cannot be duplicated simply
              by incrementing the pointer passed to ggll::rreeaaddPPiixxeellss//77 . Setting
              _?_G_L___P_A_C_K___S_K_I_P___P_I_X_E_L_S to i is equivalent to incrementing the
              pointer by i n components or indices, where n is the number of
              components or indices in each pixel. Setting _?_G_L___P_A_C_K___S_K_I_P___R_O_W_S
              to j is equivalent to incrementing the pointer by j m components
              or indices, where m is the number of components or indices per
              row, as just computed in the _?_G_L___P_A_C_K___R_O_W___L_E_N_G_T_H section.
              Setting _?_G_L___P_A_C_K___S_K_I_P___I_M_A_G_E_S to k is equivalent to incrementing
              the pointer by k p, where p is the number of components or
              indices per image, as computed in the _?_G_L___P_A_C_K___I_M_A_G_E___H_E_I_G_H_T
              section.

              _?_G_L___P_A_C_K___A_L_I_G_N_M_E_N_T: Specifies the alignment requirements for the
              start of each pixel row in memory. The allowable values are 1
              (byte-alignment), 2 (rows aligned to even-numbered bytes), 4
              (word-alignment), and 8 (rows start on double-word boundaries).

              The other six of the twelve storage parameters affect how pixel
              data is read from client memory. These values are significant
              for ggll::tteexxIImmaaggee11DD//88 , ggll::tteexxIImmaaggee22DD//99 , ggll::tteexxIImmaaggee33DD//1100 ,
              ggll::tteexxSSuubbIImmaaggee11DD//77 , ggll::tteexxSSuubbIImmaaggee11DD//77 , and ggll::tteexxSSuubbIImmaaggee11DD//77

              They are as follows:

              _?_G_L___U_N_P_A_C_K___S_W_A_P___B_Y_T_E_S: If true, byte ordering for multibyte
              color components, depth components, or stencil indices is
              reversed. That is, if a four-byte component consists of bytes b
              0, b 1, b 2, b 3, it is taken from memory as b 3, b 2, b 1, b 0
              if _?_G_L___U_N_P_A_C_K___S_W_A_P___B_Y_T_E_S is true. _?_G_L___U_N_P_A_C_K___S_W_A_P___B_Y_T_E_S has no
              effect on the memory order of components within a pixel, only on
              the order of bytes within components or indices. For example,
              the three components of a _?_G_L___R_G_B format pixel are always stored
              with red first, green second, and blue third, regardless of the
              value of _?_G_L___U_N_P_A_C_K___S_W_A_P___B_Y_T_E_S.

              _?_G_L___U_N_P_A_C_K___L_S_B___F_I_R_S_T: If true, bits are ordered within a byte
              from least significant to most significant; otherwise, the first
              bit in each byte is the most significant one.

              _?_G_L___U_N_P_A_C_K___R_O_W___L_E_N_G_T_H: If greater than 0, _?_G_L___U_N_P_A_C_K___R_O_W___L_E_N_G_T_H
              defines the number of pixels in a row. If the first pixel of a
              row is placed at location p in memory, then the location of the
              first pixel of the next row is obtained by skipping

              k={n l(a/s) |(s n l)/a| s>= a s< a)

              components or indices, where n is the number of components or
              indices in a pixel, l is the number of pixels in a row
              (_?_G_L___U_N_P_A_C_K___R_O_W___L_E_N_G_T_H if it is greater than 0, the width
              argument to the pixel routine otherwise), a is the value of
              _?_G_L___U_N_P_A_C_K___A_L_I_G_N_M_E_N_T , and s is the size, in bytes, of a single
              component (if a< s, then it is as if a= s). In the case of 1-bit
              values, the location of the next row is obtained by skipping

              k= 8 a |(n l)/(8 a)|

              components or indices.

              The word _c_o_m_p_o_n_e_n_t in this description refers to the nonindex
              values red, green, blue, alpha, and depth. Storage format
              _?_G_L___R_G_B, for example, has three components per pixel: first red,
              then green, and finally blue.

              _?_G_L___U_N_P_A_C_K___I_M_A_G_E___H_E_I_G_H_T: If greater than 0,
              _?_G_L___U_N_P_A_C_K___I_M_A_G_E___H_E_I_G_H_T defines the number of pixels in an image
              of a three-dimensional texture volume. Where _i_m_a_g_e is defined by
              all pixel sharing the same third dimension index. If the first
              pixel of a row is placed at location p in memory, then the
              location of the first pixel of the next row is obtained by
              skipping

              k={n l h(a/s) |(s n l h)/a| s>= a s< a)

              components or indices, where n is the number of components or
              indices in a pixel, l is the number of pixels in a row
              (_?_G_L___U_N_P_A_C_K___R_O_W___L_E_N_G_T_H if it is greater than 0, the width
              argument to ggll::tteexxIImmaaggee33DD//1100 otherwise), h is the number of rows
              in an image (_?_G_L___U_N_P_A_C_K___I_M_A_G_E___H_E_I_G_H_T if it is greater than 0,
              the height argument to ggll::tteexxIImmaaggee33DD//1100 otherwise), a is the
              value of _?_G_L___U_N_P_A_C_K___A_L_I_G_N_M_E_N_T, and s is the size, in bytes, of a
              single component (if a< s, then it is as if a= s).

              The word _c_o_m_p_o_n_e_n_t in this description refers to the nonindex
              values red, green, blue, alpha, and depth. Storage format
              _?_G_L___R_G_B, for example, has three components per pixel: first red,
              then green, and finally blue.

              _?_G_L___U_N_P_A_C_K___S_K_I_P___P_I_X_E_L_S and _?_G_L___U_N_P_A_C_K___S_K_I_P___R_O_W_S

              These values are provided as a convenience to the programmer;
              they provide no functionality that cannot be duplicated by
              incrementing the pointer passed to ggll::tteexxIImmaaggee11DD//88 ,
              ggll::tteexxIImmaaggee22DD//99 , ggll::tteexxSSuubbIImmaaggee11DD//77 or ggll::tteexxSSuubbIImmaaggee11DD//77 .
              Setting _?_G_L___U_N_P_A_C_K___S_K_I_P___P_I_X_E_L_S to i is equivalent to
              incrementing the pointer by i n components or indices, where n
              is the number of components or indices in each pixel. Setting
              _?_G_L___U_N_P_A_C_K___S_K_I_P___R_O_W_S to j is equivalent to incrementing the
              pointer by j k components or indices, where k is the number of
              components or indices per row, as just computed in the
              _?_G_L___U_N_P_A_C_K___R_O_W___L_E_N_G_T_H section.

              _?_G_L___U_N_P_A_C_K___A_L_I_G_N_M_E_N_T: Specifies the alignment requirements for
              the start of each pixel row in memory. The allowable values are
              1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4
              (word-alignment), and 8 (rows start on double-word boundaries).

              The following table gives the type, initial value, and range of
              valid values for each storage parameter that can be set with
              _g_l_:_p_i_x_e_l_S_t_o_r_e._P_n_a_m_e_T_y_p_e_I_n_i_t_i_a_l _V_a_l_u_e_V_a_l_i_d _R_a_n_g_e
              _?_G_L___P_A_C_K___S_W_A_P___B_Y_T_E_S boolean false true or false
              _?_G_L___P_A_C_K___L_S_B___F_I_R_S_T boolean false true or false
              _?_G_L___P_A_C_K___R_O_W___L_E_N_G_T_H integer 0 [0)
              _?_G_L___P_A_C_K___I_M_A_G_E___H_E_I_G_H_T integer 0 [0)
              _?_G_L___P_A_C_K___S_K_I_P___R_O_W_S integer 0 [0)
              _?_G_L___P_A_C_K___S_K_I_P___P_I_X_E_L_S integer 0 [0)
              _?_G_L___P_A_C_K___S_K_I_P___I_M_A_G_E_S integer 0 [0)
              _?_G_L___P_A_C_K___A_L_I_G_N_M_E_N_T integer 4 1, 2, 4, or 8
              _?_G_L___U_N_P_A_C_K___S_W_A_P___B_Y_T_E_S boolean false true or false
              _?_G_L___U_N_P_A_C_K___L_S_B___F_I_R_S_T boolean false true or false
              _?_G_L___U_N_P_A_C_K___R_O_W___L_E_N_G_T_H integer 0 [0)
              _?_G_L___U_N_P_A_C_K___I_M_A_G_E___H_E_I_G_H_T integer 0 [0)
              _?_G_L___U_N_P_A_C_K___S_K_I_P___R_O_W_S integer 0 [0)
              _?_G_L___U_N_P_A_C_K___S_K_I_P___P_I_X_E_L_S integer 0 [0)
              _?_G_L___U_N_P_A_C_K___S_K_I_P___I_M_A_G_E_S integer 0 [0)
              _?_G_L___U_N_P_A_C_K___A_L_I_G_N_M_E_N_T integer 4 1, 2, 4, or 8


              _g_l_:_p_i_x_e_l_S_t_o_r_e_f can be used to set any pixel store parameter. If
              the parameter type is boolean, then if _P_a_r_a_m is 0, the parameter
              is false; otherwise it is set to true. If _P_n_a_m_e is a integer
              type parameter, _P_a_r_a_m is rounded to the nearest integer.

              Likewise, _g_l_:_p_i_x_e_l_S_t_o_r_e_i can also be used to set any of the
              pixel store parameters. Boolean parameters are set to false if
              _P_a_r_a_m is 0 and true otherwise.

              See external documentation.

       ppiixxeellSSttoorreeii((PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Pname = enum()
                 Param = integer()

              See ppiixxeellSSttoorreeff//22

       ppiixxeellTTrraannssffeerrff((PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Pname = enum()
                 Param = float()

              Set pixel transfer modes

              _g_l_:_p_i_x_e_l_T_r_a_n_s_f_e_r sets pixel transfer modes that affect the
              operation of subsequent ggll::ccooppyyPPiixxeellss//55 , ggll::ccooppyyTTeexxIImmaaggee11DD//77 ,
              ggll::ccooppyyTTeexxIImmaaggee22DD//88 , ggll::ccooppyyTTeexxSSuubbIImmaaggee11DD//66 ,
              ggll::ccooppyyTTeexxSSuubbIImmaaggee22DD//88 , ggll::ccooppyyTTeexxSSuubbIImmaaggee33DD//99 ,
              ggll::ddrraawwPPiixxeellss//55 , ggll::rreeaaddPPiixxeellss//77 , ggll::tteexxIImmaaggee11DD//88 ,
              ggll::tteexxIImmaaggee22DD//99 , ggll::tteexxIImmaaggee33DD//1100 , ggll::tteexxSSuubbIImmaaggee11DD//77 ,
              ggll::tteexxSSuubbIImmaaggee11DD//77 , and ggll::tteexxSSuubbIImmaaggee11DD//77 commands.
              Additionally, if the ARB_imaging subset is supported, the
              routines ggll::ccoolloorrTTaabbllee//66 , ggll::ccoolloorrSSuubbTTaabbllee//66 ,
              ggll::ccoonnvvoolluuttiioonnFFiilltteerr11DD//66 , ggll::ccoonnvvoolluuttiioonnFFiilltteerr22DD//77 ,
              ggll::hhiissttooggrraamm//44 , ggll::mmiinnmmaaxx//33 , and ggll::sseeppaarraabblleeFFiilltteerr22DD//88 are
              also affected. The algorithms that are specified by pixel
              transfer modes operate on pixels after they are read from the
              frame buffer ( ggll::ccooppyyPPiixxeellss//55 ggll::ccooppyyTTeexxIImmaaggee11DD//77 ,
              ggll::ccooppyyTTeexxIImmaaggee22DD//88 , ggll::ccooppyyTTeexxSSuubbIImmaaggee11DD//66 ,
              ggll::ccooppyyTTeexxSSuubbIImmaaggee22DD//88 , ggll::ccooppyyTTeexxSSuubbIImmaaggee33DD//99 , and
              ggll::rreeaaddPPiixxeellss//77 ), or unpacked from client memory (
              ggll::ddrraawwPPiixxeellss//55 , ggll::tteexxIImmaaggee11DD//88 , ggll::tteexxIImmaaggee22DD//99 ,
              ggll::tteexxIImmaaggee33DD//1100 , ggll::tteexxSSuubbIImmaaggee11DD//77 , ggll::tteexxSSuubbIImmaaggee11DD//77 , and
              ggll::tteexxSSuubbIImmaaggee11DD//77 ). Pixel transfer operations happen in the
              same order, and in the same manner, regardless of the command
              that resulted in the pixel operation. Pixel storage modes (see
              ggll::ppiixxeellSSttoorreeff//22 ) control the unpacking of pixels being read
              from client memory and the packing of pixels being written back
              into client memory.

              Pixel transfer operations handle four fundamental pixel types:
              _c_o_l_o_r, _c_o_l_o_r _i_n_d_e_x , _d_e_p_t_h, and _s_t_e_n_c_i_l. _C_o_l_o_r pixels consist of
              four floating-point values with unspecified mantissa and
              exponent sizes, scaled such that 0 represents zero intensity and
              1 represents full intensity. _C_o_l_o_r _i_n_d_i_c_e_s comprise a single
              fixed-point value, with unspecified precision to the right of
              the binary point. _D_e_p_t_h pixels comprise a single floating-point
              value, with unspecified mantissa and exponent sizes, scaled such
              that 0.0 represents the minimum depth buffer value, and 1.0
              represents the maximum depth buffer value. Finally, _s_t_e_n_c_i_l
              pixels comprise a single fixed-point value, with unspecified
              precision to the right of the binary point.

              The pixel transfer operations performed on the four basic pixel
              types are as follows:

              _C_o_l_o_r: Each of the four color components is multiplied by a
              scale factor, then added to a bias factor. That is, the red
              component is multiplied by _?_G_L___R_E_D___S_C_A_L_E, then added to
              _?_G_L___R_E_D___B_I_A_S; the green component is multiplied by
              _?_G_L___G_R_E_E_N___S_C_A_L_E , then added to _?_G_L___G_R_E_E_N___B_I_A_S; the blue
              component is multiplied by _?_G_L___B_L_U_E___S_C_A_L_E , then added to
              _?_G_L___B_L_U_E___B_I_A_S; and the alpha component is multiplied by
              _?_G_L___A_L_P_H_A___S_C_A_L_E , then added to _?_G_L___A_L_P_H_A___B_I_A_S. After all four
              color components are scaled and biased, each is clamped to the
              range [0 1]. All color, scale, and bias values are specified
              with _g_l_:_p_i_x_e_l_T_r_a_n_s_f_e_r.

              If _?_G_L___M_A_P___C_O_L_O_R is true, each color component is scaled by the
              size of the corresponding color-to-color map, then replaced by
              the contents of that map indexed by the scaled component. That
              is, the red component is scaled by _?_G_L___P_I_X_E_L___M_A_P___R___T_O___R___S_I_Z_E,
              then replaced by the contents of _?_G_L___P_I_X_E_L___M_A_P___R___T_O___R indexed by
              itself. The green component is scaled by
              _?_G_L___P_I_X_E_L___M_A_P___G___T_O___G___S_I_Z_E, then replaced by the contents of
              _?_G_L___P_I_X_E_L___M_A_P___G___T_O___G indexed by itself. The blue component is
              scaled by _?_G_L___P_I_X_E_L___M_A_P___B___T_O___B___S_I_Z_E, then replaced by the
              contents of _?_G_L___P_I_X_E_L___M_A_P___B___T_O___B indexed by itself. And the
              alpha component is scaled by _?_G_L___P_I_X_E_L___M_A_P___A___T_O___A___S_I_Z_E, then
              replaced by the contents of _?_G_L___P_I_X_E_L___M_A_P___A___T_O___A indexed by
              itself. All components taken from the maps are then clamped to
              the range [0 1]. _?_G_L___M_A_P___C_O_L_O_R is specified with
              _g_l_:_p_i_x_e_l_T_r_a_n_s_f_e_r. The contents of the various maps are specified
              with ggll::ppiixxeellMMaappffvv//33 .

              If the ARB_imaging extension is supported, each of the four
              color components may be scaled and biased after transformation
              by the color matrix. That is, the red component is multiplied by
              _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___R_E_D___S_C_A_L_E, then added to
              _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___R_E_D___B_I_A_S ; the green component is
              multiplied by _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___G_R_E_E_N___S_C_A_L_E, then added to
              _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___G_R_E_E_N___B_I_A_S; the blue component is
              multiplied by _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___B_L_U_E___S_C_A_L_E , then added to
              _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___B_L_U_E___B_I_A_S; and the alpha component is
              multiplied by _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___A_L_P_H_A___S_C_A_L_E, then added to
              _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___A_L_P_H_A___B_I_A_S . After all four color
              components are scaled and biased, each is clamped to the range
              [0 1].

              Similarly, if the ARB_imaging extension is supported, each of
              the four color components may be scaled and biased after
              processing by the enabled convolution filter. That is, the red
              component is multiplied by _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___R_E_D___S_C_A_L_E, then
              added to _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___R_E_D___B_I_A_S ; the green component is
              multiplied by _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___G_R_E_E_N___S_C_A_L_E, then added to
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___G_R_E_E_N___B_I_A_S; the blue component is
              multiplied by _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___B_L_U_E___S_C_A_L_E , then added to
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___B_L_U_E___B_I_A_S; and the alpha component is
              multiplied by _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___A_L_P_H_A___S_C_A_L_E, then added to
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___A_L_P_H_A___B_I_A_S . After all four color
              components are scaled and biased, each is clamped to the range
              [0 1].

              _C_o_l_o_r _i_n_d_e_x: Each color index is shifted left by _?_G_L___I_N_D_E_X___S_H_I_F_T
              bits; any bits beyond the number of fraction bits carried by the
              fixed-point index are filled with zeros. If _?_G_L___I_N_D_E_X___S_H_I_F_T is
              negative, the shift is to the right, again zero filled. Then
              _?_G_L___I_N_D_E_X___O_F_F_S_E_T is added to the index. _?_G_L___I_N_D_E_X___S_H_I_F_T and
              _?_G_L___I_N_D_E_X___O_F_F_S_E_T are specified with _g_l_:_p_i_x_e_l_T_r_a_n_s_f_e_r.

              From this point, operation diverges depending on the required
              format of the resulting pixels. If the resulting pixels are to
              be written to a color index buffer, or if they are being read
              back to client memory in _?_G_L___C_O_L_O_R___I_N_D_E_X format, the pixels
              continue to be treated as indices. If _?_G_L___M_A_P___C_O_L_O_R is true,
              each index is masked by 2 n-1 , where n is
              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___I___S_I_Z_E, then replaced by the contents of
              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___I indexed by the masked value. _?_G_L___M_A_P___C_O_L_O_R
              is specified with _g_l_:_p_i_x_e_l_T_r_a_n_s_f_e_r . The contents of the index
              map is specified with ggll::ppiixxeellMMaappffvv//33 .

              If the resulting pixels are to be written to an RGBA color
              buffer, or if they are read back to client memory in a format
              other than _?_G_L___C_O_L_O_R___I_N_D_E_X, the pixels are converted from
              indices to colors by referencing the four maps
              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___R, _?_G_L___P_I_X_E_L___M_A_P___I___T_O___G ,
              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___B, and _?_G_L___P_I_X_E_L___M_A_P___I___T_O___A. Before being
              dereferenced, the index is masked by 2 n-1, where n is
              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___R___S_I_Z_E for the red map,
              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___G___S_I_Z_E for the green map,
              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___B___S_I_Z_E for the blue map, and
              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___A___S_I_Z_E for the alpha map. All components
              taken from the maps are then clamped to the range [0 1]. The
              contents of the four maps is specified with ggll::ppiixxeellMMaappffvv//33 .

              _D_e_p_t_h: Each depth value is multiplied by _?_G_L___D_E_P_T_H___S_C_A_L_E, added
              to _?_G_L___D_E_P_T_H___B_I_A_S , then clamped to the range [0 1].

              _S_t_e_n_c_i_l: Each index is shifted _?_G_L___I_N_D_E_X___S_H_I_F_T bits just as a
              color index is, then added to _?_G_L___I_N_D_E_X___O_F_F_S_E_T. If
              _?_G_L___M_A_P___S_T_E_N_C_I_L is true, each index is masked by 2 n-1, where n
              is _?_G_L___P_I_X_E_L___M_A_P___S___T_O___S___S_I_Z_E, then replaced by the contents of
              _?_G_L___P_I_X_E_L___M_A_P___S___T_O___S indexed by the masked value.

              The following table gives the type, initial value, and range of
              valid values for each of the pixel transfer parameters that are
              set with _g_l_:_p_i_x_e_l_T_r_a_n_s_f_e_r._P_n_a_m_e_T_y_p_e_I_n_i_t_i_a_l _V_a_l_u_e_V_a_l_i_d _R_a_n_g_e
              _?_G_L___M_A_P___C_O_L_O_R boolean false true/false
              _?_G_L___M_A_P___S_T_E_N_C_I_L boolean false true/false
              _?_G_L___I_N_D_E_X___S_H_I_F_T integer 0 (-)
              _?_G_L___I_N_D_E_X___O_F_F_S_E_T integer 0 (-)
              _?_G_L___R_E_D___S_C_A_L_E float 1 (-)
              _?_G_L___G_R_E_E_N___S_C_A_L_E float 1 (-)
              _?_G_L___B_L_U_E___S_C_A_L_E float 1 (-)
              _?_G_L___A_L_P_H_A___S_C_A_L_E float 1 (-)
              _?_G_L___D_E_P_T_H___S_C_A_L_E float 1 (-)
              _?_G_L___R_E_D___B_I_A_S float 0 (-)
              _?_G_L___G_R_E_E_N___B_I_A_S float 0 (-)
              _?_G_L___B_L_U_E___B_I_A_S float 0 (-)
              _?_G_L___A_L_P_H_A___B_I_A_S float 0 (-)
              _?_G_L___D_E_P_T_H___B_I_A_S float 0 (-)
              _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___R_E_D___S_C_A_L_E float 1 (-)
              _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___G_R_E_E_N___S_C_A_L_E float 1 (-)
              _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___B_L_U_E___S_C_A_L_E float 1 (-)
              _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___A_L_P_H_A___S_C_A_L_E float 1 (-)
              _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___R_E_D___B_I_A_S float 0 (-)
              _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___G_R_E_E_N___B_I_A_S float 0 (-)
              _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___B_L_U_E___B_I_A_S float 0 (-)
              _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___A_L_P_H_A___B_I_A_S float 0 (-)
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___R_E_D___S_C_A_L_E float 1 (-)
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___G_R_E_E_N___S_C_A_L_E float 1 (-)
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___B_L_U_E___S_C_A_L_E float 1 (-)
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___A_L_P_H_A___S_C_A_L_E float 1 (-)
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___R_E_D___B_I_A_S float 0 (-)
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___G_R_E_E_N___B_I_A_S float 0 (-)
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___B_L_U_E___B_I_A_S float 0 (-)
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___A_L_P_H_A___B_I_A_S float 0 (-)


              _g_l_:_p_i_x_e_l_T_r_a_n_s_f_e_r_f can be used to set any pixel transfer
              parameter. If the parameter type is boolean, 0 implies false and
              any other value implies true. If _P_n_a_m_e is an integer parameter,
              _P_a_r_a_m is rounded to the nearest integer.

              Likewise, _g_l_:_p_i_x_e_l_T_r_a_n_s_f_e_r_i can be used to set any of the pixel
              transfer parameters. Boolean parameters are set to false if
              _P_a_r_a_m is 0 and to true otherwise. _P_a_r_a_m is converted to floating
              point before being assigned to real-valued parameters.

              See external documentation.

       ppiixxeellTTrraannssffeerrii((PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Pname = enum()
                 Param = integer()

              See ppiixxeellTTrraannssffeerrff//22

       ppiixxeellMMaappffvv((MMaapp,, MMaappssiizzee,, VVaalluueess)) -->> ookk

              Types:

                 Map = enum()
                 Mapsize = integer()
                 Values = binary()

              Set up pixel transfer maps

              _g_l_:_p_i_x_e_l_M_a_p sets up translation tables, or _m_a_p_s, used by
              ggll::ccooppyyPPiixxeellss//55 , ggll::ccooppyyTTeexxIImmaaggee11DD//77 , ggll::ccooppyyTTeexxIImmaaggee22DD//88 ,
              ggll::ccooppyyTTeexxSSuubbIImmaaggee11DD//66 , ggll::ccooppyyTTeexxSSuubbIImmaaggee22DD//88 ,
              ggll::ccooppyyTTeexxSSuubbIImmaaggee33DD//99 , ggll::ddrraawwPPiixxeellss//55 , ggll::rreeaaddPPiixxeellss//77 ,
              ggll::tteexxIImmaaggee11DD//88 , ggll::tteexxIImmaaggee22DD//99 , ggll::tteexxIImmaaggee33DD//1100 ,
              ggll::tteexxSSuubbIImmaaggee11DD//77 , ggll::tteexxSSuubbIImmaaggee11DD//77 , and ggll::tteexxSSuubbIImmaaggee11DD//77
              . Additionally, if the ARB_imaging subset is supported, the
              routines ggll::ccoolloorrTTaabbllee//66 , ggll::ccoolloorrSSuubbTTaabbllee//66 ,
              ggll::ccoonnvvoolluuttiioonnFFiilltteerr11DD//66 , ggll::ccoonnvvoolluuttiioonnFFiilltteerr22DD//77 ,
              ggll::hhiissttooggrraamm//44 , ggll::mmiinnmmaaxx//33 , and ggll::sseeppaarraabblleeFFiilltteerr22DD//88 . Use
              of these maps is described completely in the ggll::ppiixxeellTTrraannssffeerrff//22
              reference page, and partly in the reference pages for the pixel
              and texture image commands. Only the specification of the maps
              is described in this reference page.

              _M_a_p is a symbolic map name, indicating one of ten maps to set.
              _M_a_p_s_i_z_e specifies the number of entries in the map, and _V_a_l_u_e_s
              is a pointer to an array of _M_a_p_s_i_z_e map values.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              pixel transfer map is specified, _V_a_l_u_e_s is treated as a byte
              offset into the buffer object's data store.

              The ten maps are as follows:

              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___I: Maps color indices to color indices.

              _?_G_L___P_I_X_E_L___M_A_P___S___T_O___S: Maps stencil indices to stencil indices.

              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___R: Maps color indices to red components.

              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___G: Maps color indices to green components.

              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___B: Maps color indices to blue components.

              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___A: Maps color indices to alpha components.

              _?_G_L___P_I_X_E_L___M_A_P___R___T_O___R: Maps red components to red components.

              _?_G_L___P_I_X_E_L___M_A_P___G___T_O___G: Maps green components to green components.

              _?_G_L___P_I_X_E_L___M_A_P___B___T_O___B: Maps blue components to blue components.

              _?_G_L___P_I_X_E_L___M_A_P___A___T_O___A: Maps alpha components to alpha components.

              The entries in a map can be specified as single-precision
              floating-point numbers, unsigned short integers, or unsigned int
              integers. Maps that store color component values (all but
              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___I and _?_G_L___P_I_X_E_L___M_A_P___S___T_O___S) retain their
              values in floating-point format, with unspecified mantissa and
              exponent sizes. Floating-point values specified by _g_l_:_p_i_x_e_l_M_a_p_f_v
              are converted directly to the internal floating-point format of
              these maps, then clamped to the range [0,1]. Unsigned integer
              values specified by _g_l_:_p_i_x_e_l_M_a_p_u_s_v and _g_l_:_p_i_x_e_l_M_a_p_u_i_v are
              converted linearly such that the largest representable integer
              maps to 1.0, and 0 maps to 0.0.

              Maps that store indices, _?_G_L___P_I_X_E_L___M_A_P___I___T_O___I and
              _?_G_L___P_I_X_E_L___M_A_P___S___T_O___S, retain their values in fixed-point format,
              with an unspecified number of bits to the right of the binary
              point. Floating-point values specified by _g_l_:_p_i_x_e_l_M_a_p_f_v are
              converted directly to the internal fixed-point format of these
              maps. Unsigned integer values specified by _g_l_:_p_i_x_e_l_M_a_p_u_s_v and
              _g_l_:_p_i_x_e_l_M_a_p_u_i_v specify integer values, with all 0's to the right
              of the binary point.

              The following table shows the initial sizes and values for each
              of the maps. Maps that are indexed by either color or stencil
              indices must have _M_a_p_s_i_z_e = 2 n for some n or the results are
              undefined. The maximum allowable size for each map depends on
              the implementation and can be determined by calling
              ggll::ggeettBBoooolleeaannvv//11 with argument _?_G_L___M_A_X___P_I_X_E_L___M_A_P___T_A_B_L_E . The
              single maximum applies to all maps; it is at least 32._M_a_p_L_o_o_k_u_p
              _I_n_d_e_x_L_o_o_k_u_p _V_a_l_u_e_I_n_i_t_i_a_l _S_i_z_e_I_n_i_t_i_a_l _V_a_l_u_e
              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___I color index color index 1 0
              _?_G_L___P_I_X_E_L___M_A_P___S___T_O___S stencil index stencil index 1 0
              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___R color index R 1 0
              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___G color index G 1 0
              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___B color index B 1 0
              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___A color index A 1 0
              _?_G_L___P_I_X_E_L___M_A_P___R___T_O___R R R 1 0
              _?_G_L___P_I_X_E_L___M_A_P___G___T_O___G G G 1 0
              _?_G_L___P_I_X_E_L___M_A_P___B___T_O___B B B 1 0
              _?_G_L___P_I_X_E_L___M_A_P___A___T_O___A A A 1 0


              See external documentation.

       ppiixxeellMMaappuuiivv((MMaapp,, MMaappssiizzee,, VVaalluueess)) -->> ookk

              Types:

                 Map = enum()
                 Mapsize = integer()
                 Values = binary()

              See ppiixxeellMMaappffvv//33

       ppiixxeellMMaappuussvv((MMaapp,, MMaappssiizzee,, VVaalluueess)) -->> ookk

              Types:

                 Map = enum()
                 Mapsize = integer()
                 Values = binary()

              See ppiixxeellMMaappffvv//33

       ggeettPPiixxeellMMaappffvv((MMaapp,, VVaalluueess)) -->> ookk

              Types:

                 Map = enum()
                 Values = mem()

              Return the specified pixel map

              See the ggll::ppiixxeellMMaappffvv//33 reference page for a description of the
              acceptable values for the _M_a_p parameter. _g_l_:_g_e_t_P_i_x_e_l_M_a_p returns
              in _D_a_t_a the contents of the pixel map specified in _M_a_p . Pixel
              maps are used during the execution of ggll::rreeaaddPPiixxeellss//77 ,
              ggll::ddrraawwPPiixxeellss//55 , ggll::ccooppyyPPiixxeellss//55 , ggll::tteexxIImmaaggee11DD//88 ,
              ggll::tteexxIImmaaggee22DD//99 , ggll::tteexxIImmaaggee33DD//1100 , ggll::tteexxSSuubbIImmaaggee11DD//77 ,
              ggll::tteexxSSuubbIImmaaggee11DD//77 , ggll::tteexxSSuubbIImmaaggee11DD//77 , ggll::ccooppyyTTeexxIImmaaggee11DD//77 ,
              ggll::ccooppyyTTeexxIImmaaggee22DD//88 , ggll::ccooppyyTTeexxSSuubbIImmaaggee11DD//66 ,
              ggll::ccooppyyTTeexxSSuubbIImmaaggee22DD//88 , and ggll::ccooppyyTTeexxSSuubbIImmaaggee33DD//99 . to map
              color indices, stencil indices, color components, and depth
              components to other values.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              pixel map is requested, _D_a_t_a is treated as a byte offset into
              the buffer object's data store.

              Unsigned integer values, if requested, are linearly mapped from
              the internal fixed or floating-point representation such that
              1.0 maps to the largest representable integer value, and 0.0
              maps to 0. Return unsigned integer values are undefined if the
              map value was not in the range [0,1].

              To determine the required size of _M_a_p , call ggll::ggeettBBoooolleeaannvv//11
              with the appropriate symbolic constant.

              See external documentation.

       ggeettPPiixxeellMMaappuuiivv((MMaapp,, VVaalluueess)) -->> ookk

              Types:

                 Map = enum()
                 Values = mem()

              See ggeettPPiixxeellMMaappffvv//22

       ggeettPPiixxeellMMaappuussvv((MMaapp,, VVaalluueess)) -->> ookk

              Types:

                 Map = enum()
                 Values = mem()

              See ggeettPPiixxeellMMaappffvv//22

       bbiittmmaapp((WWiiddtthh,, HHeeiigghhtt,, XXoorriigg,, YYoorriigg,, XXmmoovvee,, YYmmoovvee,, BBiittmmaapp)) -->> ookk

              Types:

                 Width = integer()
                 Height = integer()
                 Xorig = float()
                 Yorig = float()
                 Xmove = float()
                 Ymove = float()
                 Bitmap = offset() | mem()

              Draw a bitmap

              A bitmap is a binary image. When drawn, the bitmap is positioned
              relative to the current raster position, and frame buffer pixels
              corresponding to 1's in the bitmap are written using the current
              raster color or index. Frame buffer pixels corresponding to 0's
              in the bitmap are not modified.

              _g_l_:_b_i_t_m_a_p takes seven arguments. The first pair specifies the
              width and height of the bitmap image. The second pair specifies
              the location of the bitmap origin relative to the lower left
              corner of the bitmap image. The third pair of arguments
              specifies _x and _y offsets to be added to the current raster
              position after the bitmap has been drawn. The final argument is
              a pointer to the bitmap image itself.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              bitmap image is specified, _B_i_t_m_a_p is treated as a byte offset
              into the buffer object's data store.

              The bitmap image is interpreted like image data for the
              ggll::ddrraawwPPiixxeellss//55 command, with _W_i_d_t_h and _H_e_i_g_h_t corresponding to
              the width and height arguments of that command, and with _t_y_p_e
              set to _?_G_L___B_I_T_M_A_P and _f_o_r_m_a_t set to _?_G_L___C_O_L_O_R___I_N_D_E_X . Modes
              specified using ggll::ppiixxeellSSttoorreeff//22 affect the interpretation of
              bitmap image data; modes specified using ggll::ppiixxeellTTrraannssffeerrff//22 do
              not.

              If the current raster position is invalid, _g_l_:_b_i_t_m_a_p is ignored.
              Otherwise, the lower left corner of the bitmap image is
              positioned at the window coordinates

              x w=|x r-x o|

              y w=|y r-y o|

              where (x r y r) is the raster position and (x o y o) is the
              bitmap origin. Fragments are then generated for each pixel
              corresponding to a 1 (one) in the bitmap image. These fragments
              are generated using the current raster _z coordinate, color or
              color index, and current raster texture coordinates. They are
              then treated just as if they had been generated by a point,
              line, or polygon, including texture mapping, fogging, and all
              per-fragment operations such as alpha and depth testing.

              After the bitmap has been drawn, the _x and _y coordinates of the
              current raster position are offset by _X_m_o_v_e and _Y_m_o_v_e . No
              change is made to the _z coordinate of the current raster
              position, or to the current raster color, texture coordinates,
              or index.

              See external documentation.

       rreeaaddPPiixxeellss((XX,, YY,, WWiiddtthh,, HHeeiigghhtt,, FFoorrmmaatt,, TTyyppee,, PPiixxeellss)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()
                 Width = integer()
                 Height = integer()
                 Format = enum()
                 Type = enum()
                 Pixels = mem()

              Read a block of pixels from the frame buffer

              _g_l_:_r_e_a_d_P_i_x_e_l_s returns pixel data from the frame buffer, starting
              with the pixel whose lower left corner is at location ( _X , _Y ),
              into client memory starting at location _D_a_t_a . Several
              parameters control the processing of the pixel data before it is
              placed into client memory. These parameters are set with
              ggll::ppiixxeellSSttoorreeff//22 . This reference page describes the effects on
              _g_l_:_r_e_a_d_P_i_x_e_l_s of most, but not all of the parameters specified
              by these three commands.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              block of pixels is requested, _D_a_t_a is treated as a byte offset
              into the buffer object's data store rather than a pointer to
              client memory.

              _g_l_:_r_e_a_d_P_i_x_e_l_s returns values from each pixel with lower left
              corner at (x+i y+j) for 0<= i< width and 0<= j< height. This
              pixel is said to be the ith pixel in the jth row. Pixels are
              returned in row order from the lowest to the highest row, left
              to right in each row.

              _F_o_r_m_a_t specifies the format for the returned pixel values;
              accepted values are:

              _?_G_L___S_T_E_N_C_I_L___I_N_D_E_X: Stencil values are read from the stencil
              buffer. Each index is converted to fixed point, shifted left or
              right depending on the value and sign of _?_G_L___I_N_D_E_X___S_H_I_F_T , and
              added to _?_G_L___I_N_D_E_X___O_F_F_S_E_T. If _?_G_L___M_A_P___S_T_E_N_C_I_L is _?_G_L___T_R_U_E,
              indices are replaced by their mappings in the table
              _?_G_L___P_I_X_E_L___M_A_P___S___T_O___S.

              _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T: Depth values are read from the depth
              buffer. Each component is converted to floating point such that
              the minimum depth value maps to 0 and the maximum value maps to
              1. Each component is then multiplied by _?_G_L___D_E_P_T_H___S_C_A_L_E, added
              to _?_G_L___D_E_P_T_H___B_I_A_S , and finally clamped to the range [0 1].

              _?_G_L___D_E_P_T_H___S_T_E_N_C_I_L: Values are taken from both the depth and
              stencil buffers. The _T_y_p_e parameter must be
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___2_4___8 or _?_G_L___F_L_O_A_T___3_2___U_N_S_I_G_N_E_D___I_N_T___2_4___8___R_E_V .

              _?_G_L___R_E_D

              _?_G_L___G_R_E_E_N

              _?_G_L___B_L_U_E

              _?_G_L___R_G_B

              _?_G_L___B_G_R

              _?_G_L___R_G_B_A

              _?_G_L___B_G_R_A: Finally, the indices or components are converted to
              the proper format, as specified by _T_y_p_e . If _F_o_r_m_a_t is
              _?_G_L___S_T_E_N_C_I_L___I_N_D_E_X and _T_y_p_e is not _?_G_L___F_L_O_A_T, each index is
              masked with the mask value given in the following table. If _T_y_p_e
              is _?_G_L___F_L_O_A_T, then each integer index is converted to single-
              precision floating-point format.

              If _F_o_r_m_a_t is _?_G_L___R_E_D, _?_G_L___G_R_E_E_N, _?_G_L___B_L_U_E, _?_G_L___R_G_B, _?_G_L___B_G_R ,
              _?_G_L___R_G_B_A, or _?_G_L___B_G_R_A and _T_y_p_e is not _?_G_L___F_L_O_A_T, each component
              is multiplied by the multiplier shown in the following table. If
              type is _?_G_L___F_L_O_A_T, then each component is passed as is (or
              converted to the client's single-precision floating-point format
              if it is different from the one used by the GL)._T_y_p_e_I_n_d_e_x
              _M_a_s_k_C_o_m_p_o_n_e_n_t _C_o_n_v_e_r_s_i_o_n
              _?_G_L___U_N_S_I_G_N_E_D___B_Y_T_E 2 8-1(2 8-1) c
              _?_G_L___B_Y_T_E 2 7-1((2 8-1) c-1)/2
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T 2 16-1(2 16-1) c
              _?_G_L___S_H_O_R_T 2 15-1((2 16-1) c-1)/2
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T 2 32-1(2 32-1) c
              _?_G_L___I_N_T 2 31-1((2 32-1) c-1)/2
              _?_G_L___H_A_L_F___F_L_O_A_T none c
              _?_G_L___F_L_O_A_T none c
              _?_G_L___U_N_S_I_G_N_E_D___B_Y_T_E___3___3___2 2 N-1(2 N-1) c
              _?_G_L___U_N_S_I_G_N_E_D___B_Y_T_E___2___3___3___R_E_V 2 N-1(2 N-1) c
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___5___6___5 2 N-1 (2 N-1) c
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___5___6___5___R_E_V 2 N-1(2 N-1) c
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___4___4___4___4 2 N-1(2 N-1) c
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___4___4___4___4___R_E_V 2 N-1(2 N-1) c
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___5___5___5___1 2 N-1(2 N-1) c
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___1___5___5___5___R_E_V 2 N-1 (2 N-1) c
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___8___8___8___8 2 N-1(2 N-1) c
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___8___8___8___8___R_E_V 2 N-1(2 N-1) c
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___1_0___1_0___1_0___2 2 N-1(2 N-1) c
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___2___1_0___1_0___1_0___R_E_V 2 N-1(2 N-1) c
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___2_4___8 2 N-1(2 N-1) c
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___1_0_F___1_1_F___1_1_F___R_E_V -- Special
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___5___9___9___9___R_E_V -- Special
              _?_G_L___F_L_O_A_T___3_2___U_N_S_I_G_N_E_D___I_N_T___2_4___8___R_E_V none c (Depth Only)


              Return values are placed in memory as follows. If _F_o_r_m_a_t is
              _?_G_L___S_T_E_N_C_I_L___I_N_D_E_X , _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T, _?_G_L___R_E_D, _?_G_L___G_R_E_E_N, or
              _?_G_L___B_L_U_E, a single value is returned and the data for the ith
              pixel in the jth row is placed in location (j) width+i. _?_G_L___R_G_B
              and _?_G_L___B_G_R return three values, _?_G_L___R_G_B_A and _?_G_L___B_G_R_A return
              four values for each pixel, with all values corresponding to a
              single pixel occupying contiguous space in _D_a_t_a . Storage
              parameters set by ggll::ppiixxeellSSttoorreeff//22 , such as _?_G_L___P_A_C_K___L_S_B___F_I_R_S_T
              and _?_G_L___P_A_C_K___S_W_A_P___B_Y_T_E_S, affect the way that data is written
              into memory. See ggll::ppiixxeellSSttoorreeff//22 for a description.

              See external documentation.

       ddrraawwPPiixxeellss((WWiiddtthh,, HHeeiigghhtt,, FFoorrmmaatt,, TTyyppee,, PPiixxeellss)) -->> ookk

              Types:

                 Width = integer()
                 Height = integer()
                 Format = enum()
                 Type = enum()
                 Pixels = offset() | mem()

              Write a block of pixels to the frame buffer

              _g_l_:_d_r_a_w_P_i_x_e_l_s reads pixel data from memory and writes it into
              the frame buffer relative to the current raster position,
              provided that the raster position is valid. Use ggll::rraasstteerrPPooss22dd//22
              or ggll::wwiinnddoowwPPooss22dd//22 to set the current raster position; use
              ggll::ggeettBBoooolleeaannvv//11 with argument _?_G_L___C_U_R_R_E_N_T___R_A_S_T_E_R___P_O_S_I_T_I_O_N___V_A_L_I_D
              to determine if the specified raster position is valid, and
              ggll::ggeettBBoooolleeaannvv//11 with argument _?_G_L___C_U_R_R_E_N_T___R_A_S_T_E_R___P_O_S_I_T_I_O_N to
              query the raster position.

              Several parameters define the encoding of pixel data in memory
              and control the processing of the pixel data before it is placed
              in the frame buffer. These parameters are set with four
              commands: ggll::ppiixxeellSSttoorreeff//22 , ggll::ppiixxeellTTrraannssffeerrff//22 ,
              ggll::ppiixxeellMMaappffvv//33 , and ggll::ppiixxeellZZoooomm//22 . This reference page
              describes the effects on _g_l_:_d_r_a_w_P_i_x_e_l_s of many, but not all, of
              the parameters specified by these four commands.

              Data is read from _D_a_t_a as a sequence of signed or unsigned
              bytes, signed or unsigned shorts, signed or unsigned integers,
              or single-precision floating-point values, depending on _T_y_p_e .
              When _T_y_p_e is one of _?_G_L___U_N_S_I_G_N_E_D___B_Y_T_E, _?_G_L___B_Y_T_E,
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T , _?_G_L___S_H_O_R_T, _?_G_L___U_N_S_I_G_N_E_D___I_N_T, _?_G_L___I_N_T, or
              _?_G_L___F_L_O_A_T each of these bytes, shorts, integers, or floating-
              point values is interpreted as one color or depth component, or
              one index, depending on _F_o_r_m_a_t . When _T_y_p_e is one of
              _?_G_L___U_N_S_I_G_N_E_D___B_Y_T_E___3___3___2 , _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___5___6___5,
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___4___4___4___4, _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___5___5___5___1 ,
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___8___8___8___8, or _?_G_L___U_N_S_I_G_N_E_D___I_N_T___1_0___1_0___1_0___2, each
              unsigned value is interpreted as containing all the components
              for a single pixel, with the color components arranged according
              to _F_o_r_m_a_t . When _T_y_p_e is one of _?_G_L___U_N_S_I_G_N_E_D___B_Y_T_E___2___3___3___R_E_V ,
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___5___6___5___R_E_V, _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___4___4___4___4___R_E_V,
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___1___5___5___5___R_E_V , _?_G_L___U_N_S_I_G_N_E_D___I_N_T___8___8___8___8___R_E_V,
              or _?_G_L___U_N_S_I_G_N_E_D___I_N_T___2___1_0___1_0___1_0___R_E_V, each unsigned value is
              interpreted as containing all color components, specified by
              _F_o_r_m_a_t , for a single pixel in a reversed order. Indices are
              always treated individually. Color components are treated as
              groups of one, two, three, or four values, again based on _F_o_r_m_a_t
              . Both individual indices and groups of components are referred
              to as pixels. If _T_y_p_e is _?_G_L___B_I_T_M_A_P, the data must be unsigned
              bytes, and _F_o_r_m_a_t must be either _?_G_L___C_O_L_O_R___I_N_D_E_X or
              _?_G_L___S_T_E_N_C_I_L___I_N_D_E_X. Each unsigned byte is treated as eight 1-bit
              pixels, with bit ordering determined by _?_G_L___U_N_P_A_C_K___L_S_B___F_I_R_S_T
              (see ggll::ppiixxeellSSttoorreeff//22 ).

              width*height pixels are read from memory, starting at location
              _D_a_t_a . By default, these pixels are taken from adjacent memory
              locations, except that after all _W_i_d_t_h pixels are read, the read
              pointer is advanced to the next four-byte boundary. The four-
              byte row alignment is specified by ggll::ppiixxeellSSttoorreeff//22 with
              argument _?_G_L___U_N_P_A_C_K___A_L_I_G_N_M_E_N_T , and it can be set to one, two,
              four, or eight bytes. Other pixel store parameters specify
              different read pointer advancements, both before the first pixel
              is read and after all _W_i_d_t_h pixels are read. See the
              ggll::ppiixxeellSSttoorreeff//22 reference page for details on these options.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              block of pixels is specified, _D_a_t_a is treated as a byte offset
              into the buffer object's data store.

              The width*height pixels that are read from memory are each
              operated on in the same way, based on the values of several
              parameters specified by ggll::ppiixxeellTTrraannssffeerrff//22 and ggll::ppiixxeellMMaappffvv//33
              . The details of these operations, as well as the target buffer
              into which the pixels are drawn, are specific to the format of
              the pixels, as specified by _F_o_r_m_a_t . _F_o_r_m_a_t can assume one of 13
              symbolic values:

              _?_G_L___C_O_L_O_R___I_N_D_E_X: Each pixel is a single value, a color index. It
              is converted to fixed-point format, with an unspecified number
              of bits to the right of the binary point, regardless of the
              memory data type. Floating-point values convert to true fixed-
              point values. Signed and unsigned integer data is converted with
              all fraction bits set to 0. Bitmap data convert to either 0 or
              1.

              Each fixed-point index is then shifted left by _?_G_L___I_N_D_E_X___S_H_I_F_T
              bits and added to _?_G_L___I_N_D_E_X___O_F_F_S_E_T . If _?_G_L___I_N_D_E_X___S_H_I_F_T is
              negative, the shift is to the right. In either case, zero bits
              fill otherwise unspecified bit locations in the result.

              If the GL is in RGBA mode, the resulting index is converted to
              an RGBA pixel with the help of the _?_G_L___P_I_X_E_L___M_A_P___I___T_O___R,
              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___G, _?_G_L___P_I_X_E_L___M_A_P___I___T_O___B , and
              _?_G_L___P_I_X_E_L___M_A_P___I___T_O___A tables. If the GL is in color index mode,
              and if _?_G_L___M_A_P___C_O_L_O_R is true, the index is replaced with the
              value that it references in lookup table _?_G_L___P_I_X_E_L___M_A_P___I___T_O___I .
              Whether the lookup replacement of the index is done or not, the
              integer part of the index is then ANDed with 2 b-1, where b is
              the number of bits in a color index buffer.

              The GL then converts the resulting indices or RGBA colors to
              fragments by attaching the current raster position _z coordinate
              and texture coordinates to each pixel, then assigning x and y
              window coordinates to the nth fragment such that x n= x r+n%
              width

              y n= y r+|n/width|

              where (x r y r) is the current raster position. These pixel
              fragments are then treated just like the fragments generated by
              rasterizing points, lines, or polygons. Texture mapping, fog,
              and all the fragment operations are applied before the fragments
              are written to the frame buffer.

              _?_G_L___S_T_E_N_C_I_L___I_N_D_E_X: Each pixel is a single value, a stencil
              index. It is converted to fixed-point format, with an
              unspecified number of bits to the right of the binary point,
              regardless of the memory data type. Floating-point values
              convert to true fixed-point values. Signed and unsigned integer
              data is converted with all fraction bits set to 0. Bitmap data
              convert to either 0 or 1.

              Each fixed-point index is then shifted left by _?_G_L___I_N_D_E_X___S_H_I_F_T
              bits, and added to _?_G_L___I_N_D_E_X___O_F_F_S_E_T. If _?_G_L___I_N_D_E_X___S_H_I_F_T is
              negative, the shift is to the right. In either case, zero bits
              fill otherwise unspecified bit locations in the result. If
              _?_G_L___M_A_P___S_T_E_N_C_I_L is true, the index is replaced with the value
              that it references in lookup table _?_G_L___P_I_X_E_L___M_A_P___S___T_O___S. Whether
              the lookup replacement of the index is done or not, the integer
              part of the index is then ANDed with 2 b-1, where b is the
              number of bits in the stencil buffer. The resulting stencil
              indices are then written to the stencil buffer such that the nth
              index is written to location

              x n= x r+n% width

              y n= y r+|n/width|

              where (x r y r) is the current raster position. Only the pixel
              ownership test, the scissor test, and the stencil writemask
              affect these write operations.

              _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T: Each pixel is a single-depth component.
              Floating-point data is converted directly to an internal
              floating-point format with unspecified precision. Signed integer
              data is mapped linearly to the internal floating-point format
              such that the most positive representable integer value maps to
              1.0, and the most negative representable value maps to -1.0.
              Unsigned integer data is mapped similarly: the largest integer
              value maps to 1.0, and 0 maps to 0.0. The resulting floating-
              point depth value is then multiplied by _?_G_L___D_E_P_T_H___S_C_A_L_E and
              added to _?_G_L___D_E_P_T_H___B_I_A_S. The result is clamped to the range [0
              1].

              The GL then converts the resulting depth components to fragments
              by attaching the current raster position color or color index
              and texture coordinates to each pixel, then assigning x and y
              window coordinates to the nth fragment such that

              x n= x r+n% width

              y n= y r+|n/width|

              where (x r y r) is the current raster position. These pixel
              fragments are then treated just like the fragments generated by
              rasterizing points, lines, or polygons. Texture mapping, fog,
              and all the fragment operations are applied before the fragments
              are written to the frame buffer.

              _?_G_L___R_G_B_A

              _?_G_L___B_G_R_A: Each pixel is a four-component group: For _?_G_L___R_G_B_A,
              the red component is first, followed by green, followed by blue,
              followed by alpha; for _?_G_L___B_G_R_A the order is blue, green, red
              and then alpha. Floating-point values are converted directly to
              an internal floating-point format with unspecified precision.
              Signed integer values are mapped linearly to the internal
              floating-point format such that the most positive representable
              integer value maps to 1.0, and the most negative representable
              value maps to -1.0. (Note that this mapping does not convert 0
              precisely to 0.0.) Unsigned integer data is mapped similarly:
              The largest integer value maps to 1.0, and 0 maps to 0.0. The
              resulting floating-point color values are then multiplied by
              _?_G_L___c___S_C_A_L_E and added to _?_G_L___c___B_I_A_S, where _c is RED, GREEN,
              BLUE, and ALPHA for the respective color components. The results
              are clamped to the range [0 1].

              If _?_G_L___M_A_P___C_O_L_O_R is true, each color component is scaled by the
              size of lookup table _?_G_L___P_I_X_E_L___M_A_P___c___T_O___c, then replaced by the
              value that it references in that table. _c is R, G, B, or A
              respectively.

              The GL then converts the resulting RGBA colors to fragments by
              attaching the current raster position _z coordinate and texture
              coordinates to each pixel, then assigning x and y window
              coordinates to the nth fragment such that

              x n= x r+n% width

              y n= y r+|n/width|

              where (x r y r) is the current raster position. These pixel
              fragments are then treated just like the fragments generated by
              rasterizing points, lines, or polygons. Texture mapping, fog,
              and all the fragment operations are applied before the fragments
              are written to the frame buffer.

              _?_G_L___R_E_D: Each pixel is a single red component. This component is
              converted to the internal floating-point format in the same way
              the red component of an RGBA pixel is. It is then converted to
              an RGBA pixel with green and blue set to 0, and alpha set to 1.
              After this conversion, the pixel is treated as if it had been
              read as an RGBA pixel.

              _?_G_L___G_R_E_E_N: Each pixel is a single green component. This
              component is converted to the internal floating-point format in
              the same way the green component of an RGBA pixel is. It is then
              converted to an RGBA pixel with red and blue set to 0, and alpha
              set to 1. After this conversion, the pixel is treated as if it
              had been read as an RGBA pixel.

              _?_G_L___B_L_U_E: Each pixel is a single blue component. This component
              is converted to the internal floating-point format in the same
              way the blue component of an RGBA pixel is. It is then converted
              to an RGBA pixel with red and green set to 0, and alpha set to
              1. After this conversion, the pixel is treated as if it had been
              read as an RGBA pixel.

              _?_G_L___A_L_P_H_A: Each pixel is a single alpha component. This
              component is converted to the internal floating-point format in
              the same way the alpha component of an RGBA pixel is. It is then
              converted to an RGBA pixel with red, green, and blue set to 0.
              After this conversion, the pixel is treated as if it had been
              read as an RGBA pixel.

              _?_G_L___R_G_B

              _?_G_L___B_G_R: Each pixel is a three-component group: red first,
              followed by green, followed by blue; for _?_G_L___B_G_R, the first
              component is blue, followed by green and then red. Each
              component is converted to the internal floating-point format in
              the same way the red, green, and blue components of an RGBA
              pixel are. The color triple is converted to an RGBA pixel with
              alpha set to 1. After this conversion, the pixel is treated as
              if it had been read as an RGBA pixel.

              _?_G_L___L_U_M_I_N_A_N_C_E: Each pixel is a single luminance component. This
              component is converted to the internal floating-point format in
              the same way the red component of an RGBA pixel is. It is then
              converted to an RGBA pixel with red, green, and blue set to the
              converted luminance value, and alpha set to 1. After this
              conversion, the pixel is treated as if it had been read as an
              RGBA pixel.

              _?_G_L___L_U_M_I_N_A_N_C_E___A_L_P_H_A: Each pixel is a two-component group:
              luminance first, followed by alpha. The two components are
              converted to the internal floating-point format in the same way
              the red component of an RGBA pixel is. They are then converted
              to an RGBA pixel with red, green, and blue set to the converted
              luminance value, and alpha set to the converted alpha value.
              After this conversion, the pixel is treated as if it had been
              read as an RGBA pixel.

              The following table summarizes the meaning of the valid
              constants for the _t_y_p_e parameter:_T_y_p_e_C_o_r_r_e_s_p_o_n_d_i_n_g _T_y_p_e
              _?_G_L___U_N_S_I_G_N_E_D___B_Y_T_E unsigned 8-bit integer
              _?_G_L___B_Y_T_E signed 8-bit integer
              _?_G_L___B_I_T_M_A_P single bits in unsigned 8-bit integers
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T unsigned 16-bit integer
              _?_G_L___S_H_O_R_T signed 16-bit integer
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T unsigned 32-bit integer
              _?_G_L___I_N_T 32-bit integer
              _?_G_L___F_L_O_A_T single-precision floating-point
              _?_G_L___U_N_S_I_G_N_E_D___B_Y_T_E___3___3___2 unsigned 8-bit integer
              _?_G_L___U_N_S_I_G_N_E_D___B_Y_T_E___2___3___3___R_E_V unsigned 8-bit integer with reversed
              component ordering
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___5___6___5 unsigned 16-bit integer
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___5___6___5___R_E_V unsigned 16-bit integer with
              reversed component ordering
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___4___4___4___4 unsigned 16-bit integer
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___4___4___4___4___R_E_V unsigned 16-bit integer with
              reversed component ordering
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___5___5___5___1 unsigned 16-bit integer
              _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T___1___5___5___5___R_E_V unsigned 16-bit integer with
              reversed component ordering
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___8___8___8___8 unsigned 32-bit integer
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___8___8___8___8___R_E_V unsigned 32-bit integer with
              reversed component ordering
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___1_0___1_0___1_0___2 unsigned 32-bit integer
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___2___1_0___1_0___1_0___R_E_V unsigned 32-bit integer with
              reversed component ordering


              The rasterization described so far assumes pixel zoom factors of
              1. If ggll::ppiixxeellZZoooomm//22 is used to change the x and y pixel zoom
              factors, pixels are converted to fragments as follows. If (x r y
              r) is the current raster position, and a given pixel is in the
              nth column and mth row of the pixel rectangle, then fragments
              are generated for pixels whose centers are in the rectangle with
              corners at

              (x r+(zoom x) n y r+(zoom y) m)

              (x r+(zoom x)(n+1) y r+(zoom y)(m+1))

              where zoom x is the value of _?_G_L___Z_O_O_M___X and zoom y is the value
              of _?_G_L___Z_O_O_M___Y .

              See external documentation.

       ccooppyyPPiixxeellss((XX,, YY,, WWiiddtthh,, HHeeiigghhtt,, TTyyppee)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()
                 Width = integer()
                 Height = integer()
                 Type = enum()

              Copy pixels in the frame buffer

              _g_l_:_c_o_p_y_P_i_x_e_l_s copies a screen-aligned rectangle of pixels from
              the specified frame buffer location to a region relative to the
              current raster position. Its operation is well defined only if
              the entire pixel source region is within the exposed portion of
              the window. Results of copies from outside the window, or from
              regions of the window that are not exposed, are hardware
              dependent and undefined.

              _X and _Y specify the window coordinates of the lower left corner
              of the rectangular region to be copied. _W_i_d_t_h and _H_e_i_g_h_t specify
              the dimensions of the rectangular region to be copied. Both
              _W_i_d_t_h and _H_e_i_g_h_t must not be negative.

              Several parameters control the processing of the pixel data
              while it is being copied. These parameters are set with three
              commands: ggll::ppiixxeellTTrraannssffeerrff//22 , ggll::ppiixxeellMMaappffvv//33 , and
              ggll::ppiixxeellZZoooomm//22 . This reference page describes the effects on
              _g_l_:_c_o_p_y_P_i_x_e_l_s of most, but not all, of the parameters specified
              by these three commands.

              _g_l_:_c_o_p_y_P_i_x_e_l_s copies values from each pixel with the lower left-
              hand corner at (x+i y+j) for 0<= i< width and 0<= j< height.
              This pixel is said to be the ith pixel in the jth row. Pixels
              are copied in row order from the lowest to the highest row, left
              to right in each row.

              _T_y_p_e specifies whether color, depth, or stencil data is to be
              copied. The details of the transfer for each data type are as
              follows:

              _?_G_L___C_O_L_O_R: Indices or RGBA colors are read from the buffer
              currently specified as the read source buffer (see
              ggll::rreeaaddBBuuffffeerr//11 ). If the GL is in color index mode, each index
              that is read from this buffer is converted to a fixed-point
              format with an unspecified number of bits to the right of the
              binary point. Each index is then shifted left by _?_G_L___I_N_D_E_X___S_H_I_F_T
              bits, and added to _?_G_L___I_N_D_E_X___O_F_F_S_E_T. If _?_G_L___I_N_D_E_X___S_H_I_F_T is
              negative, the shift is to the right. In either case, zero bits
              fill otherwise unspecified bit locations in the result. If
              _?_G_L___M_A_P___C_O_L_O_R is true, the index is replaced with the value that
              it references in lookup table _?_G_L___P_I_X_E_L___M_A_P___I___T_O___I. Whether the
              lookup replacement of the index is done or not, the integer part
              of the index is then ANDed with 2 b-1, where b is the number of
              bits in a color index buffer.

              If the GL is in RGBA mode, the red, green, blue, and alpha
              components of each pixel that is read are converted to an
              internal floating-point format with unspecified precision. The
              conversion maps the largest representable component value to
              1.0, and component value 0 to 0.0. The resulting floating-point
              color values are then multiplied by _?_G_L___c___S_C_A_L_E and added to
              _?_G_L___c___B_I_A_S, where _c is RED, GREEN, BLUE, and ALPHA for the
              respective color components. The results are clamped to the
              range [0,1]. If _?_G_L___M_A_P___C_O_L_O_R is true, each color component is
              scaled by the size of lookup table _?_G_L___P_I_X_E_L___M_A_P___c___T_O___c , then
              replaced by the value that it references in that table. _c is R,
              G, B, or A.

              If the ARB_imaging extension is supported, the color values may
              be additionally processed by color-table lookups, color-matrix
              transformations, and convolution filters.

              The GL then converts the resulting indices or RGBA colors to
              fragments by attaching the current raster position _z coordinate
              and texture coordinates to each pixel, then assigning window
              coordinates (x r+i y r+j), where (x r y r) is the current raster
              position, and the pixel was the ith pixel in the jth row. These
              pixel fragments are then treated just like the fragments
              generated by rasterizing points, lines, or polygons. Texture
              mapping, fog, and all the fragment operations are applied before
              the fragments are written to the frame buffer.

              _?_G_L___D_E_P_T_H: Depth values are read from the depth buffer and
              converted directly to an internal floating-point format with
              unspecified precision. The resulting floating-point depth value
              is then multiplied by _?_G_L___D_E_P_T_H___S_C_A_L_E and added to
              _?_G_L___D_E_P_T_H___B_I_A_S . The result is clamped to the range [0,1].

              The GL then converts the resulting depth components to fragments
              by attaching the current raster position color or color index
              and texture coordinates to each pixel, then assigning window
              coordinates (x r+i y r+j), where (x r y r) is the current raster
              position, and the pixel was the ith pixel in the jth row. These
              pixel fragments are then treated just like the fragments
              generated by rasterizing points, lines, or polygons. Texture
              mapping, fog, and all the fragment operations are applied before
              the fragments are written to the frame buffer.

              _?_G_L___S_T_E_N_C_I_L: Stencil indices are read from the stencil buffer
              and converted to an internal fixed-point format with an
              unspecified number of bits to the right of the binary point.
              Each fixed-point index is then shifted left by _?_G_L___I_N_D_E_X___S_H_I_F_T
              bits, and added to _?_G_L___I_N_D_E_X___O_F_F_S_E_T. If _?_G_L___I_N_D_E_X___S_H_I_F_T is
              negative, the shift is to the right. In either case, zero bits
              fill otherwise unspecified bit locations in the result. If
              _?_G_L___M_A_P___S_T_E_N_C_I_L is true, the index is replaced with the value
              that it references in lookup table _?_G_L___P_I_X_E_L___M_A_P___S___T_O___S. Whether
              the lookup replacement of the index is done or not, the integer
              part of the index is then ANDed with 2 b-1, where b is the
              number of bits in the stencil buffer. The resulting stencil
              indices are then written to the stencil buffer such that the
              index read from the ith location of the jth row is written to
              location (x r+i y r+j), where (x r y r) is the current raster
              position. Only the pixel ownership test, the scissor test, and
              the stencil writemask affect these write operations.

              The rasterization described thus far assumes pixel zoom factors
              of 1.0. If ggll::ppiixxeellZZoooomm//22 is used to change the x and y pixel
              zoom factors, pixels are converted to fragments as follows. If
              (x r y r) is the current raster position, and a given pixel is
              in the ith location in the jth row of the source pixel
              rectangle, then fragments are generated for pixels whose centers
              are in the rectangle with corners at

              (x r+(zoom x) i y r+(zoom y) j)

              and

              (x r+(zoom x)(i+1) y r+(zoom y)(j+1))

              where zoom x is the value of _?_G_L___Z_O_O_M___X and zoom y is the value
              of _?_G_L___Z_O_O_M___Y .

              See external documentation.

       sstteenncciillFFuunncc((FFuunncc,, RReeff,, MMaasskk)) -->> ookk

              Types:

                 Func = enum()
                 Ref = integer()
                 Mask = integer()

              Set front and back function and reference value for stencil
              testing

              Stenciling, like depth-buffering, enables and disables drawing
              on a per-pixel basis. Stencil planes are first drawn into using
              GL drawing primitives, then geometry and images are rendered
              using the stencil planes to mask out portions of the screen.
              Stenciling is typically used in multipass rendering algorithms
              to achieve special effects, such as decals, outlining, and
              constructive solid geometry rendering.

              The stencil test conditionally eliminates a pixel based on the
              outcome of a comparison between the reference value and the
              value in the stencil buffer. To enable and disable the test,
              call ggll::eennaabbllee//11 and ggll::eennaabbllee//11 with argument _?_G_L___S_T_E_N_C_I_L___T_E_S_T
              . To specify actions based on the outcome of the stencil test,
              call ggll::sstteenncciillOOpp//33 or ggll::sstteenncciillOOppSSeeppaarraattee//44 .

              There can be two separate sets of _F_u_n_c , _R_e_f , and _M_a_s_k
              parameters; one affects back-facing polygons, and the other
              affects front-facing polygons as well as other non-polygon
              primitives. ggll::sstteenncciillFFuunncc//33 sets both front and back stencil
              state to the same values. Use ggll::sstteenncciillFFuunnccSSeeppaarraattee//44 to set
              front and back stencil state to different values.

              _F_u_n_c is a symbolic constant that determines the stencil
              comparison function. It accepts one of eight values, shown in
              the following list. _R_e_f is an integer reference value that is
              used in the stencil comparison. It is clamped to the range [0 2
              n-1], where n is the number of bitplanes in the stencil buffer.
              _M_a_s_k is bitwise ANDed with both the reference value and the
              stored stencil value, with the ANDed values participating in the
              comparison.

              If _s_t_e_n_c_i_l represents the value stored in the corresponding
              stencil buffer location, the following list shows the effect of
              each comparison function that can be specified by _F_u_n_c . Only if
              the comparison succeeds is the pixel passed through to the next
              stage in the rasterization process (see ggll::sstteenncciillOOpp//33 ). All
              tests treat _s_t_e_n_c_i_l values as unsigned integers in the range [0
              2 n-1], where n is the number of bitplanes in the stencil
              buffer.

              The following values are accepted by _F_u_n_c :

              _?_G_L___N_E_V_E_R: Always fails.

              _?_G_L___L_E_S_S: Passes if ( _R_e_f & _M_a_s_k ) < ( _s_t_e_n_c_i_l & _M_a_s_k ).

              _?_G_L___L_E_Q_U_A_L: Passes if ( _R_e_f & _M_a_s_k ) <= ( _s_t_e_n_c_i_l & _M_a_s_k ).

              _?_G_L___G_R_E_A_T_E_R: Passes if ( _R_e_f & _M_a_s_k ) > ( _s_t_e_n_c_i_l & _M_a_s_k ).

              _?_G_L___G_E_Q_U_A_L: Passes if ( _R_e_f & _M_a_s_k ) >= ( _s_t_e_n_c_i_l & _M_a_s_k ).

              _?_G_L___E_Q_U_A_L: Passes if ( _R_e_f & _M_a_s_k ) = ( _s_t_e_n_c_i_l & _M_a_s_k ).

              _?_G_L___N_O_T_E_Q_U_A_L: Passes if ( _R_e_f & _M_a_s_k ) != ( _s_t_e_n_c_i_l & _M_a_s_k ).

              _?_G_L___A_L_W_A_Y_S: Always passes.

              See external documentation.

       sstteenncciillMMaasskk((MMaasskk)) -->> ookk

              Types:

                 Mask = integer()

              Control the front and back writing of individual bits in the
              stencil planes

              _g_l_:_s_t_e_n_c_i_l_M_a_s_k controls the writing of individual bits in the
              stencil planes. The least significant n bits of _M_a_s_k , where n
              is the number of bits in the stencil buffer, specify a mask.
              Where a 1 appears in the mask, it's possible to write to the
              corresponding bit in the stencil buffer. Where a 0 appears, the
              corresponding bit is write-protected. Initially, all bits are
              enabled for writing.

              There can be two separate _M_a_s_k writemasks; one affects back-
              facing polygons, and the other affects front-facing polygons as
              well as other non-polygon primitives. ggll::sstteenncciillMMaasskk//11 sets both
              front and back stencil writemasks to the same values. Use
              ggll::sstteenncciillMMaasskkSSeeppaarraattee//22 to set front and back stencil
              writemasks to different values.

              See external documentation.

       sstteenncciillOOpp((FFaaiill,, ZZffaaiill,, ZZppaassss)) -->> ookk

              Types:

                 Fail = enum()
                 Zfail = enum()
                 Zpass = enum()

              Set front and back stencil test actions

              Stenciling, like depth-buffering, enables and disables drawing
              on a per-pixel basis. You draw into the stencil planes using GL
              drawing primitives, then render geometry and images, using the
              stencil planes to mask out portions of the screen. Stenciling is
              typically used in multipass rendering algorithms to achieve
              special effects, such as decals, outlining, and constructive
              solid geometry rendering.

              The stencil test conditionally eliminates a pixel based on the
              outcome of a comparison between the value in the stencil buffer
              and a reference value. To enable and disable the test, call
              ggll::eennaabbllee//11 and ggll::eennaabbllee//11 with argument _?_G_L___S_T_E_N_C_I_L___T_E_S_T ; to
              control it, call ggll::sstteenncciillFFuunncc//33 or ggll::sstteenncciillFFuunnccSSeeppaarraattee//44 .

              There can be two separate sets of _S_f_a_i_l , _D_p_f_a_i_l , and _D_p_p_a_s_s
              parameters; one affects back-facing polygons, and the other
              affects front-facing polygons as well as other non-polygon
              primitives. ggll::sstteenncciillOOpp//33 sets both front and back stencil
              state to the same values. Use ggll::sstteenncciillOOppSSeeppaarraattee//44 to set
              front and back stencil state to different values.

              _g_l_:_s_t_e_n_c_i_l_O_p takes three arguments that indicate what happens to
              the stored stencil value while stenciling is enabled. If the
              stencil test fails, no change is made to the pixel's color or
              depth buffers, and _S_f_a_i_l specifies what happens to the stencil
              buffer contents. The following eight actions are possible.

              _?_G_L___K_E_E_P: Keeps the current value.

              _?_G_L___Z_E_R_O: Sets the stencil buffer value to 0.

              _?_G_L___R_E_P_L_A_C_E: Sets the stencil buffer value to _r_e_f, as specified
              by ggll::sstteenncciillFFuunncc//33 .

              _?_G_L___I_N_C_R: Increments the current stencil buffer value. Clamps to
              the maximum representable unsigned value.

              _?_G_L___I_N_C_R___W_R_A_P: Increments the current stencil buffer value.
              Wraps stencil buffer value to zero when incrementing the maximum
              representable unsigned value.

              _?_G_L___D_E_C_R: Decrements the current stencil buffer value. Clamps to
              0.

              _?_G_L___D_E_C_R___W_R_A_P: Decrements the current stencil buffer value.
              Wraps stencil buffer value to the maximum representable unsigned
              value when decrementing a stencil buffer value of zero.

              _?_G_L___I_N_V_E_R_T: Bitwise inverts the current stencil buffer value.

              Stencil buffer values are treated as unsigned integers. When
              incremented and decremented, values are clamped to 0 and 2 n-1,
              where n is the value returned by querying _?_G_L___S_T_E_N_C_I_L___B_I_T_S .

              The other two arguments to _g_l_:_s_t_e_n_c_i_l_O_p specify stencil buffer
              actions that depend on whether subsequent depth buffer tests
              succeed ( _D_p_p_a_s_s ) or fail ( _D_p_f_a_i_l ) (see ggll::ddeepptthhFFuunncc//11 ). The
              actions are specified using the same eight symbolic constants as
              _S_f_a_i_l . Note that _D_p_f_a_i_l is ignored when there is no depth
              buffer, or when the depth buffer is not enabled. In these cases,
              _S_f_a_i_l and _D_p_p_a_s_s specify stencil action when the stencil test
              fails and passes, respectively.

              See external documentation.

       cclleeaarrSStteenncciill((SS)) -->> ookk

              Types:

                 S = integer()

              Specify the clear value for the stencil buffer

              _g_l_:_c_l_e_a_r_S_t_e_n_c_i_l specifies the index used by ggll::cclleeaarr//11 to clear
              the stencil buffer. _S is masked with 2 m-1, where m is the
              number of bits in the stencil buffer.

              See external documentation.

       tteexxGGeenndd((CCoooorrdd,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Coord = enum()
                 Pname = enum()
                 Param = float()

              Control the generation of texture coordinates

              _g_l_:_t_e_x_G_e_n selects a texture-coordinate generation function or
              supplies coefficients for one of the functions. _C_o_o_r_d names one
              of the (_s, _t, _r, _q ) texture coordinates; it must be one of the
              symbols _?_G_L___S, _?_G_L___T, _?_G_L___R , or _?_G_L___Q. _P_n_a_m_e must be one of
              three symbolic constants: _?_G_L___T_E_X_T_U_R_E___G_E_N___M_O_D_E ,
              _?_G_L___O_B_J_E_C_T___P_L_A_N_E, or _?_G_L___E_Y_E___P_L_A_N_E. If _P_n_a_m_e is
              _?_G_L___T_E_X_T_U_R_E___G_E_N___M_O_D_E , then _P_a_r_a_m_s chooses a mode, one of
              _?_G_L___O_B_J_E_C_T___L_I_N_E_A_R, _?_G_L___E_Y_E___L_I_N_E_A_R , _?_G_L___S_P_H_E_R_E___M_A_P,
              _?_G_L___N_O_R_M_A_L___M_A_P, or _?_G_L___R_E_F_L_E_C_T_I_O_N___M_A_P. If _P_n_a_m_e is either
              _?_G_L___O_B_J_E_C_T___P_L_A_N_E or _?_G_L___E_Y_E___P_L_A_N_E, _P_a_r_a_m_s contains coefficients
              for the corresponding texture generation function.

              If the texture generation function is _?_G_L___O_B_J_E_C_T___L_I_N_E_A_R, the
              function

              g= p 1*x o+p 2*y o+p 3*z o+p 4*w o

              is used, where g is the value computed for the coordinate named
              in _C_o_o_r_d , p 1, p 2, p 3, and p 4 are the four values supplied
              in _P_a_r_a_m_s , and x o, y o, z o, and w o are the object
              coordinates of the vertex. This function can be used, for
              example, to texture-map terrain using sea level as a reference
              plane (defined by p 1, p 2, p 3, and p 4). The altitude of a
              terrain vertex is computed by the _?_G_L___O_B_J_E_C_T___L_I_N_E_A_R coordinate
              generation function as its distance from sea level; that
              altitude can then be used to index the texture image to map
              white snow onto peaks and green grass onto foothills.

              If the texture generation function is _?_G_L___E_Y_E___L_I_N_E_A_R, the
              function

              g=(p 1)"*x e+(p 2)"*y e+(p 3)"*z e+(p 4)"*w e

              is used, where

              ((p 1)" (p 2)" (p 3)" (p 4)")=(p 1 p 2 p 3 p 4) M -1

              and x e, y e, z e, and w e are the eye coordinates of the
              vertex, p 1, p 2, p 3, and p 4 are the values supplied in _P_a_r_a_m_s
              , and M is the modelview matrix when _g_l_:_t_e_x_G_e_n is invoked. If M
              is poorly conditioned or singular, texture coordinates generated
              by the resulting function may be inaccurate or undefined.

              Note that the values in _P_a_r_a_m_s define a reference plane in eye
              coordinates. The modelview matrix that is applied to them may
              not be the same one in effect when the polygon vertices are
              transformed. This function establishes a field of texture
              coordinates that can produce dynamic contour lines on moving
              objects.

              If the texture generation function is _?_G_L___S_P_H_E_R_E___M_A_P and _C_o_o_r_d
              is either _?_G_L___S or _?_G_L___T, s and t texture coordinates are
              generated as follows. Let _u be the unit vector pointing from the
              origin to the polygon vertex (in eye coordinates). Let _n sup
              prime be the current normal, after transformation to eye
              coordinates. Let

              f=(f x f y f z) T be the reflection vector such that

              f= u-2 n" (n") T u

              Finally, let m= 2 ((f x) 2+(f y) 2+(f z+1) 2). Then the values
              assigned to the s and t texture coordinates are

              s= f x/m+1/2

              t= f y/m+1/2

              To enable or disable a texture-coordinate generation function,
              call ggll::eennaabbllee//11 or ggll::eennaabbllee//11 with one of the symbolic
              texture-coordinate names (_?_G_L___T_E_X_T_U_R_E___G_E_N___S , _?_G_L___T_E_X_T_U_R_E___G_E_N___T,
              _?_G_L___T_E_X_T_U_R_E___G_E_N___R, or _?_G_L___T_E_X_T_U_R_E___G_E_N___Q) as the argument. When
              enabled, the specified texture coordinate is computed according
              to the generating function associated with that coordinate. When
              disabled, subsequent vertices take the specified texture
              coordinate from the current set of texture coordinates.
              Initially, all texture generation functions are set to
              _?_G_L___E_Y_E___L_I_N_E_A_R and are disabled. Both s plane equations are (1,
              0, 0, 0), both t plane equations are (0, 1, 0, 0), and all r and
              q plane equations are (0, 0, 0, 0).

              When the ARB_multitexture extension is supported, _g_l_:_t_e_x_G_e_n sets
              the texture generation parameters for the currently active
              texture unit, selected with ggll::aaccttiivveeTTeexxttuurree//11 .

              See external documentation.

       tteexxGGeennff((CCoooorrdd,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Coord = enum()
                 Pname = enum()
                 Param = float()

              See tteexxGGeenndd//33

       tteexxGGeennii((CCoooorrdd,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Coord = enum()
                 Pname = enum()
                 Param = integer()

              See tteexxGGeenndd//33

       tteexxGGeennddvv((CCoooorrdd,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Coord = enum()
                 Pname = enum()
                 Params = {float()}

              See tteexxGGeenndd//33

       tteexxGGeennffvv((CCoooorrdd,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Coord = enum()
                 Pname = enum()
                 Params = {float()}

              See tteexxGGeenndd//33

       tteexxGGeenniivv((CCoooorrdd,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Coord = enum()
                 Pname = enum()
                 Params = {integer()}

              See tteexxGGeenndd//33

       ggeettTTeexxGGeennddvv((CCoooorrdd,, PPnnaammee)) -->> {{ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(())}}

              Types:

                 Coord = enum()
                 Pname = enum()

              Return texture coordinate generation parameters

              _g_l_:_g_e_t_T_e_x_G_e_n returns in _P_a_r_a_m_s selected parameters of a texture
              coordinate generation function that was specified using
              ggll::tteexxGGeenndd//33 . _C_o_o_r_d names one of the (_s, _t, _r, _q) texture
              coordinates, using the symbolic constant _?_G_L___S, _?_G_L___T, _?_G_L___R, or
              _?_G_L___Q.

              _P_n_a_m_e specifies one of three symbolic names:

              _?_G_L___T_E_X_T_U_R_E___G_E_N___M_O_D_E: _P_a_r_a_m_s returns the single-valued texture
              generation function, a symbolic constant. The initial value is
              _?_G_L___E_Y_E___L_I_N_E_A_R.

              _?_G_L___O_B_J_E_C_T___P_L_A_N_E: _P_a_r_a_m_s returns the four plane equation
              coefficients that specify object linear-coordinate generation.
              Integer values, when requested, are mapped directly from the
              internal floating-point representation.

              _?_G_L___E_Y_E___P_L_A_N_E: _P_a_r_a_m_s returns the four plane equation
              coefficients that specify eye linear-coordinate generation.
              Integer values, when requested, are mapped directly from the
              internal floating-point representation. The returned values are
              those maintained in eye coordinates. They are not equal to the
              values specified using ggll::tteexxGGeenndd//33 , unless the modelview
              matrix was identity when ggll::tteexxGGeenndd//33 was called.

              See external documentation.

       ggeettTTeexxGGeennffvv((CCoooorrdd,, PPnnaammee)) -->> {{ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(())}}

              Types:

                 Coord = enum()
                 Pname = enum()

              See ggeettTTeexxGGeennddvv//22

       ggeettTTeexxGGeenniivv((CCoooorrdd,, PPnnaammee)) -->> {{iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(())}}

              Types:

                 Coord = enum()
                 Pname = enum()

              See ggeettTTeexxGGeennddvv//22

       tteexxEEnnvvff((TTaarrggeett,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Target = enum()
                 Pname = enum()
                 Param = float()

              glTexEnvf

              See external documentation.

       tteexxEEnnvvii((TTaarrggeett,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Target = enum()
                 Pname = enum()
                 Param = integer()

              glTexEnvi

              See external documentation.

       tteexxEEnnvvffvv((TTaarrggeett,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Target = enum()
                 Pname = enum()
                 Params = {float()}

              Set texture environment parameters

              A texture environment specifies how texture values are
              interpreted when a fragment is textured. When _T_a_r_g_e_t is
              _?_G_L___T_E_X_T_U_R_E___F_I_L_T_E_R___C_O_N_T_R_O_L, _P_n_a_m_e must be _?_G_L___T_E_X_T_U_R_E___L_O_D___B_I_A_S .
              When _T_a_r_g_e_t is _?_G_L___T_E_X_T_U_R_E___E_N_V, _P_n_a_m_e can be
              _?_G_L___T_E_X_T_U_R_E___E_N_V___M_O_D_E , _?_G_L___T_E_X_T_U_R_E___E_N_V___C_O_L_O_R, _?_G_L___C_O_M_B_I_N_E___R_G_B,
              _?_G_L___C_O_M_B_I_N_E___A_L_P_H_A, _?_G_L___R_G_B___S_C_A_L_E , _?_G_L___A_L_P_H_A___S_C_A_L_E,
              _?_G_L___S_R_C_0___R_G_B, _?_G_L___S_R_C_1___R_G_B, _?_G_L___S_R_C_2___R_G_B, _?_G_L___S_R_C_0___A_L_P_H_A ,
              _?_G_L___S_R_C_1___A_L_P_H_A, or _?_G_L___S_R_C_2___A_L_P_H_A.

              If _P_n_a_m_e is _?_G_L___T_E_X_T_U_R_E___E_N_V___M_O_D_E, then _P_a_r_a_m_s is (or points to)
              the symbolic name of a texture function. Six texture functions
              may be specified: _?_G_L___A_D_D , _?_G_L___M_O_D_U_L_A_T_E, _?_G_L___D_E_C_A_L, _?_G_L___B_L_E_N_D,
              _?_G_L___R_E_P_L_A_C_E, or _?_G_L___C_O_M_B_I_N_E .

              The following table shows the correspondence of filtered texture
              values R t, G t, B t, A t, L t, I t to texture source
              components. C s and A s are used by the texture functions
              described below. Texture Base Internal Format C s A s
              _?_G_L___A_L_P_H_A (0, 0, 0) A t
              _?_G_L___L_U_M_I_N_A_N_C_E ( L t, L t, L t ) 1
              _?_G_L___L_U_M_I_N_A_N_C_E___A_L_P_H_A ( L t, L t, L t ) A t
              _?_G_L___I_N_T_E_N_S_I_T_Y ( I t, I t, I t ) I t
              _?_G_L___R_G_B ( R t, G t, B t ) 1
              _?_G_L___R_G_B_A ( R t, G t, B t ) A t


              A texture function acts on the fragment to be textured using the
              texture image value that applies to the fragment (see
              ggll::tteexxPPaarraammeetteerrff//33 ) and produces an RGBA color for that
              fragment. The following table shows how the RGBA color is
              produced for each of the first five texture functions that can
              be chosen. C is a triple of color values (RGB) and A is the
              associated alpha value. RGBA values extracted from a texture
              image are in the range [0,1]. The subscript p refers to the
              color computed from the previous texture stage (or the incoming
              fragment if processing texture stage 0), the subscript s to the
              texture source color, the subscript c to the texture environment
              color, and the subscript v indicates a value produced by the
              texture function. Texture Base Internal Format _?_V_a_l_u_e_?_G_L___R_E_P_L_A_C_E
              Function _?_G_L___M_O_D_U_L_A_T_E Function _?_G_L___D_E_C_A_L Function _?_G_L___B_L_E_N_D
              Function _?_G_L___A_D_D Function
              _?_G_L___A_L_P_H_A C v= C p C p undefined C p C p
               A v= A s A p A s A v= A p A s A p A s
              _?_G_L___L_U_M_I_N_A_N_C_E C v= C s C p C s undefined C p (1-C s)+C c C s C
              p+C s
               (or 1) A v= A p A p A p A p
              _?_G_L___L_U_M_I_N_A_N_C_E___A_L_P_H_A C v= C s C p C s undefined C p (1-C s)+C c C
              s C p+C s
               (or 2) A v= A s A p A s A p A s A p A s
              _?_G_L___I_N_T_E_N_S_I_T_Y C v= C s C p C s undefined C p (1-C s)+C c C s C
              p+C s
               A v= A s A p A s A p (1-A s)+A c A s A p+A s
              _?_G_L___R_G_B C v= C s C p C s C s C p (1-C s)+C c C s C p+C s
               (or 3) A v= A p A p A p A p A p
              _?_G_L___R_G_B_A C v= C s C p C s C p (1-A s)+C s A s C p (1-C s)+C c C
              s C p+C s
               (or 4) A v= A s A p A s A p A p A s A p A s


              If _P_n_a_m_e is _?_G_L___T_E_X_T_U_R_E___E_N_V___M_O_D_E, and _P_a_r_a_m_s is _?_G_L___C_O_M_B_I_N_E, the
              form of the texture function depends on the values of
              _?_G_L___C_O_M_B_I_N_E___R_G_B and _?_G_L___C_O_M_B_I_N_E___A_L_P_H_A .

              The following describes how the texture sources, as specified by
              _?_G_L___S_R_C_0___R_G_B, _?_G_L___S_R_C_1___R_G_B , _?_G_L___S_R_C_2___R_G_B, _?_G_L___S_R_C_0___A_L_P_H_A,
              _?_G_L___S_R_C_1___A_L_P_H_A, and _?_G_L___S_R_C_2___A_L_P_H_A , are combined to produce a
              final texture color. In the following tables, _?_G_L___S_R_C_0___c is
              represented by Arg0, _?_G_L___S_R_C_1___c is represented by Arg1, and
              _?_G_L___S_R_C_2___c is represented by Arg2.

              _?_G_L___C_O_M_B_I_N_E___R_G_B accepts any of _?_G_L___R_E_P_L_A_C_E, _?_G_L___M_O_D_U_L_A_T_E,
              _?_G_L___A_D_D , _?_G_L___A_D_D___S_I_G_N_E_D, _?_G_L___I_N_T_E_R_P_O_L_A_T_E, _?_G_L___S_U_B_T_R_A_C_T,
              _?_G_L___D_O_T_3___R_G_B, or _?_G_L___D_O_T_3___R_G_B_A._?_G_L___C_O_M_B_I_N_E___R_G_B_T_e_x_t_u_r_e _F_u_n_c_t_i_o_n
              _?_G_L___R_E_P_L_A_C_E Arg0
              _?_G_L___M_O_D_U_L_A_T_E Arg0*Arg1
              _?_G_L___A_D_D Arg0+Arg1
              _?_G_L___A_D_D___S_I_G_N_E_D Arg0+Arg1-0.5
              _?_G_L___I_N_T_E_R_P_O_L_A_T_E Arg0*Arg2+Arg1*(1- Arg2)
              _?_G_L___S_U_B_T_R_A_C_T Arg0-Arg1
              _?_G_L___D_O_T_3___R_G_B or _?_G_L___D_O_T_3___R_G_B_A 4*((((Arg0 r)-0.5)*((Arg1
              r)-0.5))+(((Arg0 g)-0.5)*((Arg1 g)-0.5))+(((Arg0 b)-0.5)*((Arg1
              b)-0.5)))


              The scalar results for _?_G_L___D_O_T_3___R_G_B and _?_G_L___D_O_T_3___R_G_B_A are placed
              into each of the 3 (RGB) or 4 (RGBA) components on output.

              Likewise, _?_G_L___C_O_M_B_I_N_E___A_L_P_H_A accepts any of _?_G_L___R_E_P_L_A_C_E,
              _?_G_L___M_O_D_U_L_A_T_E, _?_G_L___A_D_D, _?_G_L___A_D_D___S_I_G_N_E_D, _?_G_L___I_N_T_E_R_P_O_L_A_T_E, or
              _?_G_L___S_U_B_T_R_A_C_T. The following table describes how alpha values are
              combined:_?_G_L___C_O_M_B_I_N_E___A_L_P_H_A_T_e_x_t_u_r_e _F_u_n_c_t_i_o_n
              _?_G_L___R_E_P_L_A_C_E Arg0
              _?_G_L___M_O_D_U_L_A_T_E Arg0*Arg1
              _?_G_L___A_D_D Arg0+Arg1
              _?_G_L___A_D_D___S_I_G_N_E_D Arg0+Arg1-0.5
              _?_G_L___I_N_T_E_R_P_O_L_A_T_E Arg0*Arg2+Arg1*(1- Arg2)
              _?_G_L___S_U_B_T_R_A_C_T Arg0-Arg1


              In the following tables, the value C s represents the color
              sampled from the currently bound texture, C c represents the
              constant texture-environment color, C f represents the primary
              color of the incoming fragment, and C p represents the color
              computed from the previous texture stage or C f if processing
              texture stage 0. Likewise, A s, A c, A f, and A p represent the
              respective alpha values.

              The following table describes the values assigned to Arg0, Arg1,
              and Arg2 based upon the RGB sources and
              operands:_?_G_L___S_R_C_n___R_G_B_?_G_L___O_P_E_R_A_N_D_n___R_G_B_A_r_g_u_m_e_n_t _V_a_l_u_e
              _?_G_L___T_E_X_T_U_R_E_?_G_L___S_R_C___C_O_L_O_R(C s)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___C_O_L_O_R 1-(C s)
              _?_G_L___S_R_C___A_L_P_H_A(A s)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___A_L_P_H_A 1-(A s)
              _?_G_L___T_E_X_T_U_R_E_n_?_G_L___S_R_C___C_O_L_O_R(C s)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___C_O_L_O_R 1-(C s)
              _?_G_L___S_R_C___A_L_P_H_A (A s)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___A_L_P_H_A 1-(A s)
              _?_G_L___C_O_N_S_T_A_N_T_?_G_L___S_R_C___C_O_L_O_R(C c)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___C_O_L_O_R 1-(C c)
              _?_G_L___S_R_C___A_L_P_H_A(A c)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___A_L_P_H_A 1-(A c)
              _?_G_L___P_R_I_M_A_R_Y___C_O_L_O_R_?_G_L___S_R_C___C_O_L_O_R(C f)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___C_O_L_O_R 1-(C f)
              _?_G_L___S_R_C___A_L_P_H_A(A f)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___A_L_P_H_A 1-(A f)
              _?_G_L___P_R_E_V_I_O_U_S_?_G_L___S_R_C___C_O_L_O_R (C p)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___C_O_L_O_R 1-(C p)
              _?_G_L___S_R_C___A_L_P_H_A(A p)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___A_L_P_H_A 1-(A p)


              For _?_G_L___T_E_X_T_U_R_E_n sources, C s and A s represent the color and
              alpha, respectively, produced from texture stage n.

              The follow table describes the values assigned to Arg0, Arg1,
              and Arg2 based upon the alpha sources and
              operands:_?_G_L___S_R_C_n___A_L_P_H_A_?_G_L___O_P_E_R_A_N_D_n___A_L_P_H_A_A_r_g_u_m_e_n_t _V_a_l_u_e
              _?_G_L___T_E_X_T_U_R_E_?_G_L___S_R_C___A_L_P_H_A(A s)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___A_L_P_H_A 1-(A s)
              _?_G_L___T_E_X_T_U_R_E_n_?_G_L___S_R_C___A_L_P_H_A(A s)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___A_L_P_H_A 1-(A s)
              _?_G_L___C_O_N_S_T_A_N_T_?_G_L___S_R_C___A_L_P_H_A(A c)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___A_L_P_H_A 1-(A c)
              _?_G_L___P_R_I_M_A_R_Y___C_O_L_O_R_?_G_L___S_R_C___A_L_P_H_A(A f)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___A_L_P_H_A 1-(A f)
              _?_G_L___P_R_E_V_I_O_U_S_?_G_L___S_R_C___A_L_P_H_A(A p)
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___A_L_P_H_A 1-(A p)


              The RGB and alpha results of the texture function are multipled
              by the values of _?_G_L___R_G_B___S_C_A_L_E and _?_G_L___A_L_P_H_A___S_C_A_L_E,
              respectively, and clamped to the range [0 1].

              If _P_n_a_m_e is _?_G_L___T_E_X_T_U_R_E___E_N_V___C_O_L_O_R, _P_a_r_a_m_s is a pointer to an
              array that holds an RGBA color consisting of four values.
              Integer color components are interpreted linearly such that the
              most positive integer maps to 1.0, and the most negative integer
              maps to -1.0. The values are clamped to the range [0,1] when
              they are specified. C c takes these four values.

              If _P_n_a_m_e is _?_G_L___T_E_X_T_U_R_E___L_O_D___B_I_A_S, the value specified is added
              to the texture level-of-detail parameter, that selects which
              mipmap, or mipmaps depending upon the selected
              _?_G_L___T_E_X_T_U_R_E___M_I_N___F_I_L_T_E_R, will be sampled.

              _?_G_L___T_E_X_T_U_R_E___E_N_V___M_O_D_E defaults to _?_G_L___M_O_D_U_L_A_T_E and
              _?_G_L___T_E_X_T_U_R_E___E_N_V___C_O_L_O_R defaults to (0, 0, 0, 0).

              If _T_a_r_g_e_t is _?_G_L___P_O_I_N_T___S_P_R_I_T_E and _P_n_a_m_e is _?_G_L___C_O_O_R_D___R_E_P_L_A_C_E,
              the boolean value specified is used to either enable or disable
              point sprite texture coordinate replacement. The default value
              is _?_G_L___F_A_L_S_E.

              See external documentation.

       tteexxEEnnvviivv((TTaarrggeett,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Target = enum()
                 Pname = enum()
                 Params = {integer()}

              See tteexxEEnnvvffvv//33

       ggeettTTeexxEEnnvvffvv((TTaarrggeett,, PPnnaammee)) -->> {{ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(())}}

              Types:

                 Target = enum()
                 Pname = enum()

              Return texture environment parameters

              _g_l_:_g_e_t_T_e_x_E_n_v returns in _P_a_r_a_m_s selected values of a texture
              environment that was specified with ggll::tteexxEEnnvvffvv//33 . _T_a_r_g_e_t
              specifies a texture environment.

              When _T_a_r_g_e_t is _?_G_L___T_E_X_T_U_R_E___F_I_L_T_E_R___C_O_N_T_R_O_L, _P_n_a_m_e must be
              _?_G_L___T_E_X_T_U_R_E___L_O_D___B_I_A_S . When _T_a_r_g_e_t is _?_G_L___P_O_I_N_T___S_P_R_I_T_E, _P_n_a_m_e
              must be _?_G_L___C_O_O_R_D___R_E_P_L_A_C_E . When _T_a_r_g_e_t is _?_G_L___T_E_X_T_U_R_E___E_N_V,
              _P_n_a_m_e can be _?_G_L___T_E_X_T_U_R_E___E_N_V___M_O_D_E , _?_G_L___T_E_X_T_U_R_E___E_N_V___C_O_L_O_R,
              _?_G_L___C_O_M_B_I_N_E___R_G_B, _?_G_L___C_O_M_B_I_N_E___A_L_P_H_A, _?_G_L___R_G_B___S_C_A_L_E ,
              _?_G_L___A_L_P_H_A___S_C_A_L_E, _?_G_L___S_R_C_0___R_G_B, _?_G_L___S_R_C_1___R_G_B, _?_G_L___S_R_C_2___R_G_B,
              _?_G_L___S_R_C_0___A_L_P_H_A, _?_G_L___S_R_C_1___A_L_P_H_A, or _?_G_L___S_R_C_2___A_L_P_H_A.

              _P_n_a_m_e names a specific texture environment parameter, as
              follows:

              _?_G_L___T_E_X_T_U_R_E___E_N_V___M_O_D_E: _P_a_r_a_m_s returns the single-valued texture
              environment mode, a symbolic constant. The initial value is
              _?_G_L___M_O_D_U_L_A_T_E.

              _?_G_L___T_E_X_T_U_R_E___E_N_V___C_O_L_O_R: _P_a_r_a_m_s returns four integer or floating-
              point values that are the texture environment color. Integer
              values, when requested, are linearly mapped from the internal
              floating-point representation such that 1.0 maps to the most
              positive representable integer, and -1.0 maps to the most
              negative representable integer. The initial value is (0, 0, 0,
              0).

              _?_G_L___T_E_X_T_U_R_E___L_O_D___B_I_A_S: _P_a_r_a_m_s returns a single floating-point
              value that is the texture level-of-detail bias. The initial
              value is 0.

              _?_G_L___C_O_M_B_I_N_E___R_G_B: _P_a_r_a_m_s returns a single symbolic constant value
              representing the current RGB combine mode. The initial value is
              _?_G_L___M_O_D_U_L_A_T_E.

              _?_G_L___C_O_M_B_I_N_E___A_L_P_H_A: _P_a_r_a_m_s returns a single symbolic constant
              value representing the current alpha combine mode. The initial
              value is _?_G_L___M_O_D_U_L_A_T_E.

              _?_G_L___S_R_C_0___R_G_B: _P_a_r_a_m_s returns a single symbolic constant value
              representing the texture combiner zero's RGB source. The initial
              value is _?_G_L___T_E_X_T_U_R_E.

              _?_G_L___S_R_C_1___R_G_B: _P_a_r_a_m_s returns a single symbolic constant value
              representing the texture combiner one's RGB source. The initial
              value is _?_G_L___P_R_E_V_I_O_U_S.

              _?_G_L___S_R_C_2___R_G_B: _P_a_r_a_m_s returns a single symbolic constant value
              representing the texture combiner two's RGB source. The initial
              value is _?_G_L___C_O_N_S_T_A_N_T.

              _?_G_L___S_R_C_0___A_L_P_H_A: _P_a_r_a_m_s returns a single symbolic constant value
              representing the texture combiner zero's alpha source. The
              initial value is _?_G_L___T_E_X_T_U_R_E.

              _?_G_L___S_R_C_1___A_L_P_H_A: _P_a_r_a_m_s returns a single symbolic constant value
              representing the texture combiner one's alpha source. The
              initial value is _?_G_L___P_R_E_V_I_O_U_S.

              _?_G_L___S_R_C_2___A_L_P_H_A: _P_a_r_a_m_s returns a single symbolic constant value
              representing the texture combiner two's alpha source. The
              initial value is _?_G_L___C_O_N_S_T_A_N_T.

              _?_G_L___O_P_E_R_A_N_D_0___R_G_B: _P_a_r_a_m_s returns a single symbolic constant
              value representing the texture combiner zero's RGB operand. The
              initial value is _?_G_L___S_R_C___C_O_L_O_R.

              _?_G_L___O_P_E_R_A_N_D_1___R_G_B: _P_a_r_a_m_s returns a single symbolic constant
              value representing the texture combiner one's RGB operand. The
              initial value is _?_G_L___S_R_C___C_O_L_O_R.

              _?_G_L___O_P_E_R_A_N_D_2___R_G_B: _P_a_r_a_m_s returns a single symbolic constant
              value representing the texture combiner two's RGB operand. The
              initial value is _?_G_L___S_R_C___A_L_P_H_A.

              _?_G_L___O_P_E_R_A_N_D_0___A_L_P_H_A: _P_a_r_a_m_s returns a single symbolic constant
              value representing the texture combiner zero's alpha operand.
              The initial value is _?_G_L___S_R_C___A_L_P_H_A.

              _?_G_L___O_P_E_R_A_N_D_1___A_L_P_H_A: _P_a_r_a_m_s returns a single symbolic constant
              value representing the texture combiner one's alpha operand. The
              initial value is _?_G_L___S_R_C___A_L_P_H_A.

              _?_G_L___O_P_E_R_A_N_D_2___A_L_P_H_A: _P_a_r_a_m_s returns a single symbolic constant
              value representing the texture combiner two's alpha operand. The
              initial value is _?_G_L___S_R_C___A_L_P_H_A.

              _?_G_L___R_G_B___S_C_A_L_E: _P_a_r_a_m_s returns a single floating-point value
              representing the current RGB texture combiner scaling factor.
              The initial value is 1.0.

              _?_G_L___A_L_P_H_A___S_C_A_L_E: _P_a_r_a_m_s returns a single floating-point value
              representing the current alpha texture combiner scaling factor.
              The initial value is 1.0.

              _?_G_L___C_O_O_R_D___R_E_P_L_A_C_E: _P_a_r_a_m_s returns a single boolean value
              representing the current point sprite texture coordinate
              replacement enable state. The initial value is _?_G_L___F_A_L_S_E .

              See external documentation.

       ggeettTTeexxEEnnvviivv((TTaarrggeett,, PPnnaammee)) -->> {{iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(())}}

              Types:

                 Target = enum()
                 Pname = enum()

              See ggeettTTeexxEEnnvvffvv//22

       tteexxPPaarraammeetteerrff((TTaarrggeett,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Target = enum()
                 Pname = enum()
                 Param = float()

              Set texture parameters

              _g_l_:_t_e_x_P_a_r_a_m_e_t_e_r assigns the value or values in _P_a_r_a_m_s to the
              texture parameter specified as _P_n_a_m_e . _T_a_r_g_e_t defines the target
              texture, either _?_G_L___T_E_X_T_U_R_E___1_D , _?_G_L___T_E_X_T_U_R_E___2_D,
              _?_G_L___T_E_X_T_U_R_E___1_D___A_R_R_A_Y, _?_G_L___T_E_X_T_U_R_E___2_D___A_R_R_A_Y,
              _?_G_L___T_E_X_T_U_R_E___R_E_C_T_A_N_G_L_E , or _?_G_L___T_E_X_T_U_R_E___3_D. The following symbols
              are accepted in _P_n_a_m_e :

              _?_G_L___T_E_X_T_U_R_E___B_A_S_E___L_E_V_E_L: Specifies the index of the lowest
              defined mipmap level. This is an integer value. The initial
              value is 0.

              _?_G_L___T_E_X_T_U_R_E___B_O_R_D_E_R___C_O_L_O_R: The data in _P_a_r_a_m_s specifies four
              values that define the border values that should be used for
              border texels. If a texel is sampled from the border of the
              texture, the values of _?_G_L___T_E_X_T_U_R_E___B_O_R_D_E_R___C_O_L_O_R are interpreted
              as an RGBA color to match the texture's internal format and
              substituted for the non-existent texel data. If the texture
              contains depth components, the first component of
              _?_G_L___T_E_X_T_U_R_E___B_O_R_D_E_R___C_O_L_O_R is interpreted as a depth value. The
              initial value is ( 0.0, 0.0, 0.0, 0.0 ).

              If the values for _?_G_L___T_E_X_T_U_R_E___B_O_R_D_E_R___C_O_L_O_R are specified with
              _g_l_:_t_e_x_P_a_r_a_m_e_t_e_r_I_i_v or _g_l_:_t_e_x_P_a_r_a_m_e_t_e_r_I_u_i_v, the values are stored
              unmodified with an internal data type of integer. If specified
              with _g_l_:_t_e_x_P_a_r_a_m_e_t_e_r_i_v, they are converted to floating point
              with the following equation: f= 2 c+1 2 b-/1. If specified with
              _g_l_:_t_e_x_P_a_r_a_m_e_t_e_r_f_v , they are stored unmodified as floating-point
              values.

              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_A_R_E___F_U_N_C: Specifies the comparison operator used
              when _?_G_L___T_E_X_T_U_R_E___C_O_M_P_A_R_E___M_O_D_E is set to
              _?_G_L___C_O_M_P_A_R_E___R_E_F___T_O___T_E_X_T_U_R_E. Permissible values are:_T_e_x_t_u_r_e
              _C_o_m_p_a_r_i_s_o_n _F_u_n_c_t_i_o_n_C_o_m_p_u_t_e_d _r_e_s_u_l_t
              _?_G_L___L_E_Q_U_A_L result={1.0 0.0 &nbsp;&nbsp; r<=(D t) r>(D t))
              _?_G_L___G_E_Q_U_A_L result={1.0 0.0 &nbsp;&nbsp; r>=(D t) r<(D t))
              _?_G_L___L_E_S_S result={1.0 0.0 &nbsp;&nbsp; r< (D t) r>=(D t))
              _?_G_L___G_R_E_A_T_E_R result={1.0 0.0 &nbsp;&nbsp; r>(D t) r<=(D t))
              _?_G_L___E_Q_U_A_L result={1.0 0.0 &nbsp;&nbsp; r=(D t) r&ne;(D t))
              _?_G_L___N_O_T_E_Q_U_A_L result={1.0 0.0 &nbsp;&nbsp; r&ne;(D t) r=(D t))
              _?_G_L___A_L_W_A_Y_S result= 1.0
              _?_G_L___N_E_V_E_R result= 0.0


              where r is the current interpolated texture coordinate, and D t
              is the depth texture value sampled from the currently bound
              depth texture. result is assigned to the the red channel.

              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_A_R_E___M_O_D_E: Specifies the texture comparison mode
              for currently bound depth textures. That is, a texture whose
              internal format is _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T___* ; see ggll::tteexxIImmaaggee22DD//99 )
              Permissible values are:

              _?_G_L___C_O_M_P_A_R_E___R_E_F___T_O___T_E_X_T_U_R_E: Specifies that the interpolated and
              clamped r texture coordinate should be compared to the value in
              the currently bound depth texture. See the discussion of
              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_A_R_E___F_U_N_C for details of how the comparison is
              evaluated. The result of the comparison is assigned to the red
              channel.

              _?_G_L___N_O_N_E: Specifies that the red channel should be assigned the
              appropriate value from the currently bound depth texture.

              _?_G_L___T_E_X_T_U_R_E___L_O_D___B_I_A_S: _P_a_r_a_m_s specifies a fixed bias value that
              is to be added to the level-of-detail parameter for the texture
              before texture sampling. The specified value is added to the
              shader-supplied bias value (if any) and subsequently clamped
              into the implementation-defined range [( - bias max)(bias max)],
              where bias max is the value of the implementation defined
              constant _?_G_L___M_A_X___T_E_X_T_U_R_E___L_O_D___B_I_A_S. The initial value is 0.0.

              _?_G_L___T_E_X_T_U_R_E___M_I_N___F_I_L_T_E_R: The texture minifying function is used
              whenever the level-of-detail function used when sampling from
              the texture determines that the texture should be minified.
              There are six defined minifying functions. Two of them use
              either the nearest texture elements or a weighted average of
              multiple texture elements to compute the texture value. The
              other four use mipmaps.

              A mipmap is an ordered set of arrays representing the same image
              at progressively lower resolutions. If the texture has
              dimensions 2 n*2 m, there are max(n m)+1 mipmaps. The first
              mipmap is the original texture, with dimensions 2 n*2 m. Each
              subsequent mipmap has dimensions 2(k-1)*2(l-1), where 2 k*2 l
              are the dimensions of the previous mipmap, until either k= 0 or
              l= 0. At that point, subsequent mipmaps have dimension 1*2(l-1)
              or 2(k-1)*1 until the final mipmap, which has dimension 1*1. To
              define the mipmaps, call ggll::tteexxIImmaaggee11DD//88 , ggll::tteexxIImmaaggee22DD//99 ,
              ggll::tteexxIImmaaggee33DD//1100 , ggll::ccooppyyTTeexxIImmaaggee11DD//77 , or ggll::ccooppyyTTeexxIImmaaggee22DD//88
              with the _l_e_v_e_l argument indicating the order of the mipmaps.
              Level 0 is the original texture; level max(n m) is the final 1*1
              mipmap.

              _P_a_r_a_m_s supplies a function for minifying the texture as one of
              the following:

              _?_G_L___N_E_A_R_E_S_T: Returns the value of the texture element that is
              nearest (in Manhattan distance) to the specified texture
              coordinates.

              _?_G_L___L_I_N_E_A_R: Returns the weighted average of the four texture
              elements that are closest to the specified texture coordinates.
              These can include items wrapped or repeated from other parts of
              a texture, depending on the values of _?_G_L___T_E_X_T_U_R_E___W_R_A_P___S and
              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___T , and on the exact mapping.

              _?_G_L___N_E_A_R_E_S_T___M_I_P_M_A_P___N_E_A_R_E_S_T: Chooses the mipmap that most closely
              matches the size of the pixel being textured and uses the
              _?_G_L___N_E_A_R_E_S_T criterion (the texture element closest to the
              specified texture coordinates) to produce a texture value.

              _?_G_L___L_I_N_E_A_R___M_I_P_M_A_P___N_E_A_R_E_S_T: Chooses the mipmap that most closely
              matches the size of the pixel being textured and uses the
              _?_G_L___L_I_N_E_A_R criterion (a weighted average of the four texture
              elements that are closest to the specified texture coordinates)
              to produce a texture value.

              _?_G_L___N_E_A_R_E_S_T___M_I_P_M_A_P___L_I_N_E_A_R: Chooses the two mipmaps that most
              closely match the size of the pixel being textured and uses the
              _?_G_L___N_E_A_R_E_S_T criterion (the texture element closest to the
              specified texture coordinates ) to produce a texture value from
              each mipmap. The final texture value is a weighted average of
              those two values.

              _?_G_L___L_I_N_E_A_R___M_I_P_M_A_P___L_I_N_E_A_R: Chooses the two mipmaps that most
              closely match the size of the pixel being textured and uses the
              _?_G_L___L_I_N_E_A_R criterion (a weighted average of the texture elements
              that are closest to the specified texture coordinates) to
              produce a texture value from each mipmap. The final texture
              value is a weighted average of those two values.

              As more texture elements are sampled in the minification
              process, fewer aliasing artifacts will be apparent. While the
              _?_G_L___N_E_A_R_E_S_T and _?_G_L___L_I_N_E_A_R minification functions can be faster
              than the other four, they sample only one or multiple texture
              elements to determine the texture value of the pixel being
              rendered and can produce moire patterns or ragged transitions.
              The initial value of _?_G_L___T_E_X_T_U_R_E___M_I_N___F_I_L_T_E_R is
              _?_G_L___N_E_A_R_E_S_T___M_I_P_M_A_P___L_I_N_E_A_R .

              _?_G_L___T_E_X_T_U_R_E___M_A_G___F_I_L_T_E_R: The texture magnification function is
              used whenever the level-of-detail function used when sampling
              from the texture determines that the texture should be magified.
              It sets the texture magnification function to either _?_G_L___N_E_A_R_E_S_T
              or _?_G_L___L_I_N_E_A_R (see below). _?_G_L___N_E_A_R_E_S_T is generally faster than
              _?_G_L___L_I_N_E_A_R , but it can produce textured images with sharper
              edges because the transition between texture elements is not as
              smooth. The initial value of _?_G_L___T_E_X_T_U_R_E___M_A_G___F_I_L_T_E_R is
              _?_G_L___L_I_N_E_A_R .

              _?_G_L___N_E_A_R_E_S_T: Returns the value of the texture element that is
              nearest (in Manhattan distance) to the specified texture
              coordinates.

              _?_G_L___L_I_N_E_A_R: Returns the weighted average of the texture elements
              that are closest to the specified texture coordinates. These can
              include items wrapped or repeated from other parts of a texture,
              depending on the values of _?_G_L___T_E_X_T_U_R_E___W_R_A_P___S and
              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___T , and on the exact mapping.

              _?_G_L___T_E_X_T_U_R_E___M_I_N___L_O_D: Sets the minimum level-of-detail parameter.
              This floating-point value limits the selection of highest
              resolution mipmap (lowest mipmap level). The initial value is
              -1000.

              _?_G_L___T_E_X_T_U_R_E___M_A_X___L_O_D: Sets the maximum level-of-detail parameter.
              This floating-point value limits the selection of the lowest
              resolution mipmap (highest mipmap level). The initial value is
              1000.

              _?_G_L___T_E_X_T_U_R_E___M_A_X___L_E_V_E_L: Sets the index of the highest defined
              mipmap level. This is an integer value. The initial value is
              1000.

              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___R: Sets the swizzle that will be applied to
              the r component of a texel before it is returned to the shader.
              Valid values for _P_a_r_a_m are _?_G_L___R_E_D , _?_G_L___G_R_E_E_N, _?_G_L___B_L_U_E,
              _?_G_L___A_L_P_H_A, _?_G_L___Z_E_R_O and _?_G_L___O_N_E. If _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___R is
              _?_G_L___R_E_D, the value for r will be taken from the first channel of
              the fetched texel. If _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___R is _?_G_L___G_R_E_E_N , the
              value for r will be taken from the second channel of the fetched
              texel. If _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___R is _?_G_L___B_L_U_E, the value for r
              will be taken from the third channel of the fetched texel. If
              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___R is _?_G_L___A_L_P_H_A, the value for r will be
              taken from the fourth channel of the fetched texel. If
              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___R is _?_G_L___Z_E_R_O , the value for r will be
              subtituted with 0.0. If _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___R is _?_G_L___O_N_E , the
              value for r will be subtituted with 1.0. The initial value is
              _?_G_L___R_E_D.

              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___G: Sets the swizzle that will be applied to
              the g component of a texel before it is returned to the shader.
              Valid values for _P_a_r_a_m and their effects are similar to those of
              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___R. The initial value is _?_G_L___G_R_E_E_N .

              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___B: Sets the swizzle that will be applied to
              the b component of a texel before it is returned to the shader.
              Valid values for _P_a_r_a_m and their effects are similar to those of
              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___R. The initial value is _?_G_L___B_L_U_E .

              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___A: Sets the swizzle that will be applied to
              the a component of a texel before it is returned to the shader.
              Valid values for _P_a_r_a_m and their effects are similar to those of
              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___R. The initial value is _?_G_L___A_L_P_H_A .

              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___R_G_B_A: Sets the swizzles that will be applied
              to the r, g, b, and a components of a texel before they are
              returned to the shader. Valid values for _P_a_r_a_m_s and their
              effects are similar to those of _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___R, except
              that all channels are specified simultaneously. Setting the
              value of _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___R_G_B_A is equivalent (assuming no
              errors are generated) to setting the parameters of each of
              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___R , _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___G,
              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___B, and _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___A successively.

              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___S: Sets the wrap parameter for texture
              coordinate s to either _?_G_L___C_L_A_M_P___T_O___E_D_G_E , _?_G_L___C_L_A_M_P___T_O___B_O_R_D_E_R,
              _?_G_L___M_I_R_R_O_R_E_D___R_E_P_E_A_T, or _?_G_L___R_E_P_E_A_T. _?_G_L___C_L_A_M_P___T_O___E_D_G_E causes s
              coordinates to be clamped to the range [(1 2/N) 1-(1 2/N)],
              where N is the size of the texture in the direction of clamping.
              _?_G_L___C_L_A_M_P___T_O___B_O_R_D_E_R evaluates s coordinates in a similar manner
              to _?_G_L___C_L_A_M_P___T_O___E_D_G_E. However, in cases where clamping would
              have occurred in _?_G_L___C_L_A_M_P___T_O___E_D_G_E mode, the fetched texel data
              is substituted with the values specified by
              _?_G_L___T_E_X_T_U_R_E___B_O_R_D_E_R___C_O_L_O_R. _?_G_L___R_E_P_E_A_T causes the integer part of
              the s coordinate to be ignored; the GL uses only the fractional
              part, thereby creating a repeating pattern. _?_G_L___M_I_R_R_O_R_E_D___R_E_P_E_A_T
              causes the s coordinate to be set to the fractional part of the
              texture coordinate if the integer part of s is even; if the
              integer part of s is odd, then the s texture coordinate is set
              to 1- frac(s), where frac(s) represents the fractional part of
              s. Initially, _?_G_L___T_E_X_T_U_R_E___W_R_A_P___S is set to _?_G_L___R_E_P_E_A_T.

              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___T: Sets the wrap parameter for texture
              coordinate t to either _?_G_L___C_L_A_M_P___T_O___E_D_G_E , _?_G_L___C_L_A_M_P___T_O___B_O_R_D_E_R,
              _?_G_L___M_I_R_R_O_R_E_D___R_E_P_E_A_T, or _?_G_L___R_E_P_E_A_T. See the discussion under
              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___S. Initially, _?_G_L___T_E_X_T_U_R_E___W_R_A_P___T is set to
              _?_G_L___R_E_P_E_A_T.

              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___R: Sets the wrap parameter for texture
              coordinate r to either _?_G_L___C_L_A_M_P___T_O___E_D_G_E , _?_G_L___C_L_A_M_P___T_O___B_O_R_D_E_R,
              _?_G_L___M_I_R_R_O_R_E_D___R_E_P_E_A_T, or _?_G_L___R_E_P_E_A_T. See the discussion under
              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___S. Initially, _?_G_L___T_E_X_T_U_R_E___W_R_A_P___R is set to
              _?_G_L___R_E_P_E_A_T.

              See external documentation.

       tteexxPPaarraammeetteerrii((TTaarrggeett,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Target = enum()
                 Pname = enum()
                 Param = integer()

              See tteexxPPaarraammeetteerrff//33

       tteexxPPaarraammeetteerrffvv((TTaarrggeett,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Target = enum()
                 Pname = enum()
                 Params = {float()}

              See tteexxPPaarraammeetteerrff//33

       tteexxPPaarraammeetteerriivv((TTaarrggeett,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Target = enum()
                 Pname = enum()
                 Params = {integer()}

              See tteexxPPaarraammeetteerrff//33

       ggeettTTeexxPPaarraammeetteerrffvv((TTaarrggeett,, PPnnaammee)) -->> {{ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(()),,
       ffllooaatt(())}}

              Types:

                 Target = enum()
                 Pname = enum()

              Return texture parameter values

              _g_l_:_g_e_t_T_e_x_P_a_r_a_m_e_t_e_r returns in _P_a_r_a_m_s the value or values of the
              texture parameter specified as _P_n_a_m_e . _T_a_r_g_e_t defines the target
              texture. _?_G_L___T_E_X_T_U_R_E___1_D, _?_G_L___T_E_X_T_U_R_E___2_D, _?_G_L___T_E_X_T_U_R_E___3_D,
              _?_G_L___T_E_X_T_U_R_E___1_D___A_R_R_A_Y, _?_G_L___T_E_X_T_U_R_E___2_D___A_R_R_A_Y ,
              _?_G_L___T_E_X_T_U_R_E___R_E_C_T_A_N_G_L_E, _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P,
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___A_R_R_A_Y specify one-, two-, or three-
              dimensional, one-dimensional array, two-dimensional array,
              rectangle, cube-mapped or cube-mapped array texturing,
              respectively. _P_n_a_m_e accepts the same symbols as
              ggll::tteexxPPaarraammeetteerrff//33 , with the same interpretations:

              _?_G_L___T_E_X_T_U_R_E___M_A_G___F_I_L_T_E_R: Returns the single-valued texture
              magnification filter, a symbolic constant. The initial value is
              _?_G_L___L_I_N_E_A_R.

              _?_G_L___T_E_X_T_U_R_E___M_I_N___F_I_L_T_E_R: Returns the single-valued texture
              minification filter, a symbolic constant. The initial value is
              _?_G_L___N_E_A_R_E_S_T___M_I_P_M_A_P___L_I_N_E_A_R.

              _?_G_L___T_E_X_T_U_R_E___M_I_N___L_O_D: Returns the single-valued texture minimum
              level-of-detail value. The initial value is -1000.

              _?_G_L___T_E_X_T_U_R_E___M_A_X___L_O_D: Returns the single-valued texture maximum
              level-of-detail value. The initial value is 1000.

              _?_G_L___T_E_X_T_U_R_E___B_A_S_E___L_E_V_E_L: Returns the single-valued base texture
              mipmap level. The initial value is 0.

              _?_G_L___T_E_X_T_U_R_E___M_A_X___L_E_V_E_L: Returns the single-valued maximum texture
              mipmap array level. The initial value is 1000.

              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___R: Returns the red component swizzle. The
              initial value is _?_G_L___R_E_D .

              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___G: Returns the green component swizzle. The
              initial value is _?_G_L___G_R_E_E_N .

              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___B: Returns the blue component swizzle. The
              initial value is _?_G_L___B_L_U_E .

              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___A: Returns the alpha component swizzle. The
              initial value is _?_G_L___A_L_P_H_A .

              _?_G_L___T_E_X_T_U_R_E___S_W_I_Z_Z_L_E___R_G_B_A: Returns the component swizzle for all
              channels in a single query.

              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___S: Returns the single-valued wrapping function
              for texture coordinate s, a symbolic constant. The initial value
              is _?_G_L___R_E_P_E_A_T.

              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___T: Returns the single-valued wrapping function
              for texture coordinate t, a symbolic constant. The initial value
              is _?_G_L___R_E_P_E_A_T.

              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___R: Returns the single-valued wrapping function
              for texture coordinate r, a symbolic constant. The initial value
              is _?_G_L___R_E_P_E_A_T.

              _?_G_L___T_E_X_T_U_R_E___B_O_R_D_E_R___C_O_L_O_R: Returns four integer or floating-point
              numbers that comprise the RGBA color of the texture border.
              Floating-point values are returned in the range [0 1]. Integer
              values are returned as a linear mapping of the internal
              floating-point representation such that 1.0 maps to the most
              positive representable integer and -1.0 maps to the most
              negative representable integer. The initial value is (0, 0, 0,
              0).

              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_A_R_E___M_O_D_E: Returns a single-valued texture
              comparison mode, a symbolic constant. The initial value is
              _?_G_L___N_O_N_E. See ggll::tteexxPPaarraammeetteerrff//33 .

              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_A_R_E___F_U_N_C: Returns a single-valued texture
              comparison function, a symbolic constant. The initial value is
              _?_G_L___L_E_Q_U_A_L. See ggll::tteexxPPaarraammeetteerrff//33 .

              In addition to the parameters that may be set with
              ggll::tteexxPPaarraammeetteerrff//33 , _g_l_:_g_e_t_T_e_x_P_a_r_a_m_e_t_e_r accepts the following
              read-only parameters:

              _?_G_L___T_E_X_T_U_R_E___I_M_M_U_T_A_B_L_E___F_O_R_M_A_T: Returns non-zero if the texture
              has an immutable format. Textures become immutable if their
              storage is specified with ggll::tteexxSSttoorraaggee11DD//44 , ggll::tteexxSSttoorraaggee22DD//55
              or ggll::tteexxSSttoorraaggee33DD//66 . The initial value is _?_G_L___F_A_L_S_E .

              See external documentation.

       ggeettTTeexxPPaarraammeetteerriivv((TTaarrggeett,, PPnnaammee)) -->> {{iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(())}}

              Types:

                 Target = enum()
                 Pname = enum()

              See ggeettTTeexxPPaarraammeetteerrffvv//22

       ggeettTTeexxLLeevveellPPaarraammeetteerrffvv((TTaarrggeett,, LLeevveell,, PPnnaammee)) -->> {{ffllooaatt(())}}

              Types:

                 Target = enum()
                 Level = integer()
                 Pname = enum()

              Return texture parameter values for a specific level of detail

              _g_l_:_g_e_t_T_e_x_L_e_v_e_l_P_a_r_a_m_e_t_e_r returns in _P_a_r_a_m_s texture parameter
              values for a specific level-of-detail value, specified as _L_e_v_e_l
              . _T_a_r_g_e_t defines the target texture, either _?_G_L___T_E_X_T_U_R_E___1_D,
              _?_G_L___T_E_X_T_U_R_E___2_D, _?_G_L___T_E_X_T_U_R_E___3_D, _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___1_D ,
              _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___2_D, _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___3_D,
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___P_O_S_I_T_I_V_E___X ,
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___N_E_G_A_T_I_V_E___X,
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___P_O_S_I_T_I_V_E___Y, _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___N_E_G_A_T_I_V_E___Y
              , _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___P_O_S_I_T_I_V_E___Z,
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___N_E_G_A_T_I_V_E___Z, or _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___C_U_B_E___M_A_P .

              _?_G_L___M_A_X___T_E_X_T_U_R_E___S_I_Z_E, and _?_G_L___M_A_X___3_D___T_E_X_T_U_R_E___S_I_Z_E are not really
              descriptive enough. It has to report the largest square texture
              image that can be accommodated with mipmaps and borders, but a
              long skinny texture, or a texture without mipmaps and borders,
              may easily fit in texture memory. The proxy targets allow the
              user to more accurately query whether the GL can accommodate a
              texture of a given configuration. If the texture cannot be
              accommodated, the texture state variables, which may be queried
              with _g_l_:_g_e_t_T_e_x_L_e_v_e_l_P_a_r_a_m_e_t_e_r , are set to 0. If the texture can
              be accommodated, the texture state values will be set as they
              would be set for a non-proxy target.

              _P_n_a_m_e specifies the texture parameter whose value or values will
              be returned.

              The accepted parameter names are as follows:

              _?_G_L___T_E_X_T_U_R_E___W_I_D_T_H: _P_a_r_a_m_s returns a single value, the width of
              the texture image. This value includes the border of the texture
              image. The initial value is 0.

              _?_G_L___T_E_X_T_U_R_E___H_E_I_G_H_T: _P_a_r_a_m_s returns a single value, the height of
              the texture image. This value includes the border of the texture
              image. The initial value is 0.

              _?_G_L___T_E_X_T_U_R_E___D_E_P_T_H: _P_a_r_a_m_s returns a single value, the depth of
              the texture image. This value includes the border of the texture
              image. The initial value is 0.

              _?_G_L___T_E_X_T_U_R_E___I_N_T_E_R_N_A_L___F_O_R_M_A_T: _P_a_r_a_m_s returns a single value, the
              internal format of the texture image.

              _?_G_L___T_E_X_T_U_R_E___R_E_D___T_Y_P_E,

              _?_G_L___T_E_X_T_U_R_E___G_R_E_E_N___T_Y_P_E,

              _?_G_L___T_E_X_T_U_R_E___B_L_U_E___T_Y_P_E,

              _?_G_L___T_E_X_T_U_R_E___A_L_P_H_A___T_Y_P_E,

              _?_G_L___T_E_X_T_U_R_E___D_E_P_T_H___T_Y_P_E: The data type used to store the
              component. The types _?_G_L___N_O_N_E , _?_G_L___S_I_G_N_E_D___N_O_R_M_A_L_I_Z_E_D,
              _?_G_L___U_N_S_I_G_N_E_D___N_O_R_M_A_L_I_Z_E_D, _?_G_L___F_L_O_A_T, _?_G_L___I_N_T , and
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T may be returned to indicate signed normalized
              fixed-point, unsigned normalized fixed-point, floating-point,
              integer unnormalized, and unsigned integer unnormalized
              components, respectively.

              _?_G_L___T_E_X_T_U_R_E___R_E_D___S_I_Z_E,

              _?_G_L___T_E_X_T_U_R_E___G_R_E_E_N___S_I_Z_E,

              _?_G_L___T_E_X_T_U_R_E___B_L_U_E___S_I_Z_E,

              _?_G_L___T_E_X_T_U_R_E___A_L_P_H_A___S_I_Z_E,

              _?_G_L___T_E_X_T_U_R_E___D_E_P_T_H___S_I_Z_E: The internal storage resolution of an
              individual component. The resolution chosen by the GL will be a
              close match for the resolution requested by the user with the
              component argument of ggll::tteexxIImmaaggee11DD//88 , ggll::tteexxIImmaaggee22DD//99 ,
              ggll::tteexxIImmaaggee33DD//1100 , ggll::ccooppyyTTeexxIImmaaggee11DD//77 , and ggll::ccooppyyTTeexxIImmaaggee22DD//88
              . The initial value is 0.

              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_R_E_S_S_E_D: _P_a_r_a_m_s returns a single boolean value
              indicating if the texture image is stored in a compressed
              internal format. The initiali value is _?_G_L___F_A_L_S_E .

              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_R_E_S_S_E_D___I_M_A_G_E___S_I_Z_E: _P_a_r_a_m_s returns a single
              integer value, the number of unsigned bytes of the compressed
              texture image that would be returned from
              ggll::ggeettCCoommpprreesssseeddTTeexxIImmaaggee//33 .

              See external documentation.

       ggeettTTeexxLLeevveellPPaarraammeetteerriivv((TTaarrggeett,, LLeevveell,, PPnnaammee)) -->> {{iinntteeggeerr(())}}

              Types:

                 Target = enum()
                 Level = integer()
                 Pname = enum()

              See ggeettTTeexxLLeevveellPPaarraammeetteerrffvv//33

       tteexxIImmaaggee11DD((TTaarrggeett,, LLeevveell,, IInntteerrnnaallFFoorrmmaatt,, WWiiddtthh,, BBoorrddeerr,, FFoorrmmaatt,, TTyyppee,,
       PPiixxeellss)) -->> ookk

              Types:

                 Target = enum()
                 Level = integer()
                 InternalFormat = integer()
                 Width = integer()
                 Border = integer()
                 Format = enum()
                 Type = enum()
                 Pixels = offset() | mem()

              Specify a one-dimensional texture image

              Texturing maps a portion of a specified texture image onto each
              graphical primitive for which texturing is enabled. To enable
              and disable one-dimensional texturing, call ggll::eennaabbllee//11 and
              ggll::eennaabbllee//11 with argument _?_G_L___T_E_X_T_U_R_E___1_D.

              Texture images are defined with _g_l_:_t_e_x_I_m_a_g_e_1_D. The arguments
              describe the parameters of the texture image, such as width,
              width of the border, level-of-detail number (see
              ggll::tteexxPPaarraammeetteerrff//33 ), and the internal resolution and format
              used to store the image. The last three arguments describe how
              the image is represented in memory.

              If _T_a_r_g_e_t is _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___1_D, no data is read from _D_a_t_a ,
              but all of the texture image state is recalculated, checked for
              consistency, and checked against the implementation's
              capabilities. If the implementation cannot handle a texture of
              the requested texture size, it sets all of the image state to 0,
              but does not generate an error (see ggll::ggeettEErrrroorr//00 ). To query
              for an entire mipmap array, use an image array level greater
              than or equal to 1.

              If _T_a_r_g_e_t is _?_G_L___T_E_X_T_U_R_E___1_D, data is read from _D_a_t_a as a
              sequence of signed or unsigned bytes, shorts, or longs, or
              single-precision floating-point values, depending on _T_y_p_e .
              These values are grouped into sets of one, two, three, or four
              values, depending on _F_o_r_m_a_t , to form elements. Each data byte
              is treated as eight 1-bit elements, with bit ordering determined
              by _?_G_L___U_N_P_A_C_K___L_S_B___F_I_R_S_T (see ggll::ppiixxeellSSttoorreeff//22 ).

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              texture image is specified, _D_a_t_a is treated as a byte offset
              into the buffer object's data store.

              The first element corresponds to the left end of the texture
              array. Subsequent elements progress left-to-right through the
              remaining texels in the texture array. The final element
              corresponds to the right end of the texture array.

              _F_o_r_m_a_t determines the composition of each element in _D_a_t_a . It
              can assume one of these symbolic values:

              _?_G_L___R_E_D: Each element is a single red component. The GL converts
              it to floating point and assembles it into an RGBA element by
              attaching 0 for green and blue, and 1 for alpha. Each component
              is then multiplied by the signed scale factor _?_G_L___c___S_C_A_L_E, added
              to the signed bias _?_G_L___c___B_I_A_S, and clamped to the range [0,1].

              _?_G_L___R_G: Each element is a single red/green double The GL
              converts it to floating point and assembles it into an RGBA
              element by attaching 0 for blue, and 1 for alpha. Each component
              is then multiplied by the signed scale factor _?_G_L___c___S_C_A_L_E, added
              to the signed bias _?_G_L___c___B_I_A_S, and clamped to the range [0,1].

              _?_G_L___R_G_B

              _?_G_L___B_G_R: Each element is an RGB triple. The GL converts it to
              floating point and assembles it into an RGBA element by
              attaching 1 for alpha. Each component is then multiplied by the
              signed scale factor _?_G_L___c___S_C_A_L_E, added to the signed bias
              _?_G_L___c___B_I_A_S, and clamped to the range [0,1].

              _?_G_L___R_G_B_A

              _?_G_L___B_G_R_A: Each element contains all four components. Each
              component is multiplied by the signed scale factor _?_G_L___c___S_C_A_L_E,
              added to the signed bias _?_G_L___c___B_I_A_S, and clamped to the range
              [0,1].

              _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T: Each element is a single depth value. The
              GL converts it to floating point, multiplies by the signed scale
              factor _?_G_L___D_E_P_T_H___S_C_A_L_E, adds the signed bias _?_G_L___D_E_P_T_H___B_I_A_S, and
              clamps to the range [0,1].

              If an application wants to store the texture at a certain
              resolution or in a certain format, it can request the resolution
              and format with _I_n_t_e_r_n_a_l_F_o_r_m_a_t . The GL will choose an internal
              representation that closely approximates that requested by
              _I_n_t_e_r_n_a_l_F_o_r_m_a_t , but it may not match exactly. (The
              representations specified by _?_G_L___R_E_D, _?_G_L___R_G , _?_G_L___R_G_B and
              _?_G_L___R_G_B_A must match exactly.)

              _I_n_t_e_r_n_a_l_F_o_r_m_a_t may be one of the base internal formats shown in
              Table 1, below

              _I_n_t_e_r_n_a_l_F_o_r_m_a_t may also be one of the sized internal formats
              shown in Table 2, below

              Finally, _I_n_t_e_r_n_a_l_F_o_r_m_a_t may also be one of the generic or
              compressed compressed texture formats shown in Table 3 below

              If the _I_n_t_e_r_n_a_l_F_o_r_m_a_t parameter is one of the generic compressed
              formats, _?_G_L___C_O_M_P_R_E_S_S_E_D___R_E_D , _?_G_L___C_O_M_P_R_E_S_S_E_D___R_G,
              _?_G_L___C_O_M_P_R_E_S_S_E_D___R_G_B, or _?_G_L___C_O_M_P_R_E_S_S_E_D___R_G_B_A, the GL will replace
              the internal format with the symbolic constant for a specific
              internal format and compress the texture before storage. If no
              corresponding internal format is available, or the GL can not
              compress that image for any reason, the internal format is
              instead replaced with a corresponding base internal format.

              If the _I_n_t_e_r_n_a_l_F_o_r_m_a_t parameter is _?_G_L___S_R_G_B, _?_G_L___S_R_G_B_8,
              _?_G_L___S_R_G_B___A_L_P_H_A or _?_G_L___S_R_G_B_8___A_L_P_H_A_8, the texture is treated as if
              the red, green, or blue components are encoded in the sRGB color
              space. Any alpha component is left unchanged. The conversion
              from the sRGB encoded component c s to a linear component c l
              is:

              c l={ c s/12.92if c s&le; 0.04045( c s+0.055/1.055) 2.4if c s>
              0.04045

              Assume c s is the sRGB component in the range [0,1].

              Use the _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___1_D target to try out a resolution and
              format. The implementation will update and recompute its best
              match for the requested storage resolution and format. To then
              query this state, call ggll::ggeettTTeexxLLeevveellPPaarraammeetteerrffvv//33 . If the
              texture cannot be accommodated, texture state is set to 0.

              A one-component texture image uses only the red component of the
              RGBA color from _D_a_t_a . A two-component image uses the R and A
              values. A three-component image uses the R, G, and B values. A
              four-component image uses all of the RGBA components.

              Image-based shadowing can be enabled by comparing texture r
              coordinates to depth texture values to generate a boolean
              result. See ggll::tteexxPPaarraammeetteerrff//33 for details on texture
              comparison.

              See external documentation.

       tteexxIImmaaggee22DD((TTaarrggeett,, LLeevveell,, IInntteerrnnaallFFoorrmmaatt,, WWiiddtthh,, HHeeiigghhtt,, BBoorrddeerr,,
       FFoorrmmaatt,, TTyyppee,, PPiixxeellss)) -->> ookk

              Types:

                 Target = enum()
                 Level = integer()
                 InternalFormat = integer()
                 Width = integer()
                 Height = integer()
                 Border = integer()
                 Format = enum()
                 Type = enum()
                 Pixels = offset() | mem()

              Specify a two-dimensional texture image

              Texturing allows elements of an image array to be read by
              shaders.

              To define texture images, call _g_l_:_t_e_x_I_m_a_g_e_2_D. The arguments
              describe the parameters of the texture image, such as height,
              width, width of the border, level-of-detail number (see
              ggll::tteexxPPaarraammeetteerrff//33 ), and number of color components provided.
              The last three arguments describe how the image is represented
              in memory.

              If _T_a_r_g_e_t is _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___2_D, _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___1_D___A_R_R_A_Y,
              _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___C_U_B_E___M_A_P , or _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___R_E_C_T_A_N_G_L_E, no
              data is read from _D_a_t_a , but all of the texture image state is
              recalculated, checked for consistency, and checked against the
              implementation's capabilities. If the implementation cannot
              handle a texture of the requested texture size, it sets all of
              the image state to 0, but does not generate an error (see
              ggll::ggeettEErrrroorr//00 ). To query for an entire mipmap array, use an
              image array level greater than or equal to 1.

              If _T_a_r_g_e_t is _?_G_L___T_E_X_T_U_R_E___2_D, _?_G_L___T_E_X_T_U_R_E___R_E_C_T_A_N_G_L_E or one of the
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P targets, data is read from _D_a_t_a as a
              sequence of signed or unsigned bytes, shorts, or longs, or
              single-precision floating-point values, depending on _T_y_p_e .
              These values are grouped into sets of one, two, three, or four
              values, depending on _F_o_r_m_a_t , to form elements. Each data byte
              is treated as eight 1-bit elements, with bit ordering determined
              by _?_G_L___U_N_P_A_C_K___L_S_B___F_I_R_S_T (see ggll::ppiixxeellSSttoorreeff//22 ).

              If _T_a_r_g_e_t is _?_G_L___T_E_X_T_U_R_E___1_D___A_R_R_A_Y, data is interpreted as an
              array of one-dimensional images.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              texture image is specified, _D_a_t_a is treated as a byte offset
              into the buffer object's data store.

              The first element corresponds to the lower left corner of the
              texture image. Subsequent elements progress left-to-right
              through the remaining texels in the lowest row of the texture
              image, and then in successively higher rows of the texture
              image. The final element corresponds to the upper right corner
              of the texture image.

              _F_o_r_m_a_t determines the composition of each element in _D_a_t_a . It
              can assume one of these symbolic values:

              _?_G_L___R_E_D: Each element is a single red component. The GL converts
              it to floating point and assembles it into an RGBA element by
              attaching 0 for green and blue, and 1 for alpha. Each component
              is then multiplied by the signed scale factor _?_G_L___c___S_C_A_L_E, added
              to the signed bias _?_G_L___c___B_I_A_S, and clamped to the range [0,1].

              _?_G_L___R_G: Each element is a red/green double. The GL converts it
              to floating point and assembles it into an RGBA element by
              attaching 0 for blue, and 1 for alpha. Each component is then
              multiplied by the signed scale factor _?_G_L___c___S_C_A_L_E, added to the
              signed bias _?_G_L___c___B_I_A_S, and clamped to the range [0,1].

              _?_G_L___R_G_B

              _?_G_L___B_G_R: Each element is an RGB triple. The GL converts it to
              floating point and assembles it into an RGBA element by
              attaching 1 for alpha. Each component is then multiplied by the
              signed scale factor _?_G_L___c___S_C_A_L_E, added to the signed bias
              _?_G_L___c___B_I_A_S, and clamped to the range [0,1].

              _?_G_L___R_G_B_A

              _?_G_L___B_G_R_A: Each element contains all four components. Each
              component is multiplied by the signed scale factor _?_G_L___c___S_C_A_L_E,
              added to the signed bias _?_G_L___c___B_I_A_S, and clamped to the range
              [0,1].

              _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T: Each element is a single depth value. The
              GL converts it to floating point, multiplies by the signed scale
              factor _?_G_L___D_E_P_T_H___S_C_A_L_E, adds the signed bias _?_G_L___D_E_P_T_H___B_I_A_S, and
              clamps to the range [0,1].

              _?_G_L___D_E_P_T_H___S_T_E_N_C_I_L: Each element is a pair of depth and stencil
              values. The depth component of the pair is interpreted as in
              _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T. The stencil component is interpreted based
              on specified the depth + stencil internal format.

              If an application wants to store the texture at a certain
              resolution or in a certain format, it can request the resolution
              and format with _I_n_t_e_r_n_a_l_F_o_r_m_a_t . The GL will choose an internal
              representation that closely approximates that requested by
              _I_n_t_e_r_n_a_l_F_o_r_m_a_t , but it may not match exactly. (The
              representations specified by _?_G_L___R_E_D, _?_G_L___R_G , _?_G_L___R_G_B, and
              _?_G_L___R_G_B_A must match exactly.)

              _I_n_t_e_r_n_a_l_F_o_r_m_a_t may be one of the base internal formats shown in
              Table 1, below

              _I_n_t_e_r_n_a_l_F_o_r_m_a_t may also be one of the sized internal formats
              shown in Table 2, below

              Finally, _I_n_t_e_r_n_a_l_F_o_r_m_a_t may also be one of the generic or
              compressed compressed texture formats shown in Table 3 below

              If the _I_n_t_e_r_n_a_l_F_o_r_m_a_t parameter is one of the generic compressed
              formats, _?_G_L___C_O_M_P_R_E_S_S_E_D___R_E_D , _?_G_L___C_O_M_P_R_E_S_S_E_D___R_G,
              _?_G_L___C_O_M_P_R_E_S_S_E_D___R_G_B, or _?_G_L___C_O_M_P_R_E_S_S_E_D___R_G_B_A, the GL will replace
              the internal format with the symbolic constant for a specific
              internal format and compress the texture before storage. If no
              corresponding internal format is available, or the GL can not
              compress that image for any reason, the internal format is
              instead replaced with a corresponding base internal format.

              If the _I_n_t_e_r_n_a_l_F_o_r_m_a_t parameter is _?_G_L___S_R_G_B, _?_G_L___S_R_G_B_8,
              _?_G_L___S_R_G_B___A_L_P_H_A , or _?_G_L___S_R_G_B_8___A_L_P_H_A_8, the texture is treated as
              if the red, green, or blue components are encoded in the sRGB
              color space. Any alpha component is left unchanged. The
              conversion from the sRGB encoded component c s to a linear
              component c l is:

              c l={ c s/12.92if c s&le; 0.04045( c s+0.055/1.055) 2.4if c s>
              0.04045

              Assume c s is the sRGB component in the range [0,1].

              Use the _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___2_D, _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___1_D___A_R_R_A_Y,
              _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___R_E_C_T_A_N_G_L_E , or _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___C_U_B_E___M_A_P
              target to try out a resolution and format. The implementation
              will update and recompute its best match for the requested
              storage resolution and format. To then query this state, call
              ggll::ggeettTTeexxLLeevveellPPaarraammeetteerrffvv//33 . If the texture cannot be
              accommodated, texture state is set to 0.

              A one-component texture image uses only the red component of the
              RGBA color extracted from _D_a_t_a . A two-component image uses the
              R and G values. A three-component image uses the R, G, and B
              values. A four-component image uses all of the RGBA components.

              Image-based shadowing can be enabled by comparing texture r
              coordinates to depth texture values to generate a boolean
              result. See ggll::tteexxPPaarraammeetteerrff//33 for details on texture
              comparison.

              See external documentation.

       ggeettTTeexxIImmaaggee((TTaarrggeett,, LLeevveell,, FFoorrmmaatt,, TTyyppee,, PPiixxeellss)) -->> ookk

              Types:

                 Target = enum()
                 Level = integer()
                 Format = enum()
                 Type = enum()
                 Pixels = mem()

              Return a texture image

              _g_l_:_g_e_t_T_e_x_I_m_a_g_e returns a texture image into _I_m_g . _T_a_r_g_e_t
              specifies whether the desired texture image is one specified by
              ggll::tteexxIImmaaggee11DD//88 (_?_G_L___T_E_X_T_U_R_E___1_D ), ggll::tteexxIImmaaggee22DD//99
              (_?_G_L___T_E_X_T_U_R_E___1_D___A_R_R_A_Y, _?_G_L___T_E_X_T_U_R_E___R_E_C_T_A_N_G_L_E, _?_G_L___T_E_X_T_U_R_E___2_D or
              any of _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___*), or ggll::tteexxIImmaaggee33DD//1100
              (_?_G_L___T_E_X_T_U_R_E___2_D___A_R_R_A_Y , _?_G_L___T_E_X_T_U_R_E___3_D). _L_e_v_e_l specifies the
              level-of-detail number of the desired image. _F_o_r_m_a_t and _T_y_p_e
              specify the format and type of the desired image array. See the
              reference page for ggll::tteexxIImmaaggee11DD//88 for a description of the
              acceptable values for the _F_o_r_m_a_t and _T_y_p_e parameters,
              respectively.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              texture image is requested, _I_m_g is treated as a byte offset into
              the buffer object's data store.

              To understand the operation of _g_l_:_g_e_t_T_e_x_I_m_a_g_e, consider the
              selected internal four-component texture image to be an RGBA
              color buffer the size of the image. The semantics of
              _g_l_:_g_e_t_T_e_x_I_m_a_g_e are then identical to those of ggll::rreeaaddPPiixxeellss//77 ,
              with the exception that no pixel transfer operations are
              performed, when called with the same _F_o_r_m_a_t and _T_y_p_e , with _x
              and _y set to 0, _w_i_d_t_h set to the width of the texture image and
              _h_e_i_g_h_t set to 1 for 1D images, or to the height of the texture
              image for 2D images.

              If the selected texture image does not contain four components,
              the following mappings are applied. Single-component textures
              are treated as RGBA buffers with red set to the single-component
              value, green set to 0, blue set to 0, and alpha set to 1. Two-
              component textures are treated as RGBA buffers with red set to
              the value of component zero, alpha set to the value of component
              one, and green and blue set to 0. Finally, three-component
              textures are treated as RGBA buffers with red set to component
              zero, green set to component one, blue set to component two, and
              alpha set to 1.

              To determine the required size of _I_m_g , use
              ggll::ggeettTTeexxLLeevveellPPaarraammeetteerrffvv//33 to determine the dimensions of the
              internal texture image, then scale the required number of pixels
              by the storage required for each pixel, based on _F_o_r_m_a_t and _T_y_p_e
              . Be sure to take the pixel storage parameters into account,
              especially _?_G_L___P_A_C_K___A_L_I_G_N_M_E_N_T .

              See external documentation.

       ggeennTTeexxttuurreess((NN)) -->> [[iinntteeggeerr(())]]

              Types:

                 N = integer()

              Generate texture names

              _g_l_:_g_e_n_T_e_x_t_u_r_e_s returns _N texture names in _T_e_x_t_u_r_e_s . There is no
              guarantee that the names form a contiguous set of integers;
              however, it is guaranteed that none of the returned names was in
              use immediately before the call to _g_l_:_g_e_n_T_e_x_t_u_r_e_s.

              The generated textures have no dimensionality; they assume the
              dimensionality of the texture target to which they are first
              bound (see ggll::bbiinnddTTeexxttuurree//22 ).

              Texture names returned by a call to _g_l_:_g_e_n_T_e_x_t_u_r_e_s are not
              returned by subsequent calls, unless they are first deleted with
              ggll::ddeelleetteeTTeexxttuurreess//11 .

              See external documentation.

       ddeelleetteeTTeexxttuurreess((TTeexxttuurreess)) -->> ookk

              Types:

                 Textures = [integer()]

              Delete named textures

              _g_l_:_d_e_l_e_t_e_T_e_x_t_u_r_e_s deletes _N textures named by the elements of
              the array _T_e_x_t_u_r_e_s . After a texture is deleted, it has no
              contents or dimensionality, and its name is free for reuse (for
              example by ggll::ggeennTTeexxttuurreess//11 ). If a texture that is currently
              bound is deleted, the binding reverts to 0 (the default
              texture).

              _g_l_:_d_e_l_e_t_e_T_e_x_t_u_r_e_s silently ignores 0's and names that do not
              correspond to existing textures.

              See external documentation.

       bbiinnddTTeexxttuurree((TTaarrggeett,, TTeexxttuurree)) -->> ookk

              Types:

                 Target = enum()
                 Texture = integer()

              Bind a named texture to a texturing target

              _g_l_:_b_i_n_d_T_e_x_t_u_r_e lets you create or use a named texture. Calling
              _g_l_:_b_i_n_d_T_e_x_t_u_r_e with _T_a_r_g_e_t set to _?_G_L___T_E_X_T_U_R_E___1_D,
              _?_G_L___T_E_X_T_U_R_E___2_D, _?_G_L___T_E_X_T_U_R_E___3_D , or _?_G_L___T_E_X_T_U_R_E___1_D___A_R_R_A_Y,
              _?_G_L___T_E_X_T_U_R_E___2_D___A_R_R_A_Y, _?_G_L___T_E_X_T_U_R_E___R_E_C_T_A_N_G_L_E ,
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P, _?_G_L___T_E_X_T_U_R_E___2_D___M_U_L_T_I_S_A_M_P_L_E or
              _?_G_L___T_E_X_T_U_R_E___2_D___M_U_L_T_I_S_A_M_P_L_E___A_R_R_A_Y and _T_e_x_t_u_r_e set to the name of
              the new texture binds the texture name to the target. When a
              texture is bound to a target, the previous binding for that
              target is automatically broken.

              Texture names are unsigned integers. The value zero is reserved
              to represent the default texture for each texture target.
              Texture names and the corresponding texture contents are local
              to the shared object space of the current GL rendering context;
              two rendering contexts share texture names only if they
              explicitly enable sharing between contexts through the
              appropriate GL windows interfaces functions.

              You must use ggll::ggeennTTeexxttuurreess//11 to generate a set of new texture
              names.

              When a texture is first bound, it assumes the specified target:
              A texture first bound to _?_G_L___T_E_X_T_U_R_E___1_D becomes one-dimensional
              texture, a texture first bound to _?_G_L___T_E_X_T_U_R_E___2_D becomes two-
              dimensional texture, a texture first bound to _?_G_L___T_E_X_T_U_R_E___3_D
              becomes three-dimensional texture, a texture first bound to
              _?_G_L___T_E_X_T_U_R_E___1_D___A_R_R_A_Y becomes one-dimensional array texture, a
              texture first bound to _?_G_L___T_E_X_T_U_R_E___2_D___A_R_R_A_Y becomes two-
              dimensional arary texture, a texture first bound to
              _?_G_L___T_E_X_T_U_R_E___R_E_C_T_A_N_G_L_E becomes rectangle texture, a, texture
              first bound to _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P becomes a cube-mapped
              texture, a texture first bound to _?_G_L___T_E_X_T_U_R_E___2_D___M_U_L_T_I_S_A_M_P_L_E
              becomes a two-dimensional multisampled texture, and a texture
              first bound to _?_G_L___T_E_X_T_U_R_E___2_D___M_U_L_T_I_S_A_M_P_L_E___A_R_R_A_Y becomes a two-
              dimensional multisampled array texture. The state of a one-
              dimensional texture immediately after it is first bound is
              equivalent to the state of the default _?_G_L___T_E_X_T_U_R_E___1_D at GL
              initialization, and similarly for the other texture types.

              While a texture is bound, GL operations on the target to which
              it is bound affect the bound texture, and queries of the target
              to which it is bound return state from the bound texture. In
              effect, the texture targets become aliases for the textures
              currently bound to them, and the texture name zero refers to the
              default textures that were bound to them at initialization.

              A texture binding created with _g_l_:_b_i_n_d_T_e_x_t_u_r_e remains active
              until a different texture is bound to the same target, or until
              the bound texture is deleted with ggll::ddeelleetteeTTeexxttuurreess//11 .

              Once created, a named texture may be re-bound to its same
              original target as often as needed. It is usually much faster to
              use _g_l_:_b_i_n_d_T_e_x_t_u_r_e to bind an existing named texture to one of
              the texture targets than it is to reload the texture image using
              ggll::tteexxIImmaaggee11DD//88 , ggll::tteexxIImmaaggee22DD//99 , ggll::tteexxIImmaaggee33DD//1100 or another
              similar function.

              See external documentation.

       pprriioorriittiizzeeTTeexxttuurreess((TTeexxttuurreess,, PPrriioorriittiieess)) -->> ookk

              Types:

                 Textures = [integer()]
                 Priorities = [clamp()]

              Set texture residence priority

              _g_l_:_p_r_i_o_r_i_t_i_z_e_T_e_x_t_u_r_e_s assigns the _N texture priorities given in
              _P_r_i_o_r_i_t_i_e_s to the _N textures named in _T_e_x_t_u_r_e_s .

              The GL establishes a _w_o_r_k_i_n_g _s_e_t of textures that are resident
              in texture memory. These textures may be bound to a texture
              target much more efficiently than textures that are not
              resident. By specifying a priority for each texture,
              _g_l_:_p_r_i_o_r_i_t_i_z_e_T_e_x_t_u_r_e_s allows applications to guide the GL
              implementation in determining which textures should be resident.

              The priorities given in _P_r_i_o_r_i_t_i_e_s are clamped to the range [0
              1] before they are assigned. 0 indicates the lowest priority;
              textures with priority 0 are least likely to be resident. 1
              indicates the highest priority; textures with priority 1 are
              most likely to be resident. However, textures are not guaranteed
              to be resident until they are used.

              _g_l_:_p_r_i_o_r_i_t_i_z_e_T_e_x_t_u_r_e_s silently ignores attempts to prioritize
              texture 0 or any texture name that does not correspond to an
              existing texture.

              _g_l_:_p_r_i_o_r_i_t_i_z_e_T_e_x_t_u_r_e_s does not require that any of the textures
              named by _T_e_x_t_u_r_e_s be bound to a texture target.
              ggll::tteexxPPaarraammeetteerrff//33 may also be used to set a texture's priority,
              but only if the texture is currently bound. This is the only way
              to set the priority of a default texture.

              See external documentation.

       aarreeTTeexxttuurreessRReessiiddeenntt((TTeexxttuurreess)) -->> {{00 || 11,, RReessiiddeenncceess::::[[00 || 11]]}}

              Types:

                 Textures = [integer()]

              Determine if textures are loaded in texture memory

              GL establishes a _w_o_r_k_i_n_g _s_e_t of textures that are resident in
              texture memory. These textures can be bound to a texture target
              much more efficiently than textures that are not resident.

              _g_l_:_a_r_e_T_e_x_t_u_r_e_s_R_e_s_i_d_e_n_t queries the texture residence status of
              the _N textures named by the elements of _T_e_x_t_u_r_e_s . If all the
              named textures are resident, _g_l_:_a_r_e_T_e_x_t_u_r_e_s_R_e_s_i_d_e_n_t returns
              _?_G_L___T_R_U_E, and the contents of _R_e_s_i_d_e_n_c_e_s are undisturbed. If not
              all the named textures are resident, _g_l_:_a_r_e_T_e_x_t_u_r_e_s_R_e_s_i_d_e_n_t
              returns _?_G_L___F_A_L_S_E, and detailed status is returned in the _N
              elements of _R_e_s_i_d_e_n_c_e_s . If an element of _R_e_s_i_d_e_n_c_e_s is
              _?_G_L___T_R_U_E, then the texture named by the corresponding element of
              _T_e_x_t_u_r_e_s is resident.

              The residence status of a single bound texture may also be
              queried by calling ggll::ggeettTTeexxPPaarraammeetteerrffvv//22 with the _t_a_r_g_e_t
              argument set to the target to which the texture is bound, and
              the _p_n_a_m_e argument set to _?_G_L___T_E_X_T_U_R_E___R_E_S_I_D_E_N_T. This is the only
              way that the residence status of a default texture can be
              queried.

              See external documentation.

       iissTTeexxttuurree((TTeexxttuurree)) -->> 00 || 11

              Types:

                 Texture = integer()

              Determine if a name corresponds to a texture

              _g_l_:_i_s_T_e_x_t_u_r_e returns _?_G_L___T_R_U_E if _T_e_x_t_u_r_e is currently the name
              of a texture. If _T_e_x_t_u_r_e is zero, or is a non-zero value that is
              not currently the name of a texture, or if an error occurs,
              _g_l_:_i_s_T_e_x_t_u_r_e returns _?_G_L___F_A_L_S_E.

              A name returned by ggll::ggeennTTeexxttuurreess//11 , but not yet associated
              with a texture by calling ggll::bbiinnddTTeexxttuurree//22 , is not the name of
              a texture.

              See external documentation.

       tteexxSSuubbIImmaaggee11DD((TTaarrggeett,, LLeevveell,, XXooffffsseett,, WWiiddtthh,, FFoorrmmaatt,, TTyyppee,, PPiixxeellss)) -->>
       ookk

              Types:

                 Target = enum()
                 Level = integer()
                 Xoffset = integer()
                 Width = integer()
                 Format = enum()
                 Type = enum()
                 Pixels = offset() | mem()

              glTexSubImage

              See external documentation.

       tteexxSSuubbIImmaaggee22DD((TTaarrggeett,, LLeevveell,, XXooffffsseett,, YYooffffsseett,, WWiiddtthh,, HHeeiigghhtt,, FFoorrmmaatt,,
       TTyyppee,, PPiixxeellss)) -->> ookk

              Types:

                 Target = enum()
                 Level = integer()
                 Xoffset = integer()
                 Yoffset = integer()
                 Width = integer()
                 Height = integer()
                 Format = enum()
                 Type = enum()
                 Pixels = offset() | mem()

              glTexSubImage

              See external documentation.

       ccooppyyTTeexxIImmaaggee11DD((TTaarrggeett,, LLeevveell,, IInntteerrnnaallffoorrmmaatt,, XX,, YY,, WWiiddtthh,, BBoorrddeerr)) -->>
       ookk

              Types:

                 Target = enum()
                 Level = integer()
                 Internalformat = enum()
                 X = integer()
                 Y = integer()
                 Width = integer()
                 Border = integer()

              Copy pixels into a 1D texture image

              _g_l_:_c_o_p_y_T_e_x_I_m_a_g_e_1_D defines a one-dimensional texture image with
              pixels from the current _?_G_L___R_E_A_D___B_U_F_F_E_R.

              The screen-aligned pixel row with left corner at (x y) and with
              a length of width+2(border) defines the texture array at the
              mipmap level specified by _L_e_v_e_l . _I_n_t_e_r_n_a_l_f_o_r_m_a_t specifies the
              internal format of the texture array.

              The pixels in the row are processed exactly as if
              ggll::rreeaaddPPiixxeellss//77 had been called, but the process stops just
              before final conversion. At this point all pixel component
              values are clamped to the range [0 1] and then converted to the
              texture's internal format for storage in the texel array.

              Pixel ordering is such that lower x screen coordinates
              correspond to lower texture coordinates.

              If any of the pixels within the specified row of the current
              _?_G_L___R_E_A_D___B_U_F_F_E_R are outside the window associated with the
              current rendering context, then the values obtained for those
              pixels are undefined.

              _g_l_:_c_o_p_y_T_e_x_I_m_a_g_e_1_D defines a one-dimensional texture image with
              pixels from the current _?_G_L___R_E_A_D___B_U_F_F_E_R.

              When _I_n_t_e_r_n_a_l_f_o_r_m_a_t is one of the sRGB types, the GL does not
              automatically convert the source pixels to the sRGB color space.
              In this case, the _g_l_:_p_i_x_e_l_M_a_p function can be used to accomplish
              the conversion.

              See external documentation.

       ccooppyyTTeexxIImmaaggee22DD((TTaarrggeett,, LLeevveell,, IInntteerrnnaallffoorrmmaatt,, XX,, YY,, WWiiddtthh,, HHeeiigghhtt,,
       BBoorrddeerr)) -->> ookk

              Types:

                 Target = enum()
                 Level = integer()
                 Internalformat = enum()
                 X = integer()
                 Y = integer()
                 Width = integer()
                 Height = integer()
                 Border = integer()

              Copy pixels into a 2D texture image

              _g_l_:_c_o_p_y_T_e_x_I_m_a_g_e_2_D defines a two-dimensional texture image, or
              cube-map texture image with pixels from the current
              _?_G_L___R_E_A_D___B_U_F_F_E_R.

              The screen-aligned pixel rectangle with lower left corner at ( _X
              , _Y ) and with a width of width+2(border) and a height of
              height+2(border) defines the texture array at the mipmap level
              specified by _L_e_v_e_l . _I_n_t_e_r_n_a_l_f_o_r_m_a_t specifies the internal
              format of the texture array.

              The pixels in the rectangle are processed exactly as if
              ggll::rreeaaddPPiixxeellss//77 had been called, but the process stops just
              before final conversion. At this point all pixel component
              values are clamped to the range [0 1] and then converted to the
              texture's internal format for storage in the texel array.

              Pixel ordering is such that lower x and y screen coordinates
              correspond to lower s and t texture coordinates.

              If any of the pixels within the specified rectangle of the
              current _?_G_L___R_E_A_D___B_U_F_F_E_R are outside the window associated with
              the current rendering context, then the values obtained for
              those pixels are undefined.

              When _I_n_t_e_r_n_a_l_f_o_r_m_a_t is one of the sRGB types, the GL does not
              automatically convert the source pixels to the sRGB color space.
              In this case, the _g_l_:_p_i_x_e_l_M_a_p function can be used to accomplish
              the conversion.

              See external documentation.

       ccooppyyTTeexxSSuubbIImmaaggee11DD((TTaarrggeett,, LLeevveell,, XXooffffsseett,, XX,, YY,, WWiiddtthh)) -->> ookk

              Types:

                 Target = enum()
                 Level = integer()
                 Xoffset = integer()
                 X = integer()
                 Y = integer()
                 Width = integer()

              Copy a one-dimensional texture subimage

              _g_l_:_c_o_p_y_T_e_x_S_u_b_I_m_a_g_e_1_D replaces a portion of a one-dimensional
              texture image with pixels from the current _?_G_L___R_E_A_D___B_U_F_F_E_R
              (rather than from main memory, as is the case for
              ggll::tteexxSSuubbIImmaaggee11DD//77 ).

              The screen-aligned pixel row with left corner at ( _X , _Y ), and
              with length _W_i_d_t_h replaces the portion of the texture array with
              x indices _X_o_f_f_s_e_t through xoffset +width-1, inclusive. The
              destination in the texture array may not include any texels
              outside the texture array as it was originally specified.

              The pixels in the row are processed exactly as if
              ggll::rreeaaddPPiixxeellss//77 had been called, but the process stops just
              before final conversion. At this point, all pixel component
              values are clamped to the range [0 1] and then converted to the
              texture's internal format for storage in the texel array.

              It is not an error to specify a subtexture with zero width, but
              such a specification has no effect. If any of the pixels within
              the specified row of the current _?_G_L___R_E_A_D___B_U_F_F_E_R are outside the
              read window associated with the current rendering context, then
              the values obtained for those pixels are undefined.

              No change is made to the _i_n_t_e_r_n_a_l_f_o_r_m_a_t, _w_i_d_t_h, or _b_o_r_d_e_r
              parameters of the specified texture array or to texel values
              outside the specified subregion.

              See external documentation.

       ccooppyyTTeexxSSuubbIImmaaggee22DD((TTaarrggeett,, LLeevveell,, XXooffffsseett,, YYooffffsseett,, XX,, YY,, WWiiddtthh,, HHeeiigghhtt))
       -->> ookk

              Types:

                 Target = enum()
                 Level = integer()
                 Xoffset = integer()
                 Yoffset = integer()
                 X = integer()
                 Y = integer()
                 Width = integer()
                 Height = integer()

              Copy a two-dimensional texture subimage

              _g_l_:_c_o_p_y_T_e_x_S_u_b_I_m_a_g_e_2_D replaces a rectangular portion of a two-
              dimensional texture image or cube-map texture image with pixels
              from the current _?_G_L___R_E_A_D___B_U_F_F_E_R (rather than from main memory,
              as is the case for ggll::tteexxSSuubbIImmaaggee11DD//77 ).

              The screen-aligned pixel rectangle with lower left corner at (x
              y) and with width _W_i_d_t_h and height _H_e_i_g_h_t replaces the portion
              of the texture array with x indices _X_o_f_f_s_e_t through
              xoffset+width-1, inclusive, and y indices _Y_o_f_f_s_e_t through
              yoffset+height -1, inclusive, at the mipmap level specified by
              _L_e_v_e_l .

              The pixels in the rectangle are processed exactly as if
              ggll::rreeaaddPPiixxeellss//77 had been called, but the process stops just
              before final conversion. At this point, all pixel component
              values are clamped to the range [0 1] and then converted to the
              texture's internal format for storage in the texel array.

              The destination rectangle in the texture array may not include
              any texels outside the texture array as it was originally
              specified. It is not an error to specify a subtexture with zero
              width or height, but such a specification has no effect.

              If any of the pixels within the specified rectangle of the
              current _?_G_L___R_E_A_D___B_U_F_F_E_R are outside the read window associated
              with the current rendering context, then the values obtained for
              those pixels are undefined.

              No change is made to the _i_n_t_e_r_n_a_l_f_o_r_m_a_t, _w_i_d_t_h, _h_e_i_g_h_t, or
              _b_o_r_d_e_r parameters of the specified texture array or to texel
              values outside the specified subregion.

              See external documentation.

       mmaapp11dd((TTaarrggeett,, UU11,, UU22,, SSttrriiddee,, OOrrddeerr,, PPooiinnttss)) -->> ookk

              Types:

                 Target = enum()
                 U1 = float()
                 U2 = float()
                 Stride = integer()
                 Order = integer()
                 Points = binary()

              glMap

              See external documentation.

       mmaapp11ff((TTaarrggeett,, UU11,, UU22,, SSttrriiddee,, OOrrddeerr,, PPooiinnttss)) -->> ookk

              Types:

                 Target = enum()
                 U1 = float()
                 U2 = float()
                 Stride = integer()
                 Order = integer()
                 Points = binary()

              glMap

              See external documentation.

       mmaapp22dd((TTaarrggeett,, UU11,, UU22,, UUssttrriiddee,, UUoorrddeerr,, VV11,, VV22,, VVssttrriiddee,, VVoorrddeerr,, PPooiinnttss))
       -->> ookk

              Types:

                 Target = enum()
                 U1 = float()
                 U2 = float()
                 Ustride = integer()
                 Uorder = integer()
                 V1 = float()
                 V2 = float()
                 Vstride = integer()
                 Vorder = integer()
                 Points = binary()

              glMap

              See external documentation.

       mmaapp22ff((TTaarrggeett,, UU11,, UU22,, UUssttrriiddee,, UUoorrddeerr,, VV11,, VV22,, VVssttrriiddee,, VVoorrddeerr,, PPooiinnttss))
       -->> ookk

              Types:

                 Target = enum()
                 U1 = float()
                 U2 = float()
                 Ustride = integer()
                 Uorder = integer()
                 V1 = float()
                 V2 = float()
                 Vstride = integer()
                 Vorder = integer()
                 Points = binary()

              glMap

              See external documentation.

       ggeettMMaappddvv((TTaarrggeett,, QQuueerryy,, VV)) -->> ookk

              Types:

                 Target = enum()
                 Query = enum()
                 V = mem()

              Return evaluator parameters

              ggll::mmaapp11dd//66 and ggll::mmaapp11dd//66 define evaluators. _g_l_:_g_e_t_M_a_p returns
              evaluator parameters. _T_a_r_g_e_t chooses a map, _Q_u_e_r_y selects a
              specific parameter, and _V points to storage where the values
              will be returned.

              The acceptable values for the _T_a_r_g_e_t parameter are described in
              the ggll::mmaapp11dd//66 and ggll::mmaapp11dd//66 reference pages.

              _Q_u_e_r_y can assume the following values:

              _?_G_L___C_O_E_F_F: _V returns the control points for the evaluator
              function. One-dimensional evaluators return order control
              points, and two-dimensional evaluators return uorder*vorder
              control points. Each control point consists of one, two, three,
              or four integer, single-precision floating-point, or double-
              precision floating-point values, depending on the type of the
              evaluator. The GL returns two-dimensional control points in row-
              major order, incrementing the uorder index quickly and the
              vorder index after each row. Integer values, when requested, are
              computed by rounding the internal floating-point values to the
              nearest integer values.

              _?_G_L___O_R_D_E_R: _V returns the order of the evaluator function. One-
              dimensional evaluators return a single value, order. The initial
              value is 1. Two-dimensional evaluators return two values, uorder
              and vorder. The initial value is 1,1.

              _?_G_L___D_O_M_A_I_N: _V returns the linear u and v mapping parameters.
              One-dimensional evaluators return two values, u1 and u2, as
              specified by ggll::mmaapp11dd//66 . Two-dimensional evaluators return four
              values ( u1, u2, v1, and v2) as specified by ggll::mmaapp11dd//66 .
              Integer values, when requested, are computed by rounding the
              internal floating-point values to the nearest integer values.

              See external documentation.

       ggeettMMaappffvv((TTaarrggeett,, QQuueerryy,, VV)) -->> ookk

              Types:

                 Target = enum()
                 Query = enum()
                 V = mem()

              See ggeettMMaappddvv//33

       ggeettMMaappiivv((TTaarrggeett,, QQuueerryy,, VV)) -->> ookk

              Types:

                 Target = enum()
                 Query = enum()
                 V = mem()

              See ggeettMMaappddvv//33

       eevvaallCCoooorrdd11dd((UU)) -->> ookk

              Types:

                 U = float()

              Evaluate enabled one- and two-dimensional maps

              _g_l_:_e_v_a_l_C_o_o_r_d_1 evaluates enabled one-dimensional maps at argument
              _U . _g_l_:_e_v_a_l_C_o_o_r_d_2 does the same for two-dimensional maps using
              two domain values, _U and _V . To define a map, call ggll::mmaapp11dd//66
              and ggll::mmaapp11dd//66 ; to enable and disable it, call ggll::eennaabbllee//11 and
              ggll::eennaabbllee//11 .

              When one of the _g_l_:_e_v_a_l_C_o_o_r_d commands is issued, all currently
              enabled maps of the indicated dimension are evaluated. Then, for
              each enabled map, it is as if the corresponding GL command had
              been issued with the computed value. That is, if _?_G_L___M_A_P_1___I_N_D_E_X
              or _?_G_L___M_A_P_2___I_N_D_E_X is enabled, a ggll::iinnddeexxdd//11 command is
              simulated. If _?_G_L___M_A_P_1___C_O_L_O_R___4 or _?_G_L___M_A_P_2___C_O_L_O_R___4 is enabled, a
              ggll::ccoolloorr33bb//33 command is simulated. If _?_G_L___M_A_P_1___N_O_R_M_A_L or
              _?_G_L___M_A_P_2___N_O_R_M_A_L is enabled, a normal vector is produced, and if
              any of _?_G_L___M_A_P_1___T_E_X_T_U_R_E___C_O_O_R_D___1, _?_G_L___M_A_P_1___T_E_X_T_U_R_E___C_O_O_R_D___2 ,
              _?_G_L___M_A_P_1___T_E_X_T_U_R_E___C_O_O_R_D___3, _?_G_L___M_A_P_1___T_E_X_T_U_R_E___C_O_O_R_D___4,
              _?_G_L___M_A_P_2___T_E_X_T_U_R_E___C_O_O_R_D___1 , _?_G_L___M_A_P_2___T_E_X_T_U_R_E___C_O_O_R_D___2,
              _?_G_L___M_A_P_2___T_E_X_T_U_R_E___C_O_O_R_D___3, or _?_G_L___M_A_P_2___T_E_X_T_U_R_E___C_O_O_R_D___4 is
              enabled, then an appropriate ggll::tteexxCCoooorrdd11dd//11 command is
              simulated.

              For color, color index, normal, and texture coordinates the GL
              uses evaluated values instead of current values for those
              evaluations that are enabled, and current values otherwise,
              However, the evaluated values do not update the current values.
              Thus, if ggll::vveerrtteexx22dd//22 commands are interspersed with
              _g_l_:_e_v_a_l_C_o_o_r_d commands, the color, normal, and texture
              coordinates associated with the ggll::vveerrtteexx22dd//22 commands are not
              affected by the values generated by the _g_l_:_e_v_a_l_C_o_o_r_d commands,
              but only by the most recent ggll::ccoolloorr33bb//33 , ggll::iinnddeexxdd//11 ,
              ggll::nnoorrmmaall33bb//33 , and ggll::tteexxCCoooorrdd11dd//11 commands.

              No commands are issued for maps that are not enabled. If more
              than one texture evaluation is enabled for a particular
              dimension (for example, _?_G_L___M_A_P_2___T_E_X_T_U_R_E___C_O_O_R_D___1 and
              _?_G_L___M_A_P_2___T_E_X_T_U_R_E___C_O_O_R_D___2 ), then only the evaluation of the map
              that produces the larger number of coordinates (in this case,
              _?_G_L___M_A_P_2___T_E_X_T_U_R_E___C_O_O_R_D___2) is carried out. _?_G_L___M_A_P_1___V_E_R_T_E_X___4
              overrides _?_G_L___M_A_P_1___V_E_R_T_E_X___3, and _?_G_L___M_A_P_2___V_E_R_T_E_X___4 overrides
              _?_G_L___M_A_P_2___V_E_R_T_E_X___3 , in the same manner. If neither a three- nor
              a four-component vertex map is enabled for the specified
              dimension, the _g_l_:_e_v_a_l_C_o_o_r_d command is ignored.

              If you have enabled automatic normal generation, by calling
              ggll::eennaabbllee//11 with argument _?_G_L___A_U_T_O___N_O_R_M_A_L, _g_l_:_e_v_a_l_C_o_o_r_d_2
              generates surface normals analytically, regardless of the
              contents or enabling of the _?_G_L___M_A_P_2___N_O_R_M_A_L map. Let

              m=((&PartialD; p)/(&PartialD; u))*((&PartialD; p)/(&PartialD;
              v))

              Then the generated normal n is n= m/(||m||)

              If automatic normal generation is disabled, the corresponding
              normal map _?_G_L___M_A_P_2___N_O_R_M_A_L , if enabled, is used to produce a
              normal. If neither automatic normal generation nor a normal map
              is enabled, no normal is generated for _g_l_:_e_v_a_l_C_o_o_r_d_2 commands.

              See external documentation.

       eevvaallCCoooorrdd11ff((UU)) -->> ookk

              Types:

                 U = float()

              See eevvaallCCoooorrdd11dd//11

       eevvaallCCoooorrdd11ddvv((UU)) -->> ookk

              Types:

                 U = {U::float()}

              Equivalent to eevvaallCCoooorrdd11dd((UU)).

       eevvaallCCoooorrdd11ffvv((UU)) -->> ookk

              Types:

                 U = {U::float()}

              Equivalent to eevvaallCCoooorrdd11ff((UU)).

       eevvaallCCoooorrdd22dd((UU,, VV)) -->> ookk

              Types:

                 U = float()
                 V = float()

              See eevvaallCCoooorrdd11dd//11

       eevvaallCCoooorrdd22ff((UU,, VV)) -->> ookk

              Types:

                 U = float()
                 V = float()

              See eevvaallCCoooorrdd11dd//11

       eevvaallCCoooorrdd22ddvv((UU)) -->> ookk

              Types:

                 U = {U::float(), V::float()}

              Equivalent to eevvaallCCoooorrdd22dd((UU,, VV)).

       eevvaallCCoooorrdd22ffvv((UU)) -->> ookk

              Types:

                 U = {U::float(), V::float()}

              Equivalent to eevvaallCCoooorrdd22ff((UU,, VV)).

       mmaappGGrriidd11dd((UUnn,, UU11,, UU22)) -->> ookk

              Types:

                 Un = integer()
                 U1 = float()
                 U2 = float()

              Define a one- or two-dimensional mesh

              _g_l_:_m_a_p_G_r_i_d and ggll::eevvaallMMeesshh11//33 are used together to efficiently
              generate and evaluate a series of evenly-spaced map domain
              values. ggll::eevvaallMMeesshh11//33 steps through the integer domain of a
              one- or two-dimensional grid, whose range is the domain of the
              evaluation maps specified by ggll::mmaapp11dd//66 and ggll::mmaapp11dd//66 .

              _g_l_:_m_a_p_G_r_i_d_1 and _g_l_:_m_a_p_G_r_i_d_2 specify the linear grid mappings
              between the i (or i and j) integer grid coordinates, to the u
              (or u and v) floating-point evaluation map coordinates. See
              ggll::mmaapp11dd//66 and ggll::mmaapp11dd//66 for details of how u and v coordinates
              are evaluated.

              _g_l_:_m_a_p_G_r_i_d_1 specifies a single linear mapping such that integer
              grid coordinate 0 maps exactly to _U_1 , and integer grid
              coordinate _U_n maps exactly to _U_2 . All other integer grid
              coordinates i are mapped so that

              u= i(u2-u1)/un+u1

              _g_l_:_m_a_p_G_r_i_d_2 specifies two such linear mappings. One maps integer
              grid coordinate i= 0 exactly to _U_1 , and integer grid coordinate
              i= un exactly to _U_2 . The other maps integer grid coordinate j=
              0 exactly to _V_1 , and integer grid coordinate j= vn exactly to
              _V_2 . Other integer grid coordinates i and j are mapped such that

              u= i(u2-u1)/un+u1

              v= j(v2-v1)/vn+v1

              The mappings specified by _g_l_:_m_a_p_G_r_i_d are used identically by
              ggll::eevvaallMMeesshh11//33 and ggll::eevvaallPPooiinntt11//11 .

              See external documentation.

       mmaappGGrriidd11ff((UUnn,, UU11,, UU22)) -->> ookk

              Types:

                 Un = integer()
                 U1 = float()
                 U2 = float()

              See mmaappGGrriidd11dd//33

       mmaappGGrriidd22dd((UUnn,, UU11,, UU22,, VVnn,, VV11,, VV22)) -->> ookk

              Types:

                 Un = integer()
                 U1 = float()
                 U2 = float()
                 Vn = integer()
                 V1 = float()
                 V2 = float()

              See mmaappGGrriidd11dd//33

       mmaappGGrriidd22ff((UUnn,, UU11,, UU22,, VVnn,, VV11,, VV22)) -->> ookk

              Types:

                 Un = integer()
                 U1 = float()
                 U2 = float()
                 Vn = integer()
                 V1 = float()
                 V2 = float()

              See mmaappGGrriidd11dd//33

       eevvaallPPooiinntt11((II)) -->> ookk

              Types:

                 I = integer()

              Generate and evaluate a single point in a mesh

              ggll::mmaappGGrriidd11dd//33 and ggll::eevvaallMMeesshh11//33 are used in tandem to
              efficiently generate and evaluate a series of evenly spaced map
              domain values. _g_l_:_e_v_a_l_P_o_i_n_t can be used to evaluate a single
              grid point in the same gridspace that is traversed by
              ggll::eevvaallMMeesshh11//33 . Calling _g_l_:_e_v_a_l_P_o_i_n_t_1 is equivalent to calling
              glEvalCoord1( i.&Delta; u+u 1 ); where &Delta; u=(u 2-u 1)/n

              and n, u 1, and u 2 are the arguments to the most recent
              ggll::mmaappGGrriidd11dd//33 command. The one absolute numeric requirement is
              that if i= n, then the value computed from i.&Delta; u+u 1 is
              exactly u 2.

              In the two-dimensional case, _g_l_:_e_v_a_l_P_o_i_n_t_2, let

              &Delta; u=(u 2-u 1)/n

              &Delta; v=(v 2-v 1)/m

              where n, u 1, u 2, m, v 1, and v 2 are the arguments to the most
              recent ggll::mmaappGGrriidd11dd//33 command. Then the _g_l_:_e_v_a_l_P_o_i_n_t_2 command is
              equivalent to calling glEvalCoord2( i. &Delta; u+u 1, j.&Delta;
              v+v 1 ); The only absolute numeric requirements are that if i=
              n, then the value computed from i.&Delta; u+u 1 is exactly u 2,
              and if j= m, then the value computed from j.&Delta; v+v 1 is
              exactly v 2.

              See external documentation.

       eevvaallPPooiinntt22((II,, JJ)) -->> ookk

              Types:

                 I = integer()
                 J = integer()

              See eevvaallPPooiinntt11//11

       eevvaallMMeesshh11((MMooddee,, II11,, II22)) -->> ookk

              Types:

                 Mode = enum()
                 I1 = integer()
                 I2 = integer()

              Compute a one- or two-dimensional grid of points or lines

              ggll::mmaappGGrriidd11dd//33 and _g_l_:_e_v_a_l_M_e_s_h are used in tandem to efficiently
              generate and evaluate a series of evenly-spaced map domain
              values. _g_l_:_e_v_a_l_M_e_s_h steps through the integer domain of a one-
              or two-dimensional grid, whose range is the domain of the
              evaluation maps specified by ggll::mmaapp11dd//66 and ggll::mmaapp11dd//66 . _M_o_d_e
              determines whether the resulting vertices are connected as
              points, lines, or filled polygons.

              In the one-dimensional case, _g_l_:_e_v_a_l_M_e_s_h_1, the mesh is generated
              as if the following code fragment were executed:

              glBegin( _T_y_p_e ); for ( i = _I_1 ; i <= _I_2 ; i += 1 ) glEvalCoord1(
              i.&Delta; u+u 1 ); glEnd(); where

              &Delta; u=(u 2-u 1)/n

              and n, u 1, and u 2 are the arguments to the most recent
              ggll::mmaappGGrriidd11dd//33 command. _t_y_p_e is _?_G_L___P_O_I_N_T_S if _M_o_d_e is _?_G_L___P_O_I_N_T,
              or _?_G_L___L_I_N_E_S if _M_o_d_e is _?_G_L___L_I_N_E.

              The one absolute numeric requirement is that if i= n, then the
              value computed from i. &Delta; u+u 1 is exactly u 2.

              In the two-dimensional case, _g_l_:_e_v_a_l_M_e_s_h_2, let .cp &Delta; u=(u
              2-u 1)/n

              &Delta; v=(v 2-v 1)/m

              where n, u 1, u 2, m, v 1, and v 2 are the arguments to the most
              recent ggll::mmaappGGrriidd11dd//33 command. Then, if _M_o_d_e is _?_G_L___F_I_L_L, the
              _g_l_:_e_v_a_l_M_e_s_h_2 command is equivalent to:

              for ( j = _J_1 ; j < _J_2 ; j += 1 ) { glBegin( GL_QUAD_STRIP ); for
              ( i = _I_1 ; i <= _I_2 ; i += 1 ) { glEvalCoord2( i.&Delta; u+u 1,
              j.&Delta; v+v 1 ); glEvalCoord2( i.&Delta; u+u 1,(j+1).&Delta;
              v+v 1 ); } glEnd(); }

              If _M_o_d_e is _?_G_L___L_I_N_E, then a call to _g_l_:_e_v_a_l_M_e_s_h_2 is equivalent
              to:

              for ( j = _J_1 ; j <= _J_2 ; j += 1 ) { glBegin( GL_LINE_STRIP );
              for ( i = _I_1 ; i <= _I_2 ; i += 1 ) glEvalCoord2( i.&Delta; u+u 1,
              j.&Delta; v+v 1 ); glEnd(); } for ( i = _I_1 ; i <= _I_2 ; i += 1 )
              { glBegin( GL_LINE_STRIP ); for ( j = _J_1 ; j <= _J_1 ; j += 1 )
              glEvalCoord2( i.&Delta; u+u 1, j. &Delta; v+v 1 ); glEnd(); }

              And finally, if _M_o_d_e is _?_G_L___P_O_I_N_T, then a call to _g_l_:_e_v_a_l_M_e_s_h_2
              is equivalent to:

              glBegin( GL_POINTS ); for ( j = _J_1 ; j <= _J_2 ; j += 1 ) for ( i
              = _I_1 ; i <= _I_2 ; i += 1 ) glEvalCoord2( i.&Delta; u+u 1,
              j.&Delta; v+v 1 ); glEnd();

              In all three cases, the only absolute numeric requirements are
              that if i= n, then the value computed from i.&Delta; u+u 1 is
              exactly u 2, and if j= m, then the value computed from j.&Delta;
              v+v 1 is exactly v 2.

              See external documentation.

       eevvaallMMeesshh22((MMooddee,, II11,, II22,, JJ11,, JJ22)) -->> ookk

              Types:

                 Mode = enum()
                 I1 = integer()
                 I2 = integer()
                 J1 = integer()
                 J2 = integer()

              See eevvaallMMeesshh11//33

       ffooggff((PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Pname = enum()
                 Param = float()

              Specify fog parameters

              Fog is initially disabled. While enabled, fog affects rasterized
              geometry, bitmaps, and pixel blocks, but not buffer clear
              operations. To enable and disable fog, call ggll::eennaabbllee//11 and
              ggll::eennaabbllee//11 with argument _?_G_L___F_O_G.

              _g_l_:_f_o_g assigns the value or values in _P_a_r_a_m_s to the fog
              parameter specified by _P_n_a_m_e . The following values are accepted
              for _P_n_a_m_e :

              _?_G_L___F_O_G___M_O_D_E: _P_a_r_a_m_s is a single integer or floating-point value
              that specifies the equation to be used to compute the fog blend
              factor, f. Three symbolic constants are accepted: _?_G_L___L_I_N_E_A_R,
              _?_G_L___E_X_P, and _?_G_L___E_X_P_2. The equations corresponding to these
              symbolic constants are defined below. The initial fog mode is
              _?_G_L___E_X_P.

              _?_G_L___F_O_G___D_E_N_S_I_T_Y: _P_a_r_a_m_s is a single integer or floating-point
              value that specifies density, the fog density used in both
              exponential fog equations. Only nonnegative densities are
              accepted. The initial fog density is 1.

              _?_G_L___F_O_G___S_T_A_R_T: _P_a_r_a_m_s is a single integer or floating-point
              value that specifies start, the near distance used in the linear
              fog equation. The initial near distance is 0.

              _?_G_L___F_O_G___E_N_D: _P_a_r_a_m_s is a single integer or floating-point value
              that specifies end, the far distance used in the linear fog
              equation. The initial far distance is 1.

              _?_G_L___F_O_G___I_N_D_E_X: _P_a_r_a_m_s is a single integer or floating-point
              value that specifies i f, the fog color index. The initial fog
              index is 0.

              _?_G_L___F_O_G___C_O_L_O_R: _P_a_r_a_m_s contains four integer or floating-point
              values that specify C f, the fog color. Integer values are
              mapped linearly such that the most positive representable value
              maps to 1.0, and the most negative representable value maps to
              -1.0. Floating-point values are mapped directly. After
              conversion, all color components are clamped to the range [0 1].
              The initial fog color is (0, 0, 0, 0).

              _?_G_L___F_O_G___C_O_O_R_D___S_R_C: _P_a_r_a_m_s contains either of the following
              symbolic constants: _?_G_L___F_O_G___C_O_O_R_D or _?_G_L___F_R_A_G_M_E_N_T___D_E_P_T_H.
              _?_G_L___F_O_G___C_O_O_R_D specifies that the current fog coordinate should
              be used as distance value in the fog color computation.
              _?_G_L___F_R_A_G_M_E_N_T___D_E_P_T_H specifies that the current fragment depth
              should be used as distance value in the fog computation.

              Fog blends a fog color with each rasterized pixel fragment's
              post-texturing color using a blending factor f. Factor f is
              computed in one of three ways, depending on the fog mode. Let c
              be either the distance in eye coordinate from the origin (in the
              case that the _?_G_L___F_O_G___C_O_O_R_D___S_R_C is _?_G_L___F_R_A_G_M_E_N_T___D_E_P_T_H) or the
              current fog coordinate (in the case that _?_G_L___F_O_G___C_O_O_R_D___S_R_C is
              _?_G_L___F_O_G___C_O_O_R_D). The equation for _?_G_L___L_I_N_E_A_R fog is f=(end-
              c)/(end-start)

              The equation for _?_G_L___E_X_P fog is f= e(-(density. c))

              The equation for _?_G_L___E_X_P_2 fog is f= e(-(density. c)) 2

              Regardless of the fog mode, f is clamped to the range [0 1]
              after it is computed. Then, if the GL is in RGBA color mode, the
              fragment's red, green, and blue colors, represented by C r, are
              replaced by

              (C r)"= f*C r+(1-f)*C f

              Fog does not affect a fragment's alpha component.

              In color index mode, the fragment's color index i r is replaced
              by

              (i r)"= i r+(1-f)*i f

              See external documentation.

       ffooggii((PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Pname = enum()
                 Param = integer()

              See ffooggff//22

       ffooggffvv((PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Pname = enum()
                 Params = {float()}

              See ffooggff//22

       ffooggiivv((PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Pname = enum()
                 Params = {integer()}

              See ffooggff//22

       ffeeeeddbbaacckkBBuuffffeerr((SSiizzee,, TTyyppee,, BBuuffffeerr)) -->> ookk

              Types:

                 Size = integer()
                 Type = enum()
                 Buffer = mem()

              Controls feedback mode

              The _g_l_:_f_e_e_d_b_a_c_k_B_u_f_f_e_r function controls feedback. Feedback, like
              selection, is a GL mode. The mode is selected by calling
              ggll::rreennddeerrMMooddee//11 with _?_G_L___F_E_E_D_B_A_C_K. When the GL is in feedback
              mode, no pixels are produced by rasterization. Instead,
              information about primitives that would have been rasterized is
              fed back to the application using the GL.

              _g_l_:_f_e_e_d_b_a_c_k_B_u_f_f_e_r has three arguments: _B_u_f_f_e_r is a pointer to an
              array of floating-point values into which feedback information
              is placed. _S_i_z_e indicates the size of the array. _T_y_p_e is a
              symbolic constant describing the information that is fed back
              for each vertex. _g_l_:_f_e_e_d_b_a_c_k_B_u_f_f_e_r must be issued before
              feedback mode is enabled (by calling ggll::rreennddeerrMMooddee//11 with
              argument _?_G_L___F_E_E_D_B_A_C_K). Setting _?_G_L___F_E_E_D_B_A_C_K without
              establishing the feedback buffer, or calling _g_l_:_f_e_e_d_b_a_c_k_B_u_f_f_e_r
              while the GL is in feedback mode, is an error.

              When ggll::rreennddeerrMMooddee//11 is called while in feedback mode, it
              returns the number of entries placed in the feedback array and
              resets the feedback array pointer to the base of the feedback
              buffer. The returned value never exceeds _S_i_z_e . If the feedback
              data required more room than was available in _B_u_f_f_e_r ,
              ggll::rreennddeerrMMooddee//11 returns a negative value. To take the GL out of
              feedback mode, call ggll::rreennddeerrMMooddee//11 with a parameter value other
              than _?_G_L___F_E_E_D_B_A_C_K.

              While in feedback mode, each primitive, bitmap, or pixel
              rectangle that would be rasterized generates a block of values
              that are copied into the feedback array. If doing so would cause
              the number of entries to exceed the maximum, the block is
              partially written so as to fill the array (if there is any room
              left at all), and an overflow flag is set. Each block begins
              with a code indicating the primitive type, followed by values
              that describe the primitive's vertices and associated data.
              Entries are also written for bitmaps and pixel rectangles.
              Feedback occurs after polygon culling and ggll::ppoollyyggoonnMMooddee//22
              interpretation of polygons has taken place, so polygons that are
              culled are not returned in the feedback buffer. It can also
              occur after polygons with more than three edges are broken up
              into triangles, if the GL implementation renders polygons by
              performing this decomposition.

              The ggll::ppaassssTThhrroouugghh//11 command can be used to insert a marker into
              the feedback buffer. See ggll::ppaassssTThhrroouugghh//11 .

              Following is the grammar for the blocks of values written into
              the feedback buffer. Each primitive is indicated with a unique
              identifying value followed by some number of vertices. Polygon
              entries include an integer value indicating how many vertices
              follow. A vertex is fed back as some number of floating-point
              values, as determined by _T_y_p_e . Colors are fed back as four
              values in RGBA mode and one value in color index mode.

              feedbackList feedbackItem feedbackList | feedbackItem

              feedbackItem point | lineSegment | polygon | bitmap |
              pixelRectangle | passThru

              point _?_G_L___P_O_I_N_T___T_O_K_E_N vertex

              lineSegment _?_G_L___L_I_N_E___T_O_K_E_N vertex vertex | _?_G_L___L_I_N_E___R_E_S_E_T___T_O_K_E_N
              vertex vertex

              polygon _?_G_L___P_O_L_Y_G_O_N___T_O_K_E_N n polySpec

              polySpec polySpec vertex | vertex vertex vertex

              bitmap _?_G_L___B_I_T_M_A_P___T_O_K_E_N vertex

              pixelRectangle _?_G_L___D_R_A_W___P_I_X_E_L___T_O_K_E_N vertex |
              _?_G_L___C_O_P_Y___P_I_X_E_L___T_O_K_E_N vertex

              passThru _?_G_L___P_A_S_S___T_H_R_O_U_G_H___T_O_K_E_N value

              vertex 2d | 3d | 3dColor | 3dColorTexture | 4dColorTexture

              2d value value

              3d value value value

              3dColor value value value color

              3dColorTexture value value value color tex

              4dColorTexture value value value value color tex

              color rgba | index

              rgba value value value value

              index value

              tex value value value value

              _v_a_l_u_e is a floating-point number, and _n is a floating-point
              integer giving the number of vertices in the polygon.
              _?_G_L___P_O_I_N_T___T_O_K_E_N, _?_G_L___L_I_N_E___T_O_K_E_N, _?_G_L___L_I_N_E___R_E_S_E_T___T_O_K_E_N ,
              _?_G_L___P_O_L_Y_G_O_N___T_O_K_E_N, _?_G_L___B_I_T_M_A_P___T_O_K_E_N, _?_G_L___D_R_A_W___P_I_X_E_L___T_O_K_E_N,
              _?_G_L___C_O_P_Y___P_I_X_E_L___T_O_K_E_N and _?_G_L___P_A_S_S___T_H_R_O_U_G_H___T_O_K_E_N are symbolic
              floating-point constants. _?_G_L___L_I_N_E___R_E_S_E_T___T_O_K_E_N is returned
              whenever the line stipple pattern is reset. The data returned as
              a vertex depends on the feedback _T_y_p_e .

              The following table gives the correspondence between _T_y_p_e and
              the number of values per vertex. _k is 1 in color index mode and
              4 in RGBA mode._T_y_p_e_C_o_o_r_d_i_n_a_t_e_s_C_o_l_o_r_T_e_x_t_u_r_e_T_o_t_a_l _N_u_m_b_e_r _o_f _V_a_l_u_e_s
              _?_G_L___2_D_x, _y 2
              _?_G_L___3_D_x, _y, _z 3
              _?_G_L___3_D___C_O_L_O_R_x, _y, _z k 3+k
              _?_G_L___3_D___C_O_L_O_R___T_E_X_T_U_R_E_x, _y, _z k 4 7+k
              _?_G_L___4_D___C_O_L_O_R___T_E_X_T_U_R_E_x, _y, _z, _w k 4 8+k


              Feedback vertex coordinates are in window coordinates, except _w,
              which is in clip coordinates. Feedback colors are lighted, if
              lighting is enabled. Feedback texture coordinates are generated,
              if texture coordinate generation is enabled. They are always
              transformed by the texture matrix.

              See external documentation.

       ppaassssTThhrroouugghh((TTookkeenn)) -->> ookk

              Types:

                 Token = float()

              Place a marker in the feedback buffer

              Feedback is a GL render mode. The mode is selected by calling
              ggll::rreennddeerrMMooddee//11 with _?_G_L___F_E_E_D_B_A_C_K. When the GL is in feedback
              mode, no pixels are produced by rasterization. Instead,
              information about primitives that would have been rasterized is
              fed back to the application using the GL. See the
              ggll::ffeeeeddbbaacckkBBuuffffeerr//33 reference page for a description of the
              feedback buffer and the values in it.

              _g_l_:_p_a_s_s_T_h_r_o_u_g_h inserts a user-defined marker in the feedback
              buffer when it is executed in feedback mode. _T_o_k_e_n is returned
              as if it were a primitive; it is indicated with its own unique
              identifying value: _?_G_L___P_A_S_S___T_H_R_O_U_G_H___T_O_K_E_N. The order of
              _g_l_:_p_a_s_s_T_h_r_o_u_g_h commands with respect to the specification of
              graphics primitives is maintained.

              See external documentation.

       sseelleeccttBBuuffffeerr((SSiizzee,, BBuuffffeerr)) -->> ookk

              Types:

                 Size = integer()
                 Buffer = mem()

              Establish a buffer for selection mode values

              _g_l_:_s_e_l_e_c_t_B_u_f_f_e_r has two arguments: _B_u_f_f_e_r is a pointer to an
              array of unsigned integers, and _S_i_z_e indicates the size of the
              array. _B_u_f_f_e_r returns values from the name stack (see
              ggll::iinniittNNaammeess//00 , ggll::llooaaddNNaammee//11 , ggll::ppuusshhNNaammee//11 ) when the
              rendering mode is _?_G_L___S_E_L_E_C_T (see ggll::rreennddeerrMMooddee//11 ).
              _g_l_:_s_e_l_e_c_t_B_u_f_f_e_r must be issued before selection mode is enabled,
              and it must not be issued while the rendering mode is
              _?_G_L___S_E_L_E_C_T.

              A programmer can use selection to determine which primitives are
              drawn into some region of a window. The region is defined by the
              current modelview and perspective matrices.

              In selection mode, no pixel fragments are produced from
              rasterization. Instead, if a primitive or a raster position
              intersects the clipping volume defined by the viewing frustum
              and the user-defined clipping planes, this primitive causes a
              selection hit. (With polygons, no hit occurs if the polygon is
              culled.) When a change is made to the name stack, or when
              ggll::rreennddeerrMMooddee//11 is called, a hit record is copied to _B_u_f_f_e_r if
              any hits have occurred since the last such event (name stack
              change or ggll::rreennddeerrMMooddee//11 call). The hit record consists of the
              number of names in the name stack at the time of the event,
              followed by the minimum and maximum depth values of all vertices
              that hit since the previous event, followed by the name stack
              contents, bottom name first.

              Depth values (which are in the range [0,1]) are multiplied by 2
              32-1, before being placed in the hit record.

              An internal index into _B_u_f_f_e_r is reset to 0 whenever selection
              mode is entered. Each time a hit record is copied into _B_u_f_f_e_r ,
              the index is incremented to point to the cell just past the end
              of the block of names(emthat is, to the next available cell If
              the hit record is larger than the number of remaining locations
              in _B_u_f_f_e_r , as much data as can fit is copied, and the overflow
              flag is set. If the name stack is empty when a hit record is
              copied, that record consists of 0 followed by the minimum and
              maximum depth values.

              To exit selection mode, call ggll::rreennddeerrMMooddee//11 with an argument
              other than _?_G_L___S_E_L_E_C_T . Whenever ggll::rreennddeerrMMooddee//11 is called while
              the render mode is _?_G_L___S_E_L_E_C_T, it returns the number of hit
              records copied to _B_u_f_f_e_r , resets the overflow flag and the
              selection buffer pointer, and initializes the name stack to be
              empty. If the overflow bit was set when ggll::rreennddeerrMMooddee//11 was
              called, a negative hit record count is returned.

              See external documentation.

       iinniittNNaammeess(()) -->> ookk

              Initialize the name stack

              The name stack is used during selection mode to allow sets of
              rendering commands to be uniquely identified. It consists of an
              ordered set of unsigned integers. _g_l_:_i_n_i_t_N_a_m_e_s causes the name
              stack to be initialized to its default empty state.

              The name stack is always empty while the render mode is not
              _?_G_L___S_E_L_E_C_T. Calls to _g_l_:_i_n_i_t_N_a_m_e_s while the render mode is not
              _?_G_L___S_E_L_E_C_T are ignored.

              See external documentation.

       llooaaddNNaammee((NNaammee)) -->> ookk

              Types:

                 Name = integer()

              Load a name onto the name stack

              The name stack is used during selection mode to allow sets of
              rendering commands to be uniquely identified. It consists of an
              ordered set of unsigned integers and is initially empty.

              _g_l_:_l_o_a_d_N_a_m_e causes _N_a_m_e to replace the value on the top of the
              name stack.

              The name stack is always empty while the render mode is not
              _?_G_L___S_E_L_E_C_T. Calls to _g_l_:_l_o_a_d_N_a_m_e while the render mode is not
              _?_G_L___S_E_L_E_C_T are ignored.

              See external documentation.

       ppuusshhNNaammee((NNaammee)) -->> ookk

              Types:

                 Name = integer()

              Push and pop the name stack

              The name stack is used during selection mode to allow sets of
              rendering commands to be uniquely identified. It consists of an
              ordered set of unsigned integers and is initially empty.

              _g_l_:_p_u_s_h_N_a_m_e causes _N_a_m_e to be pushed onto the name stack.
              ggll::ppuusshhNNaammee//11 pops one name off the top of the stack.

              The maximum name stack depth is implementation-dependent; call
              _?_G_L___M_A_X___N_A_M_E___S_T_A_C_K___D_E_P_T_H to find out the value for a particular
              implementation. It is an error to push a name onto a full stack
              or to pop a name off an empty stack. It is also an error to
              manipulate the name stack between the execution of ggll::''bbeeggiinn''//11
              and the corresponding execution of ggll::''bbeeggiinn''//11 . In any of
              these cases, the error flag is set and no other change is made
              to GL state.

              The name stack is always empty while the render mode is not
              _?_G_L___S_E_L_E_C_T. Calls to _g_l_:_p_u_s_h_N_a_m_e or ggll::ppuusshhNNaammee//11 while the
              render mode is not _?_G_L___S_E_L_E_C_T are ignored.

              See external documentation.

       ppooppNNaammee(()) -->> ookk

              See ppuusshhNNaammee//11

       bblleennddCCoolloorr((RReedd,, GGrreeeenn,, BBlluuee,, AAllpphhaa)) -->> ookk

              Types:

                 Red = clamp()
                 Green = clamp()
                 Blue = clamp()
                 Alpha = clamp()

              Set the blend color

              The _?_G_L___B_L_E_N_D___C_O_L_O_R may be used to calculate the source and
              destination blending factors. The color components are clamped
              to the range [0 1] before being stored. See ggll::bblleennddFFuunncc//22 for a
              complete description of the blending operations. Initially the
              _?_G_L___B_L_E_N_D___C_O_L_O_R is set to (0, 0, 0, 0).

              See external documentation.

       bblleennddEEqquuaattiioonn((MMooddee)) -->> ookk

              Types:

                 Mode = enum()

              Specify the equation used for both the RGB blend equation and
              the Alpha blend equation

              The blend equations determine how a new pixel (the ''source''
              color) is combined with a pixel already in the framebuffer (the
              ''destination'' color). This function sets both the RGB blend
              equation and the alpha blend equation to a single equation.
              _g_l_:_b_l_e_n_d_E_q_u_a_t_i_o_n_i specifies the blend equation for a single draw
              buffer whereas _g_l_:_b_l_e_n_d_E_q_u_a_t_i_o_n sets the blend equation for all
              draw buffers.

              These equations use the source and destination blend factors
              specified by either ggll::bblleennddFFuunncc//22 or ggll::bblleennddFFuunnccSSeeppaarraattee//44 .
              See ggll::bblleennddFFuunncc//22 or ggll::bblleennddFFuunnccSSeeppaarraattee//44 for a description
              of the various blend factors.

              In the equations that follow, source and destination color
              components are referred to as (R s G s B s A s) and (R d G d B d
              A d), respectively. The result color is referred to as (R r G r
              B r A r). The source and destination blend factors are denoted
              (s R s G s B s A) and (d R d G d B d A), respectively. For these
              equations all color components are understood to have values in
              the range [0 1]._M_o_d_e_R_G_B _C_o_m_p_o_n_e_n_t_s_A_l_p_h_a _C_o_m_p_o_n_e_n_t
              _?_G_L___F_U_N_C___A_D_D Rr= R s s R+R d d R Gr= G s s G+G d d G Br= B s s
              B+B d d B Ar= A s s A+A d d A
              _?_G_L___F_U_N_C___S_U_B_T_R_A_C_T Rr= R s s R-R d d R Gr= G s s G-G d d G Br= B
              s s B-B d d B Ar= A s s A-A d d A
              _?_G_L___F_U_N_C___R_E_V_E_R_S_E___S_U_B_T_R_A_C_T Rr= R d d R-R s s R Gr= G d d G-G s s
              G Br= B d d B-B s s B Ar= A d d A-A s s A
              _?_G_L___M_I_N Rr= min(R s R d) Gr= min(G s G d) Br= min(B s B d) Ar=
              min(A s A d)
              _?_G_L___M_A_X Rr= max(R s R d) Gr= max(G s G d) Br= max(B s B d) Ar=
              max(A s A d)


              The results of these equations are clamped to the range [0 1].

              The _?_G_L___M_I_N and _?_G_L___M_A_X equations are useful for applications
              that analyze image data (image thresholding against a constant
              color, for example). The _?_G_L___F_U_N_C___A_D_D equation is useful for
              antialiasing and transparency, among other things.

              Initially, both the RGB blend equation and the alpha blend
              equation are set to _?_G_L___F_U_N_C___A_D_D .

              See external documentation.

       ddrraawwRRaannggeeEElleemmeennttss((MMooddee,, SSttaarrtt,, EEnndd,, CCoouunntt,, TTyyppee,, IInnddiicceess)) -->> ookk

              Types:

                 Mode = enum()
                 Start = integer()
                 End = integer()
                 Count = integer()
                 Type = enum()
                 Indices = offset() | mem()

              Render primitives from array data

              _g_l_:_d_r_a_w_R_a_n_g_e_E_l_e_m_e_n_t_s is a restricted form of ggll::ddrraawwEElleemmeennttss//44 .
              _M_o_d_e , _S_t_a_r_t , _E_n_d , and _C_o_u_n_t match the corresponding arguments
              to ggll::ddrraawwEElleemmeennttss//44 , with the additional constraint that all
              values in the arrays _C_o_u_n_t must lie between _S_t_a_r_t and _E_n_d ,
              inclusive.

              Implementations denote recommended maximum amounts of vertex and
              index data, which may be queried by calling ggll::ggeettBBoooolleeaannvv//11
              with argument _?_G_L___M_A_X___E_L_E_M_E_N_T_S___V_E_R_T_I_C_E_S and
              _?_G_L___M_A_X___E_L_E_M_E_N_T_S___I_N_D_I_C_E_S . If end-start+1 is greater than the
              value of _?_G_L___M_A_X___E_L_E_M_E_N_T_S___V_E_R_T_I_C_E_S, or if _C_o_u_n_t is greater than
              the value of _?_G_L___M_A_X___E_L_E_M_E_N_T_S___I_N_D_I_C_E_S, then the call may operate
              at reduced performance. There is no requirement that all
              vertices in the range [start end] be referenced. However, the
              implementation may partially process unused vertices, reducing
              performance from what could be achieved with an optimal index
              set.

              When _g_l_:_d_r_a_w_R_a_n_g_e_E_l_e_m_e_n_t_s is called, it uses _C_o_u_n_t sequential
              elements from an enabled array, starting at _S_t_a_r_t to construct a
              sequence of geometric primitives. _M_o_d_e specifies what kind of
              primitives are constructed, and how the array elements construct
              these primitives. If more than one array is enabled, each is
              used.

              Vertex attributes that are modified by _g_l_:_d_r_a_w_R_a_n_g_e_E_l_e_m_e_n_t_s have
              an unspecified value after _g_l_:_d_r_a_w_R_a_n_g_e_E_l_e_m_e_n_t_s returns.
              Attributes that aren't modified maintain their previous values.

              See external documentation.

       tteexxIImmaaggee33DD((TTaarrggeett,, LLeevveell,, IInntteerrnnaallFFoorrmmaatt,, WWiiddtthh,, HHeeiigghhtt,, DDeepptthh,, BBoorrddeerr,,
       FFoorrmmaatt,, TTyyppee,, PPiixxeellss)) -->> ookk

              Types:

                 Target = enum()
                 Level = integer()
                 InternalFormat = integer()
                 Width = integer()
                 Height = integer()
                 Depth = integer()
                 Border = integer()
                 Format = enum()
                 Type = enum()
                 Pixels = offset() | mem()

              Specify a three-dimensional texture image

              Texturing maps a portion of a specified texture image onto each
              graphical primitive for which texturing is enabled. To enable
              and disable three-dimensional texturing, call ggll::eennaabbllee//11 and
              ggll::eennaabbllee//11 with argument _?_G_L___T_E_X_T_U_R_E___3_D.

              To define texture images, call _g_l_:_t_e_x_I_m_a_g_e_3_D. The arguments
              describe the parameters of the texture image, such as height,
              width, depth, width of the border, level-of-detail number (see
              ggll::tteexxPPaarraammeetteerrff//33 ), and number of color components provided.
              The last three arguments describe how the image is represented
              in memory.

              If _T_a_r_g_e_t is _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___3_D, no data is read from _D_a_t_a ,
              but all of the texture image state is recalculated, checked for
              consistency, and checked against the implementation's
              capabilities. If the implementation cannot handle a texture of
              the requested texture size, it sets all of the image state to 0,
              but does not generate an error (see ggll::ggeettEErrrroorr//00 ). To query
              for an entire mipmap array, use an image array level greater
              than or equal to 1.

              If _T_a_r_g_e_t is _?_G_L___T_E_X_T_U_R_E___3_D, data is read from _D_a_t_a as a
              sequence of signed or unsigned bytes, shorts, or longs, or
              single-precision floating-point values, depending on _T_y_p_e .
              These values are grouped into sets of one, two, three, or four
              values, depending on _F_o_r_m_a_t , to form elements. Each data byte
              is treated as eight 1-bit elements, with bit ordering determined
              by _?_G_L___U_N_P_A_C_K___L_S_B___F_I_R_S_T (see ggll::ppiixxeellSSttoorreeff//22 ).

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              texture image is specified, _D_a_t_a is treated as a byte offset
              into the buffer object's data store.

              The first element corresponds to the lower left corner of the
              texture image. Subsequent elements progress left-to-right
              through the remaining texels in the lowest row of the texture
              image, and then in successively higher rows of the texture
              image. The final element corresponds to the upper right corner
              of the texture image.

              _F_o_r_m_a_t determines the composition of each element in _D_a_t_a . It
              can assume one of these symbolic values:

              _?_G_L___R_E_D: Each element is a single red component. The GL converts
              it to floating point and assembles it into an RGBA element by
              attaching 0 for green and blue, and 1 for alpha. Each component
              is then multiplied by the signed scale factor _?_G_L___c___S_C_A_L_E, added
              to the signed bias _?_G_L___c___B_I_A_S, and clamped to the range [0,1].

              _?_G_L___R_G: Each element is a red and green pair. The GL converts
              each to floating point and assembles it into an RGBA element by
              attaching 0 for blue, and 1 for alpha. Each component is then
              multiplied by the signed scale factor _?_G_L___c___S_C_A_L_E, added to the
              signed bias _?_G_L___c___B_I_A_S, and clamped to the range [0,1].

              _?_G_L___R_G_B

              _?_G_L___B_G_R: Each element is an RGB triple. The GL converts it to
              floating point and assembles it into an RGBA element by
              attaching 1 for alpha. Each component is then multiplied by the
              signed scale factor _?_G_L___c___S_C_A_L_E, added to the signed bias
              _?_G_L___c___B_I_A_S, and clamped to the range [0,1].

              _?_G_L___R_G_B_A

              _?_G_L___B_G_R_A: Each element contains all four components. Each
              component is multiplied by the signed scale factor _?_G_L___c___S_C_A_L_E,
              added to the signed bias _?_G_L___c___B_I_A_S, and clamped to the range
              [0,1].

              If an application wants to store the texture at a certain
              resolution or in a certain format, it can request the resolution
              and format with _I_n_t_e_r_n_a_l_F_o_r_m_a_t . The GL will choose an internal
              representation that closely approximates that requested by
              _I_n_t_e_r_n_a_l_F_o_r_m_a_t , but it may not match exactly. (The
              representations specified by _?_G_L___R_E_D, _?_G_L___R_G , _?_G_L___R_G_B, and
              _?_G_L___R_G_B_A must match exactly.)

              _I_n_t_e_r_n_a_l_F_o_r_m_a_t may be one of the base internal formats shown in
              Table 1, below

              _I_n_t_e_r_n_a_l_F_o_r_m_a_t may also be one of the sized internal formats
              shown in Table 2, below

              Finally, _I_n_t_e_r_n_a_l_F_o_r_m_a_t may also be one of the generic or
              compressed compressed texture formats shown in Table 3 below

              If the _I_n_t_e_r_n_a_l_F_o_r_m_a_t parameter is one of the generic compressed
              formats, _?_G_L___C_O_M_P_R_E_S_S_E_D___R_E_D , _?_G_L___C_O_M_P_R_E_S_S_E_D___R_G,
              _?_G_L___C_O_M_P_R_E_S_S_E_D___R_G_B, or _?_G_L___C_O_M_P_R_E_S_S_E_D___R_G_B_A, the GL will replace
              the internal format with the symbolic constant for a specific
              internal format and compress the texture before storage. If no
              corresponding internal format is available, or the GL can not
              compress that image for any reason, the internal format is
              instead replaced with a corresponding base internal format.

              If the _I_n_t_e_r_n_a_l_F_o_r_m_a_t parameter is _?_G_L___S_R_G_B, _?_G_L___S_R_G_B_8,
              _?_G_L___S_R_G_B___A_L_P_H_A , or _?_G_L___S_R_G_B_8___A_L_P_H_A_8, the texture is treated as
              if the red, green, blue, or luminance components are encoded in
              the sRGB color space. Any alpha component is left unchanged. The
              conversion from the sRGB encoded component c s to a linear
              component c l is:

              c l={ c s/12.92if c s&le; 0.04045( c s+0.055/1.055) 2.4if c s>
              0.04045

              Assume c s is the sRGB component in the range [0,1].

              Use the _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___3_D target to try out a resolution and
              format. The implementation will update and recompute its best
              match for the requested storage resolution and format. To then
              query this state, call ggll::ggeettTTeexxLLeevveellPPaarraammeetteerrffvv//33 . If the
              texture cannot be accommodated, texture state is set to 0.

              A one-component texture image uses only the red component of the
              RGBA color extracted from _D_a_t_a . A two-component image uses the
              R and A values. A three-component image uses the R, G, and B
              values. A four-component image uses all of the RGBA components.

              See external documentation.

       tteexxSSuubbIImmaaggee33DD((TTaarrggeett,, LLeevveell,, XXooffffsseett,, YYooffffsseett,, ZZooffffsseett,, WWiiddtthh,, HHeeiigghhtt,,
       DDeepptthh,, FFoorrmmaatt,, TTyyppee,, PPiixxeellss)) -->> ookk

              Types:

                 Target = enum()
                 Level = integer()
                 Xoffset = integer()
                 Yoffset = integer()
                 Zoffset = integer()
                 Width = integer()
                 Height = integer()
                 Depth = integer()
                 Format = enum()
                 Type = enum()
                 Pixels = offset() | mem()

              glTexSubImage

              See external documentation.

       ccooppyyTTeexxSSuubbIImmaaggee33DD((TTaarrggeett,, LLeevveell,, XXooffffsseett,, YYooffffsseett,, ZZooffffsseett,, XX,, YY,,
       WWiiddtthh,, HHeeiigghhtt)) -->> ookk

              Types:

                 Target = enum()
                 Level = integer()
                 Xoffset = integer()
                 Yoffset = integer()
                 Zoffset = integer()
                 X = integer()
                 Y = integer()
                 Width = integer()
                 Height = integer()

              Copy a three-dimensional texture subimage

              _g_l_:_c_o_p_y_T_e_x_S_u_b_I_m_a_g_e_3_D replaces a rectangular portion of a three-
              dimensional texture image with pixels from the current
              _?_G_L___R_E_A_D___B_U_F_F_E_R (rather than from main memory, as is the case
              for ggll::tteexxSSuubbIImmaaggee11DD//77 ).

              The screen-aligned pixel rectangle with lower left corner at ( _X
              , _Y ) and with width _W_i_d_t_h and height _H_e_i_g_h_t replaces the
              portion of the texture array with x indices _X_o_f_f_s_e_t through
              xoffset+width-1, inclusive, and y indices _Y_o_f_f_s_e_t through
              yoffset+height-1, inclusive, at z index _Z_o_f_f_s_e_t and at the
              mipmap level specified by _L_e_v_e_l .

              The pixels in the rectangle are processed exactly as if
              ggll::rreeaaddPPiixxeellss//77 had been called, but the process stops just
              before final conversion. At this point, all pixel component
              values are clamped to the range [0 1] and then converted to the
              texture's internal format for storage in the texel array.

              The destination rectangle in the texture array may not include
              any texels outside the texture array as it was originally
              specified. It is not an error to specify a subtexture with zero
              width or height, but such a specification has no effect.

              If any of the pixels within the specified rectangle of the
              current _?_G_L___R_E_A_D___B_U_F_F_E_R are outside the read window associated
              with the current rendering context, then the values obtained for
              those pixels are undefined.

              No change is made to the _i_n_t_e_r_n_a_l_f_o_r_m_a_t, _w_i_d_t_h, _h_e_i_g_h_t, _d_e_p_t_h,
              or _b_o_r_d_e_r parameters of the specified texture array or to texel
              values outside the specified subregion.

              See external documentation.

       ccoolloorrTTaabbllee((TTaarrggeett,, IInntteerrnnaallffoorrmmaatt,, WWiiddtthh,, FFoorrmmaatt,, TTyyppee,, TTaabbllee)) -->> ookk

              Types:

                 Target = enum()
                 Internalformat = enum()
                 Width = integer()
                 Format = enum()
                 Type = enum()
                 Table = offset() | mem()

              Define a color lookup table

              _g_l_:_c_o_l_o_r_T_a_b_l_e may be used in two ways: to test the actual size
              and color resolution of a lookup table given a particular set of
              parameters, or to load the contents of a color lookup table. Use
              the targets _?_G_L___P_R_O_X_Y___* for the first case and the other targets
              for the second case.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              color table is specified, _D_a_t_a is treated as a byte offset into
              the buffer object's data store.

              If _T_a_r_g_e_t is _?_G_L___C_O_L_O_R___T_A_B_L_E, _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___C_O_L_O_R___T_A_B_L_E,
              or _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___C_O_L_O_R___T_A_B_L_E , _g_l_:_c_o_l_o_r_T_a_b_l_e builds a
              color lookup table from an array of pixels. The pixel array
              specified by _W_i_d_t_h , _F_o_r_m_a_t , _T_y_p_e , and _D_a_t_a is extracted from
              memory and processed just as if ggll::ddrraawwPPiixxeellss//55 were called, but
              processing stops after the final expansion to RGBA is completed.

              The four scale parameters and the four bias parameters that are
              defined for the table are then used to scale and bias the R, G,
              B, and A components of each pixel. (Use _g_l_:_c_o_l_o_r_T_a_b_l_e_P_a_r_a_m_e_t_e_r
              to set these scale and bias parameters.)

              Next, the R, G, B, and A values are clamped to the range [0 1].
              Each pixel is then converted to the internal format specified by
              _I_n_t_e_r_n_a_l_f_o_r_m_a_t . This conversion simply maps the component
              values of the pixel (R, G, B, and A) to the values included in
              the internal format (red, green, blue, alpha, luminance, and
              intensity). The mapping is as follows:_I_n_t_e_r_n_a_l
              _F_o_r_m_a_t_R_e_d_G_r_e_e_n_B_l_u_e_A_l_p_h_a_L_u_m_i_n_a_n_c_e_I_n_t_e_n_s_i_t_y
              _?_G_L___A_L_P_H_A A
              _?_G_L___L_U_M_I_N_A_N_C_E R
              _?_G_L___L_U_M_I_N_A_N_C_E___A_L_P_H_A A R
              _?_G_L___I_N_T_E_N_S_I_T_Y R
              _?_G_L___R_G_B R G B
              _?_G_L___R_G_B_A R G B A


              Finally, the red, green, blue, alpha, luminance, and/or
              intensity components of the resulting pixels are stored in the
              color table. They form a one-dimensional table with indices in
              the range [0 width-1].

              If _T_a_r_g_e_t is _?_G_L___P_R_O_X_Y___*, _g_l_:_c_o_l_o_r_T_a_b_l_e recomputes and stores
              the values of the proxy color table's state variables
              _?_G_L___C_O_L_O_R___T_A_B_L_E___F_O_R_M_A_T, _?_G_L___C_O_L_O_R___T_A_B_L_E___W_I_D_T_H ,
              _?_G_L___C_O_L_O_R___T_A_B_L_E___R_E_D___S_I_Z_E, _?_G_L___C_O_L_O_R___T_A_B_L_E___G_R_E_E_N___S_I_Z_E,
              _?_G_L___C_O_L_O_R___T_A_B_L_E___B_L_U_E___S_I_Z_E , _?_G_L___C_O_L_O_R___T_A_B_L_E___A_L_P_H_A___S_I_Z_E,
              _?_G_L___C_O_L_O_R___T_A_B_L_E___L_U_M_I_N_A_N_C_E___S_I_Z_E, and
              _?_G_L___C_O_L_O_R___T_A_B_L_E___I_N_T_E_N_S_I_T_Y___S_I_Z_E . There is no effect on the image
              or state of any actual color table. If the specified color table
              is too large to be supported, then all the proxy state variables
              listed above are set to zero. Otherwise, the color table could
              be supported by _g_l_:_c_o_l_o_r_T_a_b_l_e using the corresponding non-proxy
              target, and the proxy state variables are set as if that target
              were being defined.

              The proxy state variables can be retrieved by calling
              ggll::ggeettCCoolloorrTTaabblleePPaarraammeetteerrffvv//22 with a target of _?_G_L___P_R_O_X_Y___*. This
              allows the application to decide if a particular _g_l_:_c_o_l_o_r_T_a_b_l_e
              command would succeed, and to determine what the resulting color
              table attributes would be.

              If a color table is enabled, and its width is non-zero, then its
              contents are used to replace a subset of the components of each
              RGBA pixel group, based on the internal format of the table.

              Each pixel group has color components (R, G, B, A) that are in
              the range [0.0 1.0]. The color components are rescaled to the
              size of the color lookup table to form an index. Then a subset
              of the components based on the internal format of the table are
              replaced by the table entry selected by that index. If the color
              components and contents of the table are represented as
              follows:_R_e_p_r_e_s_e_n_t_a_t_i_o_n_M_e_a_n_i_n_g
               r Table index computed from R
              g Table index computed from G
              b Table index computed from B
              a Table index computed from A
              L[i] Luminance value at table index i
              I[i] Intensity value at table index i
               R[i] Red value at table index i
              G[i] Green value at table index i
              B[i] Blue value at table index i
               A[i] Alpha value at table index i


              then the result of color table lookup is as follows:_R_e_s_u_l_t_i_n_g
              _T_e_x_t_u_r_e _C_o_m_p_o_n_e_n_t_s
              _T_a_b_l_e _I_n_t_e_r_n_a_l _F_o_r_m_a_t_R_G_B_A
              _?_G_L___A_L_P_H_ARGBA[a]
              _?_G_L___L_U_M_I_N_A_N_C_EL[r]L[g]L[b]At
              _?_G_L___L_U_M_I_N_A_N_C_E___A_L_P_H_A L[r]L[g]L[b]A[a]
              _?_G_L___I_N_T_E_N_S_I_T_Y I[r]I[g]I[b]I[a]
              _?_G_L___R_G_BR[r] G[g]B[b]A
              _?_G_L___R_G_B_AR[r] G[g]B[b]A[a]


              When _?_G_L___C_O_L_O_R___T_A_B_L_E is enabled, the colors resulting from the
              pixel map operation (if it is enabled) are mapped by the color
              lookup table before being passed to the convolution operation.
              The colors resulting from the convolution operation are modified
              by the post convolution color lookup table when
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___C_O_L_O_R___T_A_B_L_E is enabled. These modified
              colors are then sent to the color matrix operation. Finally, if
              _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___C_O_L_O_R___T_A_B_L_E is enabled, the colors
              resulting from the color matrix operation are mapped by the post
              color matrix color lookup table before being used by the
              histogram operation.

              See external documentation.

       ccoolloorrTTaabblleePPaarraammeetteerrffvv((TTaarrggeett,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Target = enum()
                 Pname = enum()
                 Params = {float(), float(), float(), float()}

              Set color lookup table parameters

              _g_l_:_c_o_l_o_r_T_a_b_l_e_P_a_r_a_m_e_t_e_r is used to specify the scale factors and
              bias terms applied to color components when they are loaded into
              a color table. _T_a_r_g_e_t indicates which color table the scale and
              bias terms apply to; it must be set to _?_G_L___C_O_L_O_R___T_A_B_L_E,
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___C_O_L_O_R___T_A_B_L_E , or
              _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___C_O_L_O_R___T_A_B_L_E.

              _P_n_a_m_e must be _?_G_L___C_O_L_O_R___T_A_B_L_E___S_C_A_L_E to set the scale factors. In
              this case, _P_a_r_a_m_s points to an array of four values, which are
              the scale factors for red, green, blue, and alpha, in that
              order.

              _P_n_a_m_e must be _?_G_L___C_O_L_O_R___T_A_B_L_E___B_I_A_S to set the bias terms. In
              this case, _P_a_r_a_m_s points to an array of four values, which are
              the bias terms for red, green, blue, and alpha, in that order.

              The color tables themselves are specified by calling
              ggll::ccoolloorrTTaabbllee//66 .

              See external documentation.

       ccoolloorrTTaabblleePPaarraammeetteerriivv((TTaarrggeett,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Target = enum()
                 Pname = enum()
                 Params = {integer(), integer(), integer(), integer()}

              See ccoolloorrTTaabblleePPaarraammeetteerrffvv//33

       ccooppyyCCoolloorrTTaabbllee((TTaarrggeett,, IInntteerrnnaallffoorrmmaatt,, XX,, YY,, WWiiddtthh)) -->> ookk

              Types:

                 Target = enum()
                 Internalformat = enum()
                 X = integer()
                 Y = integer()
                 Width = integer()

              Copy pixels into a color table

              _g_l_:_c_o_p_y_C_o_l_o_r_T_a_b_l_e loads a color table with pixels from the
              current _?_G_L___R_E_A_D___B_U_F_F_E_R (rather than from main memory, as is the
              case for ggll::ccoolloorrTTaabbllee//66 ).

              The screen-aligned pixel rectangle with lower-left corner at ( _X
              , _Y ) having width _W_i_d_t_h and height 1 is loaded into the color
              table. If any pixels within this region are outside the window
              that is associated with the GL context, the values obtained for
              those pixels are undefined.

              The pixels in the rectangle are processed just as if
              ggll::rreeaaddPPiixxeellss//77 were called, with _I_n_t_e_r_n_a_l_f_o_r_m_a_t set to RGBA,
              but processing stops after the final conversion to RGBA.

              The four scale parameters and the four bias parameters that are
              defined for the table are then used to scale and bias the R, G,
              B, and A components of each pixel. The scale and bias parameters
              are set by calling ggll::ccoolloorrTTaabblleePPaarraammeetteerrffvv//33 .

              Next, the R, G, B, and A values are clamped to the range [0 1].
              Each pixel is then converted to the internal format specified by
              _I_n_t_e_r_n_a_l_f_o_r_m_a_t . This conversion simply maps the component
              values of the pixel (R, G, B, and A) to the values included in
              the internal format (red, green, blue, alpha, luminance, and
              intensity). The mapping is as follows:_I_n_t_e_r_n_a_l
              _F_o_r_m_a_t_R_e_d_G_r_e_e_n_B_l_u_e_A_l_p_h_a_L_u_m_i_n_a_n_c_e_I_n_t_e_n_s_i_t_y
              _?_G_L___A_L_P_H_A A
              _?_G_L___L_U_M_I_N_A_N_C_E R
              _?_G_L___L_U_M_I_N_A_N_C_E___A_L_P_H_A A R
              _?_G_L___I_N_T_E_N_S_I_T_Y R
              _?_G_L___R_G_B R G B
              _?_G_L___R_G_B_A R G B A


              Finally, the red, green, blue, alpha, luminance, and/or
              intensity components of the resulting pixels are stored in the
              color table. They form a one-dimensional table with indices in
              the range [0 width-1].

              See external documentation.

       ggeettCCoolloorrTTaabbllee((TTaarrggeett,, FFoorrmmaatt,, TTyyppee,, TTaabbllee)) -->> ookk

              Types:

                 Target = enum()
                 Format = enum()
                 Type = enum()
                 Table = mem()

              Retrieve contents of a color lookup table

              _g_l_:_g_e_t_C_o_l_o_r_T_a_b_l_e returns in _T_a_b_l_e the contents of the color
              table specified by _T_a_r_g_e_t . No pixel transfer operations are
              performed, but pixel storage modes that are applicable to
              ggll::rreeaaddPPiixxeellss//77 are performed.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              histogram table is requested, _T_a_b_l_e is treated as a byte offset
              into the buffer object's data store.

              Color components that are requested in the specified _F_o_r_m_a_t ,
              but which are not included in the internal format of the color
              lookup table, are returned as zero. The assignments of internal
              color components to the components requested by _F_o_r_m_a_t
              are_I_n_t_e_r_n_a_l _C_o_m_p_o_n_e_n_t_R_e_s_u_l_t_i_n_g _C_o_m_p_o_n_e_n_t
               Red Red
               Green Green
               Blue Blue
               Alpha Alpha
               Luminance Red
               Intensity Red


              See external documentation.

       ggeettCCoolloorrTTaabblleePPaarraammeetteerrffvv((TTaarrggeett,, PPnnaammee)) -->> {{ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(()),,
       ffllooaatt(())}}

              Types:

                 Target = enum()
                 Pname = enum()

              Get color lookup table parameters

              Returns parameters specific to color table _T_a_r_g_e_t .

              When _P_n_a_m_e is set to _?_G_L___C_O_L_O_R___T_A_B_L_E___S_C_A_L_E or
              _?_G_L___C_O_L_O_R___T_A_B_L_E___B_I_A_S, _g_l_:_g_e_t_C_o_l_o_r_T_a_b_l_e_P_a_r_a_m_e_t_e_r returns the
              color table scale or bias parameters for the table specified by
              _T_a_r_g_e_t . For these queries, _T_a_r_g_e_t must be set to
              _?_G_L___C_O_L_O_R___T_A_B_L_E , _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___C_O_L_O_R___T_A_B_L_E, or
              _?_G_L___P_O_S_T___C_O_L_O_R___M_A_T_R_I_X___C_O_L_O_R___T_A_B_L_E and _P_a_r_a_m_s points to an array
              of four elements, which receive the scale or bias factors for
              red, green, blue, and alpha, in that order.

              _g_l_:_g_e_t_C_o_l_o_r_T_a_b_l_e_P_a_r_a_m_e_t_e_r can also be used to retrieve the
              format and size parameters for a color table. For these queries,
              set _T_a_r_g_e_t to either the color table target or the proxy color
              table target. The format and size parameters are set by
              ggll::ccoolloorrTTaabbllee//66 .

              The following table lists the format and size parameters that
              may be queried. For each symbolic constant listed below for
              _P_n_a_m_e , _P_a_r_a_m_s must point to an array of the given length and
              receive the values indicated._P_a_r_a_m_e_t_e_r_N_M_e_a_n_i_n_g
              _?_G_L___C_O_L_O_R___T_A_B_L_E___F_O_R_M_A_T 1 Internal format (e.g., _?_G_L___R_G_B_A)
              _?_G_L___C_O_L_O_R___T_A_B_L_E___W_I_D_T_H 1 Number of elements in table
              _?_G_L___C_O_L_O_R___T_A_B_L_E___R_E_D___S_I_Z_E 1 Size of red component, in bits
              _?_G_L___C_O_L_O_R___T_A_B_L_E___G_R_E_E_N___S_I_Z_E 1 Size of green component
              _?_G_L___C_O_L_O_R___T_A_B_L_E___B_L_U_E___S_I_Z_E 1 Size of blue component
              _?_G_L___C_O_L_O_R___T_A_B_L_E___A_L_P_H_A___S_I_Z_E 1 Size of alpha component
              _?_G_L___C_O_L_O_R___T_A_B_L_E___L_U_M_I_N_A_N_C_E___S_I_Z_E 1 Size of luminance component
              _?_G_L___C_O_L_O_R___T_A_B_L_E___I_N_T_E_N_S_I_T_Y___S_I_Z_E 1 Size of intensity component


              See external documentation.

       ggeettCCoolloorrTTaabblleePPaarraammeetteerriivv((TTaarrggeett,, PPnnaammee)) -->> {{iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(()),, iinntteeggeerr(())}}

              Types:

                 Target = enum()
                 Pname = enum()

              See ggeettCCoolloorrTTaabblleePPaarraammeetteerrffvv//22

       ccoolloorrSSuubbTTaabbllee((TTaarrggeett,, SSttaarrtt,, CCoouunntt,, FFoorrmmaatt,, TTyyppee,, DDaattaa)) -->> ookk

              Types:

                 Target = enum()
                 Start = integer()
                 Count = integer()
                 Format = enum()
                 Type = enum()
                 Data = offset() | mem()

              Respecify a portion of a color table

              _g_l_:_c_o_l_o_r_S_u_b_T_a_b_l_e is used to respecify a contiguous portion of a
              color table previously defined using ggll::ccoolloorrTTaabbllee//66 . The
              pixels referenced by _D_a_t_a replace the portion of the existing
              table from indices _S_t_a_r_t to start+count-1, inclusive. This
              region may not include any entries outside the range of the
              color table as it was originally specified. It is not an error
              to specify a subtexture with width of 0, but such a
              specification has no effect.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              portion of a color table is respecified, _D_a_t_a is treated as a
              byte offset into the buffer object's data store.

              See external documentation.

       ccooppyyCCoolloorrSSuubbTTaabbllee((TTaarrggeett,, SSttaarrtt,, XX,, YY,, WWiiddtthh)) -->> ookk

              Types:

                 Target = enum()
                 Start = integer()
                 X = integer()
                 Y = integer()
                 Width = integer()

              Respecify a portion of a color table

              _g_l_:_c_o_p_y_C_o_l_o_r_S_u_b_T_a_b_l_e is used to respecify a contiguous portion
              of a color table previously defined using ggll::ccoolloorrTTaabbllee//66 . The
              pixels copied from the framebuffer replace the portion of the
              existing table from indices _S_t_a_r_t to start+x-1, inclusive. This
              region may not include any entries outside the range of the
              color table, as was originally specified. It is not an error to
              specify a subtexture with width of 0, but such a specification
              has no effect.

              See external documentation.

       ccoonnvvoolluuttiioonnFFiilltteerr11DD((TTaarrggeett,, IInntteerrnnaallffoorrmmaatt,, WWiiddtthh,, FFoorrmmaatt,, TTyyppee,, IImmaaggee))
       -->> ookk

              Types:

                 Target = enum()
                 Internalformat = enum()
                 Width = integer()
                 Format = enum()
                 Type = enum()
                 Image = offset() | mem()

              Define a one-dimensional convolution filter

              _g_l_:_c_o_n_v_o_l_u_t_i_o_n_F_i_l_t_e_r_1_D builds a one-dimensional convolution
              filter kernel from an array of pixels.

              The pixel array specified by _W_i_d_t_h , _F_o_r_m_a_t , _T_y_p_e , and _D_a_t_a is
              extracted from memory and processed just as if ggll::ddrraawwPPiixxeellss//55
              were called, but processing stops after the final expansion to
              RGBA is completed.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              convolution filter is specified, _D_a_t_a is treated as a byte
              offset into the buffer object's data store.

              The R, G, B, and A components of each pixel are next scaled by
              the four 1D _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___S_C_A_L_E parameters and biased
              by the four 1D _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___B_I_A_S parameters. (The
              scale and bias parameters are set by ggll::ccoonnvvoolluuttiioonnPPaarraammeetteerrff//33
              using the _?_G_L___C_O_N_V_O_L_U_T_I_O_N___1_D target and the names
              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___S_C_A_L_E and _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___B_I_A_S .
              The parameters themselves are vectors of four values that are
              applied to red, green, blue, and alpha, in that order.) The R,
              G, B, and A values are not clamped to [0,1] at any time during
              this process.

              Each pixel is then converted to the internal format specified by
              _I_n_t_e_r_n_a_l_f_o_r_m_a_t . This conversion simply maps the component
              values of the pixel (R, G, B, and A) to the values included in
              the internal format (red, green, blue, alpha, luminance, and
              intensity). The mapping is as follows:_I_n_t_e_r_n_a_l
              _F_o_r_m_a_t_R_e_d_G_r_e_e_n_B_l_u_e_A_l_p_h_a_L_u_m_i_n_a_n_c_e_I_n_t_e_n_s_i_t_y
              _?_G_L___A_L_P_H_A A
              _?_G_L___L_U_M_I_N_A_N_C_E R
              _?_G_L___L_U_M_I_N_A_N_C_E___A_L_P_H_A A R
              _?_G_L___I_N_T_E_N_S_I_T_Y R
              _?_G_L___R_G_B R G B
              _?_G_L___R_G_B_A R G B A


              The red, green, blue, alpha, luminance, and/or intensity
              components of the resulting pixels are stored in floating-point
              rather than integer format. They form a one-dimensional filter
              kernel image indexed with coordinate _i such that _i starts at 0
              and increases from left to right. Kernel location _i is derived
              from the _ith pixel, counting from 0.

              Note that after a convolution is performed, the resulting color
              components are also scaled by their corresponding
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___c___S_C_A_L_E parameters and biased by their
              corresponding _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___c___B_I_A_S parameters (where _c
              takes on the values _R_E_D, _G_R_E_E_N, _B_L_U_E, and _A_L_P_H_A). These
              parameters are set by ggll::ppiixxeellTTrraannssffeerrff//22 .

              See external documentation.

       ccoonnvvoolluuttiioonnFFiilltteerr22DD((TTaarrggeett,, IInntteerrnnaallffoorrmmaatt,, WWiiddtthh,, HHeeiigghhtt,, FFoorrmmaatt,,
       TTyyppee,, IImmaaggee)) -->> ookk

              Types:

                 Target = enum()
                 Internalformat = enum()
                 Width = integer()
                 Height = integer()
                 Format = enum()
                 Type = enum()
                 Image = offset() | mem()

              Define a two-dimensional convolution filter

              _g_l_:_c_o_n_v_o_l_u_t_i_o_n_F_i_l_t_e_r_2_D builds a two-dimensional convolution
              filter kernel from an array of pixels.

              The pixel array specified by _W_i_d_t_h , _H_e_i_g_h_t , _F_o_r_m_a_t , _T_y_p_e ,
              and _D_a_t_a is extracted from memory and processed just as if
              ggll::ddrraawwPPiixxeellss//55 were called, but processing stops after the
              final expansion to RGBA is completed.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              convolution filter is specified, _D_a_t_a is treated as a byte
              offset into the buffer object's data store.

              The R, G, B, and A components of each pixel are next scaled by
              the four 2D _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___S_C_A_L_E parameters and biased
              by the four 2D _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___B_I_A_S parameters. (The
              scale and bias parameters are set by ggll::ccoonnvvoolluuttiioonnPPaarraammeetteerrff//33
              using the _?_G_L___C_O_N_V_O_L_U_T_I_O_N___2_D target and the names
              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___S_C_A_L_E and _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___B_I_A_S .
              The parameters themselves are vectors of four values that are
              applied to red, green, blue, and alpha, in that order.) The R,
              G, B, and A values are not clamped to [0,1] at any time during
              this process.

              Each pixel is then converted to the internal format specified by
              _I_n_t_e_r_n_a_l_f_o_r_m_a_t . This conversion simply maps the component
              values of the pixel (R, G, B, and A) to the values included in
              the internal format (red, green, blue, alpha, luminance, and
              intensity). The mapping is as follows:_I_n_t_e_r_n_a_l
              _F_o_r_m_a_t_R_e_d_G_r_e_e_n_B_l_u_e_A_l_p_h_a_L_u_m_i_n_a_n_c_e_I_n_t_e_n_s_i_t_y
              _?_G_L___A_L_P_H_A A
              _?_G_L___L_U_M_I_N_A_N_C_E R
              _?_G_L___L_U_M_I_N_A_N_C_E___A_L_P_H_A A R
              _?_G_L___I_N_T_E_N_S_I_T_Y R
              _?_G_L___R_G_B R G B
              _?_G_L___R_G_B_A R G B A


              The red, green, blue, alpha, luminance, and/or intensity
              components of the resulting pixels are stored in floating-point
              rather than integer format. They form a two-dimensional filter
              kernel image indexed with coordinates _i and _j such that _i starts
              at zero and increases from left to right, and _j starts at zero
              and increases from bottom to top. Kernel location _i_,_j is derived
              from the _Nth pixel, where _N is _i+_j* _W_i_d_t_h .

              Note that after a convolution is performed, the resulting color
              components are also scaled by their corresponding
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___c___S_C_A_L_E parameters and biased by their
              corresponding _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___c___B_I_A_S parameters (where _c
              takes on the values _R_E_D, _G_R_E_E_N, _B_L_U_E, and _A_L_P_H_A). These
              parameters are set by ggll::ppiixxeellTTrraannssffeerrff//22 .

              See external documentation.

       ccoonnvvoolluuttiioonnPPaarraammeetteerrff((TTaarrggeett,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Target = enum()
                 Pname = enum()
                 Params = {float()}

              Set convolution parameters

              _g_l_:_c_o_n_v_o_l_u_t_i_o_n_P_a_r_a_m_e_t_e_r sets the value of a convolution
              parameter.

              _T_a_r_g_e_t selects the convolution filter to be affected:
              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___1_D, _?_G_L___C_O_N_V_O_L_U_T_I_O_N___2_D , or _?_G_L___S_E_P_A_R_A_B_L_E___2_D for
              the 1D, 2D, or separable 2D filter, respectively.

              _P_n_a_m_e selects the parameter to be changed.
              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___S_C_A_L_E and _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___B_I_A_S
              affect the definition of the convolution filter kernel; see
              ggll::ccoonnvvoolluuttiioonnFFiilltteerr11DD//66 , ggll::ccoonnvvoolluuttiioonnFFiilltteerr22DD//77 , and
              ggll::sseeppaarraabblleeFFiilltteerr22DD//88 for details. In these cases, _P_a_r_a_m_s v is
              an array of four values to be applied to red, green, blue, and
              alpha values, respectively. The initial value for
              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___S_C_A_L_E is (1, 1, 1, 1), and the initial
              value for _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___B_I_A_S is (0, 0, 0, 0).

              A _P_n_a_m_e value of _?_G_L___C_O_N_V_O_L_U_T_I_O_N___B_O_R_D_E_R___M_O_D_E controls the
              convolution border mode. The accepted modes are:

              _?_G_L___R_E_D_U_C_E: The image resulting from convolution is smaller than
              the source image. If the filter width is Wf and height is Hf,
              and the source image width is Ws and height is Hs, then the
              convolved image width will be Ws-Wf+1 and height will be Hs-Hf
              +1. (If this reduction would generate an image with zero or
              negative width and/or height, the output is simply null, with no
              error generated.) The coordinates of the image resulting from
              convolution are zero through Ws-Wf in width and zero through Hs-
              Hf in height.

              _?_G_L___C_O_N_S_T_A_N_T___B_O_R_D_E_R: The image resulting from convolution is the
              same size as the source image, and processed as if the source
              image were surrounded by pixels with their color specified by
              the _?_G_L___C_O_N_V_O_L_U_T_I_O_N___B_O_R_D_E_R___C_O_L_O_R.

              _?_G_L___R_E_P_L_I_C_A_T_E___B_O_R_D_E_R: The image resulting from convolution is
              the same size as the source image, and processed as if the
              outermost pixel on the border of the source image were
              replicated.

              See external documentation.

       ccoonnvvoolluuttiioonnPPaarraammeetteerrffvv((TTaarrggeett::::eennuumm(()),, PPnnaammee::::eennuumm(()),, PPaarraammss)) -->> ookk

              Types:

                 Params = {Params::{float()}}

              Equivalent to ccoonnvvoolluuttiioonnPPaarraammeetteerrff((TTaarrggeett,, PPnnaammee,, PPaarraammss)).

       ccoonnvvoolluuttiioonnPPaarraammeetteerrii((TTaarrggeett,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Target = enum()
                 Pname = enum()
                 Params = {integer()}

              See ccoonnvvoolluuttiioonnPPaarraammeetteerrff//33

       ccoonnvvoolluuttiioonnPPaarraammeetteerriivv((TTaarrggeett::::eennuumm(()),, PPnnaammee::::eennuumm(()),, PPaarraammss)) -->> ookk

              Types:

                 Params = {Params::{integer()}}

              Equivalent to ccoonnvvoolluuttiioonnPPaarraammeetteerrii((TTaarrggeett,, PPnnaammee,, PPaarraammss)).

       ccooppyyCCoonnvvoolluuttiioonnFFiilltteerr11DD((TTaarrggeett,, IInntteerrnnaallffoorrmmaatt,, XX,, YY,, WWiiddtthh)) -->> ookk

              Types:

                 Target = enum()
                 Internalformat = enum()
                 X = integer()
                 Y = integer()
                 Width = integer()

              Copy pixels into a one-dimensional convolution filter

              _g_l_:_c_o_p_y_C_o_n_v_o_l_u_t_i_o_n_F_i_l_t_e_r_1_D defines a one-dimensional convolution
              filter kernel with pixels from the current _?_G_L___R_E_A_D___B_U_F_F_E_R
              (rather than from main memory, as is the case for
              ggll::ccoonnvvoolluuttiioonnFFiilltteerr11DD//66 ).

              The screen-aligned pixel rectangle with lower-left corner at ( _X
              , _Y ), width _W_i_d_t_h and height 1 is used to define the
              convolution filter. If any pixels within this region are outside
              the window that is associated with the GL context, the values
              obtained for those pixels are undefined.

              The pixels in the rectangle are processed exactly as if
              ggll::rreeaaddPPiixxeellss//77 had been called with _f_o_r_m_a_t set to RGBA, but the
              process stops just before final conversion. The R, G, B, and A
              components of each pixel are next scaled by the four 1D
              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___S_C_A_L_E parameters and biased by the four
              1D _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___B_I_A_S parameters. (The scale and bias
              parameters are set by ggll::ccoonnvvoolluuttiioonnPPaarraammeetteerrff//33 using the
              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___1_D target and the names
              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___S_C_A_L_E and _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___B_I_A_S .
              The parameters themselves are vectors of four values that are
              applied to red, green, blue, and alpha, in that order.) The R,
              G, B, and A values are not clamped to [0,1] at any time during
              this process.

              Each pixel is then converted to the internal format specified by
              _I_n_t_e_r_n_a_l_f_o_r_m_a_t . This conversion simply maps the component
              values of the pixel (R, G, B, and A) to the values included in
              the internal format (red, green, blue, alpha, luminance, and
              intensity). The mapping is as follows:_I_n_t_e_r_n_a_l
              _F_o_r_m_a_t_R_e_d_G_r_e_e_n_B_l_u_e_A_l_p_h_a_L_u_m_i_n_a_n_c_e_I_n_t_e_n_s_i_t_y
              _?_G_L___A_L_P_H_A A
              _?_G_L___L_U_M_I_N_A_N_C_E R
              _?_G_L___L_U_M_I_N_A_N_C_E___A_L_P_H_A A R
              _?_G_L___I_N_T_E_N_S_I_T_Y R
              _?_G_L___R_G_B R G B
              _?_G_L___R_G_B_A R G B A


              The red, green, blue, alpha, luminance, and/or intensity
              components of the resulting pixels are stored in floating-point
              rather than integer format.

              Pixel ordering is such that lower x screen coordinates
              correspond to lower _i filter image coordinates.

              Note that after a convolution is performed, the resulting color
              components are also scaled by their corresponding
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___c___S_C_A_L_E parameters and biased by their
              corresponding _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___c___B_I_A_S parameters (where _c
              takes on the values _R_E_D, _G_R_E_E_N, _B_L_U_E, and _A_L_P_H_A). These
              parameters are set by ggll::ppiixxeellTTrraannssffeerrff//22 .

              See external documentation.

       ccooppyyCCoonnvvoolluuttiioonnFFiilltteerr22DD((TTaarrggeett,, IInntteerrnnaallffoorrmmaatt,, XX,, YY,, WWiiddtthh,, HHeeiigghhtt)) -->>
       ookk

              Types:

                 Target = enum()
                 Internalformat = enum()
                 X = integer()
                 Y = integer()
                 Width = integer()
                 Height = integer()

              Copy pixels into a two-dimensional convolution filter

              _g_l_:_c_o_p_y_C_o_n_v_o_l_u_t_i_o_n_F_i_l_t_e_r_2_D defines a two-dimensional convolution
              filter kernel with pixels from the current _?_G_L___R_E_A_D___B_U_F_F_E_R
              (rather than from main memory, as is the case for
              ggll::ccoonnvvoolluuttiioonnFFiilltteerr22DD//77 ).

              The screen-aligned pixel rectangle with lower-left corner at ( _X
              , _Y ), width _W_i_d_t_h and height _H_e_i_g_h_t is used to define the
              convolution filter. If any pixels within this region are outside
              the window that is associated with the GL context, the values
              obtained for those pixels are undefined.

              The pixels in the rectangle are processed exactly as if
              ggll::rreeaaddPPiixxeellss//77 had been called with _f_o_r_m_a_t set to RGBA, but the
              process stops just before final conversion. The R, G, B, and A
              components of each pixel are next scaled by the four 2D
              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___S_C_A_L_E parameters and biased by the four
              2D _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___B_I_A_S parameters. (The scale and bias
              parameters are set by ggll::ccoonnvvoolluuttiioonnPPaarraammeetteerrff//33 using the
              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___2_D target and the names
              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___S_C_A_L_E and _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___B_I_A_S .
              The parameters themselves are vectors of four values that are
              applied to red, green, blue, and alpha, in that order.) The R,
              G, B, and A values are not clamped to [0,1] at any time during
              this process.

              Each pixel is then converted to the internal format specified by
              _I_n_t_e_r_n_a_l_f_o_r_m_a_t . This conversion simply maps the component
              values of the pixel (R, G, B, and A) to the values included in
              the internal format (red, green, blue, alpha, luminance, and
              intensity). The mapping is as follows:_I_n_t_e_r_n_a_l
              _F_o_r_m_a_t_R_e_d_G_r_e_e_n_B_l_u_e_A_l_p_h_a_L_u_m_i_n_a_n_c_e_I_n_t_e_n_s_i_t_y
              _?_G_L___A_L_P_H_A A
              _?_G_L___L_U_M_I_N_A_N_C_E R
              _?_G_L___L_U_M_I_N_A_N_C_E___A_L_P_H_A A R
              _?_G_L___I_N_T_E_N_S_I_T_Y R
              _?_G_L___R_G_B R G B
              _?_G_L___R_G_B_A R G B A


              The red, green, blue, alpha, luminance, and/or intensity
              components of the resulting pixels are stored in floating-point
              rather than integer format.

              Pixel ordering is such that lower x screen coordinates
              correspond to lower _i filter image coordinates, and lower y
              screen coordinates correspond to lower _j filter image
              coordinates.

              Note that after a convolution is performed, the resulting color
              components are also scaled by their corresponding
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___c___S_C_A_L_E parameters and biased by their
              corresponding _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___c___B_I_A_S parameters (where _c
              takes on the values _R_E_D, _G_R_E_E_N, _B_L_U_E, and _A_L_P_H_A). These
              parameters are set by ggll::ppiixxeellTTrraannssffeerrff//22 .

              See external documentation.

       ggeettCCoonnvvoolluuttiioonnFFiilltteerr((TTaarrggeett,, FFoorrmmaatt,, TTyyppee,, IImmaaggee)) -->> ookk

              Types:

                 Target = enum()
                 Format = enum()
                 Type = enum()
                 Image = mem()

              Get current 1D or 2D convolution filter kernel

              _g_l_:_g_e_t_C_o_n_v_o_l_u_t_i_o_n_F_i_l_t_e_r returns the current 1D or 2D convolution
              filter kernel as an image. The one- or two-dimensional image is
              placed in _I_m_a_g_e according to the specifications in _F_o_r_m_a_t and
              _T_y_p_e . No pixel transfer operations are performed on this image,
              but the relevant pixel storage modes are applied.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              convolution filter is requested, _I_m_a_g_e is treated as a byte
              offset into the buffer object's data store.

              Color components that are present in _F_o_r_m_a_t but not included in
              the internal format of the filter are returned as zero. The
              assignments of internal color components to the components of
              _F_o_r_m_a_t are as follows._I_n_t_e_r_n_a_l _C_o_m_p_o_n_e_n_t_R_e_s_u_l_t_i_n_g _C_o_m_p_o_n_e_n_t
               Red Red
               Green Green
               Blue Blue
               Alpha Alpha
               Luminance Red
               Intensity Red


              See external documentation.

       ggeettCCoonnvvoolluuttiioonnPPaarraammeetteerrffvv((TTaarrggeett,, PPnnaammee)) -->> {{ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(()),,
       ffllooaatt(())}}

              Types:

                 Target = enum()
                 Pname = enum()

              Get convolution parameters

              _g_l_:_g_e_t_C_o_n_v_o_l_u_t_i_o_n_P_a_r_a_m_e_t_e_r retrieves convolution parameters.
              _T_a_r_g_e_t determines which convolution filter is queried. _P_n_a_m_e
              determines which parameter is returned:

              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___B_O_R_D_E_R___M_O_D_E: The convolution border mode. See
              ggll::ccoonnvvoolluuttiioonnPPaarraammeetteerrff//33 for a list of border modes.

              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___B_O_R_D_E_R___C_O_L_O_R: The current convolution border
              color. _P_a_r_a_m_s must be a pointer to an array of four elements,
              which will receive the red, green, blue, and alpha border
              colors.

              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___S_C_A_L_E: The current filter scale factors.
              _P_a_r_a_m_s must be a pointer to an array of four elements, which
              will receive the red, green, blue, and alpha filter scale
              factors in that order.

              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___B_I_A_S: The current filter bias factors.
              _P_a_r_a_m_s must be a pointer to an array of four elements, which
              will receive the red, green, blue, and alpha filter bias terms
              in that order.

              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_O_R_M_A_T: The current internal format. See
              ggll::ccoonnvvoolluuttiioonnFFiilltteerr11DD//66 , ggll::ccoonnvvoolluuttiioonnFFiilltteerr22DD//77 , and
              ggll::sseeppaarraabblleeFFiilltteerr22DD//88 for lists of allowable formats.

              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___W_I_D_T_H: The current filter image width.

              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___H_E_I_G_H_T: The current filter image height.

              _?_G_L___M_A_X___C_O_N_V_O_L_U_T_I_O_N___W_I_D_T_H: The maximum acceptable filter image
              width.

              _?_G_L___M_A_X___C_O_N_V_O_L_U_T_I_O_N___H_E_I_G_H_T: The maximum acceptable filter image
              height.

              See external documentation.

       ggeettCCoonnvvoolluuttiioonnPPaarraammeetteerriivv((TTaarrggeett,, PPnnaammee)) -->> {{iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(()),, iinntteeggeerr(())}}

              Types:

                 Target = enum()
                 Pname = enum()

              See ggeettCCoonnvvoolluuttiioonnPPaarraammeetteerrffvv//22

       sseeppaarraabblleeFFiilltteerr22DD((TTaarrggeett,, IInntteerrnnaallffoorrmmaatt,, WWiiddtthh,, HHeeiigghhtt,, FFoorrmmaatt,, TTyyppee,,
       RRooww,, CCoolluummnn)) -->> ookk

              Types:

                 Target = enum()
                 Internalformat = enum()
                 Width = integer()
                 Height = integer()
                 Format = enum()
                 Type = enum()
                 Row = offset() | mem()
                 Column = offset() | mem()

              Define a separable two-dimensional convolution filter

              _g_l_:_s_e_p_a_r_a_b_l_e_F_i_l_t_e_r_2_D builds a two-dimensional separable
              convolution filter kernel from two arrays of pixels.

              The pixel arrays specified by ( _W_i_d_t_h , _F_o_r_m_a_t , _T_y_p_e , _R_o_w )
              and ( _H_e_i_g_h_t , _F_o_r_m_a_t , _T_y_p_e , _C_o_l_u_m_n ) are processed just as if
              they had been passed to ggll::ddrraawwPPiixxeellss//55 , but processing stops
              after the final expansion to RGBA is completed.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              convolution filter is specified, _R_o_w and _C_o_l_u_m_n are treated as
              byte offsets into the buffer object's data store.

              Next, the R, G, B, and A components of all pixels in both arrays
              are scaled by the four separable 2D _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___S_C_A_L_E
              parameters and biased by the four separable 2D
              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___B_I_A_S parameters. (The scale and bias
              parameters are set by ggll::ccoonnvvoolluuttiioonnPPaarraammeetteerrff//33 using the
              _?_G_L___S_E_P_A_R_A_B_L_E___2_D target and the names
              _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___S_C_A_L_E and _?_G_L___C_O_N_V_O_L_U_T_I_O_N___F_I_L_T_E_R___B_I_A_S.
              The parameters themselves are vectors of four values that are
              applied to red, green, blue, and alpha, in that order.) The R,
              G, B, and A values are not clamped to [0,1] at any time during
              this process.

              Each pixel is then converted to the internal format specified by
              _I_n_t_e_r_n_a_l_f_o_r_m_a_t . This conversion simply maps the component
              values of the pixel (R, G, B, and A) to the values included in
              the internal format (red, green, blue, alpha, luminance, and
              intensity). The mapping is as follows:_I_n_t_e_r_n_a_l
              _F_o_r_m_a_t_R_e_d_G_r_e_e_n_B_l_u_e_A_l_p_h_a_L_u_m_i_n_a_n_c_e_I_n_t_e_n_s_i_t_y
              _?_G_L___L_U_M_I_N_A_N_C_E R
              _?_G_L___L_U_M_I_N_A_N_C_E___A_L_P_H_A A R
              _?_G_L___I_N_T_E_N_S_I_T_Y R
              _?_G_L___R_G_B R G B
              _?_G_L___R_G_B_A R G B A


              The red, green, blue, alpha, luminance, and/or intensity
              components of the resulting pixels are stored in floating-point
              rather than integer format. They form two one-dimensional filter
              kernel images. The row image is indexed by coordinate _i starting
              at zero and increasing from left to right. Each location in the
              row image is derived from element _i of _R_o_w . The column image is
              indexed by coordinate _j starting at zero and increasing from
              bottom to top. Each location in the column image is derived from
              element _j of _C_o_l_u_m_n .

              Note that after a convolution is performed, the resulting color
              components are also scaled by their corresponding
              _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___c___S_C_A_L_E parameters and biased by their
              corresponding _?_G_L___P_O_S_T___C_O_N_V_O_L_U_T_I_O_N___c___B_I_A_S parameters (where _c
              takes on the values _R_E_D, _G_R_E_E_N, _B_L_U_E, and _A_L_P_H_A). These
              parameters are set by ggll::ppiixxeellTTrraannssffeerrff//22 .

              See external documentation.

       ggeettHHiissttooggrraamm((TTaarrggeett,, RReesseett,, FFoorrmmaatt,, TTyyppee,, VVaalluueess)) -->> ookk

              Types:

                 Target = enum()
                 Reset = 0 | 1
                 Format = enum()
                 Type = enum()
                 Values = mem()

              Get histogram table

              _g_l_:_g_e_t_H_i_s_t_o_g_r_a_m returns the current histogram table as a one-
              dimensional image with the same width as the histogram. No pixel
              transfer operations are performed on this image, but pixel
              storage modes that are applicable to 1D images are honored.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              histogram table is requested, _V_a_l_u_e_s is treated as a byte offset
              into the buffer object's data store.

              Color components that are requested in the specified _F_o_r_m_a_t ,
              but which are not included in the internal format of the
              histogram, are returned as zero. The assignments of internal
              color components to the components requested by _F_o_r_m_a_t
              are:_I_n_t_e_r_n_a_l _C_o_m_p_o_n_e_n_t_R_e_s_u_l_t_i_n_g _C_o_m_p_o_n_e_n_t
               Red Red
               Green Green
               Blue Blue
               Alpha Alpha
               Luminance Red


              See external documentation.

       ggeettHHiissttooggrraammPPaarraammeetteerrffvv((TTaarrggeett,, PPnnaammee)) -->> {{ffllooaatt(())}}

              Types:

                 Target = enum()
                 Pname = enum()

              Get histogram parameters

              _g_l_:_g_e_t_H_i_s_t_o_g_r_a_m_P_a_r_a_m_e_t_e_r is used to query parameter values for
              the current histogram or for a proxy. The histogram state
              information may be queried by calling _g_l_:_g_e_t_H_i_s_t_o_g_r_a_m_P_a_r_a_m_e_t_e_r
              with a _T_a_r_g_e_t of _?_G_L___H_I_S_T_O_G_R_A_M (to obtain information for the
              current histogram table) or _?_G_L___P_R_O_X_Y___H_I_S_T_O_G_R_A_M (to obtain
              information from the most recent proxy request) and one of the
              following values for the _P_n_a_m_e argument:_P_a_r_a_m_e_t_e_r_D_e_s_c_r_i_p_t_i_o_n
              _?_G_L___H_I_S_T_O_G_R_A_M___W_I_D_T_H Histogram table width
              _?_G_L___H_I_S_T_O_G_R_A_M___F_O_R_M_A_T Internal format
              _?_G_L___H_I_S_T_O_G_R_A_M___R_E_D___S_I_Z_E Red component counter size, in bits
              _?_G_L___H_I_S_T_O_G_R_A_M___G_R_E_E_N___S_I_Z_E Green component counter size, in bits
              _?_G_L___H_I_S_T_O_G_R_A_M___B_L_U_E___S_I_Z_E Blue component counter size, in bits
              _?_G_L___H_I_S_T_O_G_R_A_M___A_L_P_H_A___S_I_Z_E Alpha component counter size, in bits
              _?_G_L___H_I_S_T_O_G_R_A_M___L_U_M_I_N_A_N_C_E___S_I_Z_E Luminance component counter size,
              in bits
              _?_G_L___H_I_S_T_O_G_R_A_M___S_I_N_K Value of the _s_i_n_k parameter


              See external documentation.

       ggeettHHiissttooggrraammPPaarraammeetteerriivv((TTaarrggeett,, PPnnaammee)) -->> {{iinntteeggeerr(())}}

              Types:

                 Target = enum()
                 Pname = enum()

              See ggeettHHiissttooggrraammPPaarraammeetteerrffvv//22

       ggeettMMiinnmmaaxx((TTaarrggeett,, RReesseett,, FFoorrmmaatt,, TTyyppeess,, VVaalluueess)) -->> ookk

              Types:

                 Target = enum()
                 Reset = 0 | 1
                 Format = enum()
                 Types = enum()
                 Values = mem()

              Get minimum and maximum pixel values

              _g_l_:_g_e_t_M_i_n_m_a_x returns the accumulated minimum and maximum pixel
              values (computed on a per-component basis) in a one-dimensional
              image of width 2. The first set of return values are the minima,
              and the second set of return values are the maxima. The format
              of the return values is determined by _F_o_r_m_a_t , and their type is
              determined by _T_y_p_e_s .

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while
              minimum and maximum pixel values are requested, _V_a_l_u_e_s is
              treated as a byte offset into the buffer object's data store.

              No pixel transfer operations are performed on the return values,
              but pixel storage modes that are applicable to one-dimensional
              images are performed. Color components that are requested in the
              specified _F_o_r_m_a_t , but that are not included in the internal
              format of the minmax table, are returned as zero. The assignment
              of internal color components to the components requested by
              _F_o_r_m_a_t are as follows:_I_n_t_e_r_n_a_l _C_o_m_p_o_n_e_n_t_R_e_s_u_l_t_i_n_g _C_o_m_p_o_n_e_n_t
               Red Red
               Green Green
               Blue Blue
               Alpha Alpha
               Luminance Red


              If _R_e_s_e_t is _?_G_L___T_R_U_E, the minmax table entries corresponding to
              the return values are reset to their initial values. Minimum and
              maximum values that are not returned are not modified, even if
              _R_e_s_e_t is _?_G_L___T_R_U_E.

              See external documentation.

       ggeettMMiinnmmaaxxPPaarraammeetteerrffvv((TTaarrggeett,, PPnnaammee)) -->> {{ffllooaatt(())}}

              Types:

                 Target = enum()
                 Pname = enum()

              Get minmax parameters

              _g_l_:_g_e_t_M_i_n_m_a_x_P_a_r_a_m_e_t_e_r retrieves parameters for the current
              minmax table by setting _P_n_a_m_e to one of the following
              values:_P_a_r_a_m_e_t_e_r_D_e_s_c_r_i_p_t_i_o_n
              _?_G_L___M_I_N_M_A_X___F_O_R_M_A_T Internal format of minmax table
              _?_G_L___M_I_N_M_A_X___S_I_N_K Value of the _s_i_n_k parameter


              See external documentation.

       ggeettMMiinnmmaaxxPPaarraammeetteerriivv((TTaarrggeett,, PPnnaammee)) -->> {{iinntteeggeerr(())}}

              Types:

                 Target = enum()
                 Pname = enum()

              See ggeettMMiinnmmaaxxPPaarraammeetteerrffvv//22

       hhiissttooggrraamm((TTaarrggeett,, WWiiddtthh,, IInntteerrnnaallffoorrmmaatt,, SSiinnkk)) -->> ookk

              Types:

                 Target = enum()
                 Width = integer()
                 Internalformat = enum()
                 Sink = 0 | 1

              Define histogram table

              When _?_G_L___H_I_S_T_O_G_R_A_M is enabled, RGBA color components are
              converted to histogram table indices by clamping to the range
              [0,1], multiplying by the width of the histogram table, and
              rounding to the nearest integer. The table entries selected by
              the RGBA indices are then incremented. (If the internal format
              of the histogram table includes luminance, then the index
              derived from the R color component determines the luminance
              table entry to be incremented.) If a histogram table entry is
              incremented beyond its maximum value, then its value becomes
              undefined. (This is not an error.)

              Histogramming is performed only for RGBA pixels (though these
              may be specified originally as color indices and converted to
              RGBA by index table lookup). Histogramming is enabled with
              ggll::eennaabbllee//11 and disabled with ggll::eennaabbllee//11 .

              When _T_a_r_g_e_t is _?_G_L___H_I_S_T_O_G_R_A_M, _g_l_:_h_i_s_t_o_g_r_a_m redefines the current
              histogram table to have _W_i_d_t_h entries of the format specified by
              _I_n_t_e_r_n_a_l_f_o_r_m_a_t . The entries are indexed 0 through width-1, and
              all entries are initialized to zero. The values in the previous
              histogram table, if any, are lost. If _S_i_n_k is _?_G_L___T_R_U_E , then
              pixels are discarded after histogramming; no further processing
              of the pixels takes place, and no drawing, texture loading, or
              pixel readback will result.

              When _T_a_r_g_e_t is _?_G_L___P_R_O_X_Y___H_I_S_T_O_G_R_A_M, _g_l_:_h_i_s_t_o_g_r_a_m computes all
              state information as if the histogram table were to be
              redefined, but does not actually define the new table. If the
              requested histogram table is too large to be supported, then the
              state information will be set to zero. This provides a way to
              determine if a histogram table with the given parameters can be
              supported.

              See external documentation.

       mmiinnmmaaxx((TTaarrggeett,, IInntteerrnnaallffoorrmmaatt,, SSiinnkk)) -->> ookk

              Types:

                 Target = enum()
                 Internalformat = enum()
                 Sink = 0 | 1

              Define minmax table

              When _?_G_L___M_I_N_M_A_X is enabled, the RGBA components of incoming
              pixels are compared to the minimum and maximum values for each
              component, which are stored in the two-element minmax table.
              (The first element stores the minima, and the second element
              stores the maxima.) If a pixel component is greater than the
              corresponding component in the maximum element, then the maximum
              element is updated with the pixel component value. If a pixel
              component is less than the corresponding component in the
              minimum element, then the minimum element is updated with the
              pixel component value. (In both cases, if the internal format of
              the minmax table includes luminance, then the R color component
              of incoming pixels is used for comparison.) The contents of the
              minmax table may be retrieved at a later time by calling
              ggll::ggeettMMiinnmmaaxx//55 . The minmax operation is enabled or disabled by
              calling ggll::eennaabbllee//11 or ggll::eennaabbllee//11 , respectively, with an
              argument of _?_G_L___M_I_N_M_A_X .

              _g_l_:_m_i_n_m_a_x redefines the current minmax table to have entries of
              the format specified by _I_n_t_e_r_n_a_l_f_o_r_m_a_t . The maximum element is
              initialized with the smallest possible component values, and the
              minimum element is initialized with the largest possible
              component values. The values in the previous minmax table, if
              any, are lost. If _S_i_n_k is _?_G_L___T_R_U_E , then pixels are discarded
              after minmax; no further processing of the pixels takes place,
              and no drawing, texture loading, or pixel readback will result.

              See external documentation.

       rreesseettHHiissttooggrraamm((TTaarrggeett)) -->> ookk

              Types:

                 Target = enum()

              Reset histogram table entries to zero

              _g_l_:_r_e_s_e_t_H_i_s_t_o_g_r_a_m resets all the elements of the current
              histogram table to zero.

              See external documentation.

       rreesseettMMiinnmmaaxx((TTaarrggeett)) -->> ookk

              Types:

                 Target = enum()

              Reset minmax table entries to initial values

              _g_l_:_r_e_s_e_t_M_i_n_m_a_x resets the elements of the current minmax table
              to their initial values: the _m_a_x_i_m_u_m element receives the
              minimum possible component values, and the _m_i_n_i_m_u_m element
              receives the maximum possible component values.

              See external documentation.

       aaccttiivveeTTeexxttuurree((TTeexxttuurree)) -->> ookk

              Types:

                 Texture = enum()

              Select active texture unit

              _g_l_:_a_c_t_i_v_e_T_e_x_t_u_r_e selects which texture unit subsequent texture
              state calls will affect. The number of texture units an
              implementation supports is implementation dependent, but must be
              at least 80.

              See external documentation.

       ssaammpplleeCCoovveerraaggee((VVaalluuee,, IInnvveerrtt)) -->> ookk

              Types:

                 Value = clamp()
                 Invert = 0 | 1

              Specify multisample coverage parameters

              Multisampling samples a pixel multiple times at various
              implementation-dependent subpixel locations to generate
              antialiasing effects. Multisampling transparently antialiases
              points, lines, polygons, and images if it is enabled.

              _V_a_l_u_e is used in constructing a temporary mask used in
              determining which samples will be used in resolving the final
              fragment color. This mask is bitwise-anded with the coverage
              mask generated from the multisampling computation. If the _I_n_v_e_r_t
              flag is set, the temporary mask is inverted (all bits flipped)
              and then the bitwise-and is computed.

              If an implementation does not have any multisample buffers
              available, or multisampling is disabled, rasterization occurs
              with only a single sample computing a pixel's final RGB color.

              Provided an implementation supports multisample buffers, and
              multisampling is enabled, then a pixel's final color is
              generated by combining several samples per pixel. Each sample
              contains color, depth, and stencil information, allowing those
              operations to be performed on each sample.

              See external documentation.

       ccoommpprreesssseeddTTeexxIImmaaggee33DD((TTaarrggeett,, LLeevveell,, IInntteerrnnaallffoorrmmaatt,, WWiiddtthh,, HHeeiigghhtt,,
       DDeepptthh,, BBoorrddeerr,, IImmaaggeeSSiizzee,, DDaattaa)) -->> ookk

              Types:

                 Target = enum()
                 Level = integer()
                 Internalformat = enum()
                 Width = integer()
                 Height = integer()
                 Depth = integer()
                 Border = integer()
                 ImageSize = integer()
                 Data = offset() | mem()

              Specify a three-dimensional texture image in a compressed format

              Texturing allows elements of an image array to be read by
              shaders.

              _g_l_:_c_o_m_p_r_e_s_s_e_d_T_e_x_I_m_a_g_e_3_D loads a previously defined, and
              retrieved, compressed three-dimensional texture image if _T_a_r_g_e_t
              is _?_G_L___T_E_X_T_U_R_E___3_D (see ggll::tteexxIImmaaggee33DD//1100 ).

              If _T_a_r_g_e_t is _?_G_L___T_E_X_T_U_R_E___2_D___A_R_R_A_Y, _D_a_t_a is treated as an array
              of compressed 2D textures.

              If _T_a_r_g_e_t is _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___3_D or _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___2_D___A_R_R_A_Y,
              no data is read from _D_a_t_a , but all of the texture image state
              is recalculated, checked for consistency, and checked against
              the implementation's capabilities. If the implementation cannot
              handle a texture of the requested texture size, it sets all of
              the image state to 0, but does not generate an error (see
              ggll::ggeettEErrrroorr//00 ). To query for an entire mipmap array, use an
              image array level greater than or equal to 1.

              _I_n_t_e_r_n_a_l_f_o_r_m_a_t must be a known compressed image format (such as
              _?_G_L___R_G_T_C) or an extension-specified compressed-texture format.
              When a texture is loaded with ggll::tteexxIImmaaggee22DD//99 using a generic
              compressed texture format (e.g., _?_G_L___C_O_M_P_R_E_S_S_E_D___R_G_B), the GL
              selects from one of its extensions supporting compressed
              textures. In order to load the compressed texture image using
              _g_l_:_c_o_m_p_r_e_s_s_e_d_T_e_x_I_m_a_g_e_3_D, query the compressed texture image's
              size and format using ggll::ggeettTTeexxLLeevveellPPaarraammeetteerrffvv//33 .

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              texture image is specified, _D_a_t_a is treated as a byte offset
              into the buffer object's data store.

              If the compressed data are arranged into fixed-size blocks of
              texels, the pixel storage modes can be used to select a sub-
              rectangle from a larger containing rectangle. These pixel
              storage modes operate in the same way as they do for
              ggll::tteexxIImmaaggee11DD//88 . In the following description, denote by b s, b
              w, b h, and b d, the values of pixel storage modes
              _?_G_L___U_N_P_A_C_K___C_O_M_P_R_E_S_S_E_D___B_L_O_C_K___S_I_Z_E,
              _?_G_L___U_N_P_A_C_K___C_O_M_P_R_E_S_S_E_D___B_L_O_C_K___W_I_D_T_H,
              _?_G_L___U_N_P_A_C_K___C_O_M_P_R_E_S_S_E_D___B_L_O_C_K___H_E_I_G_H_T , and
              _?_G_L___U_N_P_A_C_K___C_O_M_P_R_E_S_S_E_D___B_L_O_C_K___D_E_P_T_H, respectively. b s is the
              compressed block size in bytes; b w, b h, and b d are the
              compressed block width, height, and depth in pixels.

              By default the pixel storage modes _?_G_L___U_N_P_A_C_K___R_O_W___L_E_N_G_T_H,
              _?_G_L___U_N_P_A_C_K___S_K_I_P___R_O_W_S , _?_G_L___U_N_P_A_C_K___S_K_I_P___P_I_X_E_L_S,
              _?_G_L___U_N_P_A_C_K___I_M_A_G_E___H_E_I_G_H_T and _?_G_L___U_N_P_A_C_K___S_K_I_P___I_M_A_G_E_S are ignored
              for compressed images. To enable _?_G_L___U_N_P_A_C_K___S_K_I_P___P_I_X_E_L_S and
              _?_G_L___U_N_P_A_C_K___R_O_W___L_E_N_G_T_H , b s and b w must both be non-zero. To
              also enable _?_G_L___U_N_P_A_C_K___S_K_I_P___R_O_W_S and _?_G_L___U_N_P_A_C_K___I_M_A_G_E___H_E_I_G_H_T , b
              h must be non-zero. To also enable _?_G_L___U_N_P_A_C_K___S_K_I_P___I_M_A_G_E_S, b d
              must be non-zero. All parameters must be consistent with the
              compressed format to produce the desired results.

              When selecting a sub-rectangle from a compressed image: the
              value of _?_G_L___U_N_P_A_C_K___S_K_I_P___P_I_X_E_L_S must be a multiple of b w;the
              value of _?_G_L___U_N_P_A_C_K___S_K_I_P___R_O_W_S must be a multiple of b w;the
              value of _?_G_L___U_N_P_A_C_K___S_K_I_P___I_M_A_G_E_S must be a multiple of b w.

              _I_m_a_g_e_S_i_z_e must be equal to:

              b s*|width b/w|*|height b/h|*|depth b/d|

              See external documentation.

       ccoommpprreesssseeddTTeexxIImmaaggee22DD((TTaarrggeett,, LLeevveell,, IInntteerrnnaallffoorrmmaatt,, WWiiddtthh,, HHeeiigghhtt,,
       BBoorrddeerr,, IImmaaggeeSSiizzee,, DDaattaa)) -->> ookk

              Types:

                 Target = enum()
                 Level = integer()
                 Internalformat = enum()
                 Width = integer()
                 Height = integer()
                 Border = integer()
                 ImageSize = integer()
                 Data = offset() | mem()

              Specify a two-dimensional texture image in a compressed format

              Texturing allows elements of an image array to be read by
              shaders.

              _g_l_:_c_o_m_p_r_e_s_s_e_d_T_e_x_I_m_a_g_e_2_D loads a previously defined, and
              retrieved, compressed two-dimensional texture image if _T_a_r_g_e_t is
              _?_G_L___T_E_X_T_U_R_E___2_D, or one of the cube map faces such as
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___P_O_S_I_T_I_V_E___X. (see ggll::tteexxIImmaaggee22DD//99 ).

              If _T_a_r_g_e_t is _?_G_L___T_E_X_T_U_R_E___1_D___A_R_R_A_Y, _D_a_t_a is treated as an array
              of compressed 1D textures.

              If _T_a_r_g_e_t is _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___2_D, _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___1_D___A_R_R_A_Y or
              _?_G_L___P_R_O_X_Y___C_U_B_E___M_A_P , no data is read from _D_a_t_a , but all of the
              texture image state is recalculated, checked for consistency,
              and checked against the implementation's capabilities. If the
              implementation cannot handle a texture of the requested texture
              size, it sets all of the image state to 0, but does not generate
              an error (see ggll::ggeettEErrrroorr//00 ). To query for an entire mipmap
              array, use an image array level greater than or equal to 1.

              _I_n_t_e_r_n_a_l_f_o_r_m_a_t must be a known compressed image format (such as
              _?_G_L___R_G_T_C) or an extension-specified compressed-texture format.
              When a texture is loaded with ggll::tteexxIImmaaggee22DD//99 using a generic
              compressed texture format (e.g., _?_G_L___C_O_M_P_R_E_S_S_E_D___R_G_B), the GL
              selects from one of its extensions supporting compressed
              textures. In order to load the compressed texture image using
              _g_l_:_c_o_m_p_r_e_s_s_e_d_T_e_x_I_m_a_g_e_2_D, query the compressed texture image's
              size and format using ggll::ggeettTTeexxLLeevveellPPaarraammeetteerrffvv//33 .

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              texture image is specified, _D_a_t_a is treated as a byte offset
              into the buffer object's data store.

              If the compressed data are arranged into fixed-size blocks of
              texels, the pixel storage modes can be used to select a sub-
              rectangle from a larger containing rectangle. These pixel
              storage modes operate in the same way as they do for
              ggll::tteexxIImmaaggee22DD//99 . In the following description, denote by b s, b
              w, b h, and b d, the values of pixel storage modes
              _?_G_L___U_N_P_A_C_K___C_O_M_P_R_E_S_S_E_D___B_L_O_C_K___S_I_Z_E,
              _?_G_L___U_N_P_A_C_K___C_O_M_P_R_E_S_S_E_D___B_L_O_C_K___W_I_D_T_H,
              _?_G_L___U_N_P_A_C_K___C_O_M_P_R_E_S_S_E_D___B_L_O_C_K___H_E_I_G_H_T , and
              _?_G_L___U_N_P_A_C_K___C_O_M_P_R_E_S_S_E_D___B_L_O_C_K___D_E_P_T_H, respectively. b s is the
              compressed block size in bytes; b w, b h, and b d are the
              compressed block width, height, and depth in pixels.

              By default the pixel storage modes _?_G_L___U_N_P_A_C_K___R_O_W___L_E_N_G_T_H,
              _?_G_L___U_N_P_A_C_K___S_K_I_P___R_O_W_S , _?_G_L___U_N_P_A_C_K___S_K_I_P___P_I_X_E_L_S,
              _?_G_L___U_N_P_A_C_K___I_M_A_G_E___H_E_I_G_H_T and _?_G_L___U_N_P_A_C_K___S_K_I_P___I_M_A_G_E_S are ignored
              for compressed images. To enable _?_G_L___U_N_P_A_C_K___S_K_I_P___P_I_X_E_L_S and
              _?_G_L___U_N_P_A_C_K___R_O_W___L_E_N_G_T_H , b s and b w must both be non-zero. To
              also enable _?_G_L___U_N_P_A_C_K___S_K_I_P___R_O_W_S and _?_G_L___U_N_P_A_C_K___I_M_A_G_E___H_E_I_G_H_T , b
              h must be non-zero. To also enable _?_G_L___U_N_P_A_C_K___S_K_I_P___I_M_A_G_E_S, b d
              must be non-zero. All parameters must be consistent with the
              compressed format to produce the desired results.

              When selecting a sub-rectangle from a compressed image: the
              value of _?_G_L___U_N_P_A_C_K___S_K_I_P___P_I_X_E_L_S must be a multiple of b w;the
              value of _?_G_L___U_N_P_A_C_K___S_K_I_P___R_O_W_S must be a multiple of b w.

              _I_m_a_g_e_S_i_z_e must be equal to:

              b s*|width b/w|*|height b/h|

              See external documentation.

       ccoommpprreesssseeddTTeexxIImmaaggee11DD((TTaarrggeett,, LLeevveell,, IInntteerrnnaallffoorrmmaatt,, WWiiddtthh,, BBoorrddeerr,,
       IImmaaggeeSSiizzee,, DDaattaa)) -->> ookk

              Types:

                 Target = enum()
                 Level = integer()
                 Internalformat = enum()
                 Width = integer()
                 Border = integer()
                 ImageSize = integer()
                 Data = offset() | mem()

              Specify a one-dimensional texture image in a compressed format

              Texturing allows elements of an image array to be read by
              shaders.

              _g_l_:_c_o_m_p_r_e_s_s_e_d_T_e_x_I_m_a_g_e_1_D loads a previously defined, and
              retrieved, compressed one-dimensional texture image if _T_a_r_g_e_t is
              _?_G_L___T_E_X_T_U_R_E___1_D (see ggll::tteexxIImmaaggee11DD//88 ).

              If _T_a_r_g_e_t is _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___1_D, no data is read from _D_a_t_a ,
              but all of the texture image state is recalculated, checked for
              consistency, and checked against the implementation's
              capabilities. If the implementation cannot handle a texture of
              the requested texture size, it sets all of the image state to 0,
              but does not generate an error (see ggll::ggeettEErrrroorr//00 ). To query
              for an entire mipmap array, use an image array level greater
              than or equal to 1.

              _I_n_t_e_r_n_a_l_f_o_r_m_a_t must be an extension-specified compressed-texture
              format. When a texture is loaded with ggll::tteexxIImmaaggee11DD//88 using a
              generic compressed texture format (e.g., _?_G_L___C_O_M_P_R_E_S_S_E_D___R_G_B) the
              GL selects from one of its extensions supporting compressed
              textures. In order to load the compressed texture image using
              _g_l_:_c_o_m_p_r_e_s_s_e_d_T_e_x_I_m_a_g_e_1_D , query the compressed texture image's
              size and format using ggll::ggeettTTeexxLLeevveellPPaarraammeetteerrffvv//33 .

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              texture image is specified, _D_a_t_a is treated as a byte offset
              into the buffer object's data store.

              If the compressed data are arranged into fixed-size blocks of
              texels, the pixel storage modes can be used to select a sub-
              rectangle from a larger containing rectangle. These pixel
              storage modes operate in the same way as they do for
              ggll::tteexxIImmaaggee11DD//88 . In the following description, denote by b s, b
              w, b h, and b d, the values of pixel storage modes
              _?_G_L___U_N_P_A_C_K___C_O_M_P_R_E_S_S_E_D___B_L_O_C_K___S_I_Z_E,
              _?_G_L___U_N_P_A_C_K___C_O_M_P_R_E_S_S_E_D___B_L_O_C_K___W_I_D_T_H,
              _?_G_L___U_N_P_A_C_K___C_O_M_P_R_E_S_S_E_D___B_L_O_C_K___H_E_I_G_H_T , and
              _?_G_L___U_N_P_A_C_K___C_O_M_P_R_E_S_S_E_D___B_L_O_C_K___D_E_P_T_H, respectively. b s is the
              compressed block size in bytes; b w, b h, and b d are the
              compressed block width, height, and depth in pixels.

              By default the pixel storage modes _?_G_L___U_N_P_A_C_K___R_O_W___L_E_N_G_T_H,
              _?_G_L___U_N_P_A_C_K___S_K_I_P___R_O_W_S , _?_G_L___U_N_P_A_C_K___S_K_I_P___P_I_X_E_L_S,
              _?_G_L___U_N_P_A_C_K___I_M_A_G_E___H_E_I_G_H_T and _?_G_L___U_N_P_A_C_K___S_K_I_P___I_M_A_G_E_S are ignored
              for compressed images. To enable _?_G_L___U_N_P_A_C_K___S_K_I_P___P_I_X_E_L_S and
              _?_G_L___U_N_P_A_C_K___R_O_W___L_E_N_G_T_H , b s and b w must both be non-zero. To
              also enable _?_G_L___U_N_P_A_C_K___S_K_I_P___R_O_W_S and _?_G_L___U_N_P_A_C_K___I_M_A_G_E___H_E_I_G_H_T , b
              h must be non-zero. To also enable _?_G_L___U_N_P_A_C_K___S_K_I_P___I_M_A_G_E_S, b d
              must be non-zero. All parameters must be consistent with the
              compressed format to produce the desired results.

              When selecting a sub-rectangle from a compressed image: the
              value of _?_G_L___U_N_P_A_C_K___S_K_I_P___P_I_X_E_L_S must be a multiple of b w;

              _I_m_a_g_e_S_i_z_e must be equal to:

              b s*|width b/w|

              See external documentation.

       ccoommpprreesssseeddTTeexxSSuubbIImmaaggee33DD((TTaarrggeett,, LLeevveell,, XXooffffsseett,, YYooffffsseett,, ZZooffffsseett,,
       WWiiddtthh,, HHeeiigghhtt,, DDeepptthh,, FFoorrmmaatt,, IImmaaggeeSSiizzee,, DDaattaa)) -->> ookk

              Types:

                 Target = enum()
                 Level = integer()
                 Xoffset = integer()
                 Yoffset = integer()
                 Zoffset = integer()
                 Width = integer()
                 Height = integer()
                 Depth = integer()
                 Format = enum()
                 ImageSize = integer()
                 Data = offset() | mem()

              Specify a three-dimensional texture subimage in a compressed
              format

              Texturing allows elements of an image array to be read by
              shaders.

              _g_l_:_c_o_m_p_r_e_s_s_e_d_T_e_x_S_u_b_I_m_a_g_e_3_D redefines a contiguous subregion of
              an existing three-dimensional texture image. The texels
              referenced by _D_a_t_a replace the portion of the existing texture
              array with x indices _X_o_f_f_s_e_t and xoffset+width-1, and the y
              indices _Y_o_f_f_s_e_t and yoffset+height-1, and the z indices _Z_o_f_f_s_e_t
              and zoffset+depth-1, inclusive. This region may not include any
              texels outside the range of the texture array as it was
              originally specified. It is not an error to specify a subtexture
              with width of 0, but such a specification has no effect.

              _I_n_t_e_r_n_a_l_f_o_r_m_a_t must be a known compressed image format (such as
              _?_G_L___R_G_T_C) or an extension-specified compressed-texture format.
              The _F_o_r_m_a_t of the compressed texture image is selected by the GL
              implementation that compressed it (see ggll::tteexxIImmaaggee33DD//1100 ) and
              should be queried at the time the texture was compressed with
              ggll::ggeettTTeexxLLeevveellPPaarraammeetteerrffvv//33 .

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              texture image is specified, _D_a_t_a is treated as a byte offset
              into the buffer object's data store.

              See external documentation.

       ccoommpprreesssseeddTTeexxSSuubbIImmaaggee22DD((TTaarrggeett,, LLeevveell,, XXooffffsseett,, YYooffffsseett,, WWiiddtthh,, HHeeiigghhtt,,
       FFoorrmmaatt,, IImmaaggeeSSiizzee,, DDaattaa)) -->> ookk

              Types:

                 Target = enum()
                 Level = integer()
                 Xoffset = integer()
                 Yoffset = integer()
                 Width = integer()
                 Height = integer()
                 Format = enum()
                 ImageSize = integer()
                 Data = offset() | mem()

              Specify a two-dimensional texture subimage in a compressed
              format

              Texturing allows elements of an image array to be read by
              shaders.

              _g_l_:_c_o_m_p_r_e_s_s_e_d_T_e_x_S_u_b_I_m_a_g_e_2_D redefines a contiguous subregion of
              an existing two-dimensional texture image. The texels referenced
              by _D_a_t_a replace the portion of the existing texture array with x
              indices _X_o_f_f_s_e_t and xoffset+width-1, and the y indices _Y_o_f_f_s_e_t
              and yoffset+height-1, inclusive. This region may not include any
              texels outside the range of the texture array as it was
              originally specified. It is not an error to specify a subtexture
              with width of 0, but such a specification has no effect.

              _I_n_t_e_r_n_a_l_f_o_r_m_a_t must be a known compressed image format (such as
              _?_G_L___R_G_T_C) or an extension-specified compressed-texture format.
              The _F_o_r_m_a_t of the compressed texture image is selected by the GL
              implementation that compressed it (see ggll::tteexxIImmaaggee22DD//99 ) and
              should be queried at the time the texture was compressed with
              ggll::ggeettTTeexxLLeevveellPPaarraammeetteerrffvv//33 .

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              texture image is specified, _D_a_t_a is treated as a byte offset
              into the buffer object's data store.

              See external documentation.

       ccoommpprreesssseeddTTeexxSSuubbIImmaaggee11DD((TTaarrggeett,, LLeevveell,, XXooffffsseett,, WWiiddtthh,, FFoorrmmaatt,,
       IImmaaggeeSSiizzee,, DDaattaa)) -->> ookk

              Types:

                 Target = enum()
                 Level = integer()
                 Xoffset = integer()
                 Width = integer()
                 Format = enum()
                 ImageSize = integer()
                 Data = offset() | mem()

              Specify a one-dimensional texture subimage in a compressed
              format

              Texturing allows elements of an image array to be read by
              shaders.

              _g_l_:_c_o_m_p_r_e_s_s_e_d_T_e_x_S_u_b_I_m_a_g_e_1_D redefines a contiguous subregion of
              an existing one-dimensional texture image. The texels referenced
              by _D_a_t_a replace the portion of the existing texture array with x
              indices _X_o_f_f_s_e_t and xoffset+width-1, inclusive. This region may
              not include any texels outside the range of the texture array as
              it was originally specified. It is not an error to specify a
              subtexture with width of 0, but such a specification has no
              effect.

              _I_n_t_e_r_n_a_l_f_o_r_m_a_t must be a known compressed image format (such as
              _?_G_L___R_G_T_C) or an extension-specified compressed-texture format.
              The _F_o_r_m_a_t of the compressed texture image is selected by the GL
              implementation that compressed it (see ggll::tteexxIImmaaggee11DD//88 ), and
              should be queried at the time the texture was compressed with
              ggll::ggeettTTeexxLLeevveellPPaarraammeetteerrffvv//33 .

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              texture image is specified, _D_a_t_a is treated as a byte offset
              into the buffer object's data store.

              See external documentation.

       ggeettCCoommpprreesssseeddTTeexxIImmaaggee((TTaarrggeett,, LLoodd,, IImmgg)) -->> ookk

              Types:

                 Target = enum()
                 Lod = integer()
                 Img = mem()

              Return a compressed texture image

              _g_l_:_g_e_t_C_o_m_p_r_e_s_s_e_d_T_e_x_I_m_a_g_e returns the compressed texture image
              associated with _T_a_r_g_e_t and _L_o_d into _I_m_g . _I_m_g should be an array
              of _?_G_L___T_E_X_T_U_R_E___C_O_M_P_R_E_S_S_E_D___I_M_A_G_E___S_I_Z_E bytes. _T_a_r_g_e_t specifies
              whether the desired texture image was one specified by
              ggll::tteexxIImmaaggee11DD//88 (_?_G_L___T_E_X_T_U_R_E___1_D), ggll::tteexxIImmaaggee22DD//99
              (_?_G_L___T_E_X_T_U_R_E___2_D or any of _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___* ), or
              ggll::tteexxIImmaaggee33DD//1100 (_?_G_L___T_E_X_T_U_R_E___3_D). _L_o_d specifies the level-of-
              detail number of the desired image.

              If a non-zero named buffer object is bound to the
              _?_G_L___P_I_X_E_L___P_A_C_K___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a
              texture image is requested, _I_m_g is treated as a byte offset into
              the buffer object's data store.

              To minimize errors, first verify that the texture is compressed
              by calling ggll::ggeettTTeexxLLeevveellPPaarraammeetteerrffvv//33 with argument
              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_R_E_S_S_E_D. If the texture is compressed, then
              determine the amount of memory required to store the compressed
              texture by calling ggll::ggeettTTeexxLLeevveellPPaarraammeetteerrffvv//33 with argument
              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_R_E_S_S_E_D___I_M_A_G_E___S_I_Z_E. Finally, retrieve the
              internal format of the texture by calling
              ggll::ggeettTTeexxLLeevveellPPaarraammeetteerrffvv//33 with argument
              _?_G_L___T_E_X_T_U_R_E___I_N_T_E_R_N_A_L___F_O_R_M_A_T . To store the texture for later
              use, associate the internal format and size with the retrieved
              texture image. These data can be used by the respective texture
              or subtexture loading routine used for loading _T_a_r_g_e_t textures.

              See external documentation.

       cclliieennttAAccttiivveeTTeexxttuurree((TTeexxttuurree)) -->> ookk

              Types:

                 Texture = enum()

              Select active texture unit

              _g_l_:_c_l_i_e_n_t_A_c_t_i_v_e_T_e_x_t_u_r_e selects the vertex array client state
              parameters to be modified by ggll::tteexxCCoooorrddPPooiinntteerr//44 , and enabled
              or disabled with ggll::eennaabblleeCClliieennttSSttaattee//11 or
              ggll::eennaabblleeCClliieennttSSttaattee//11 , respectively, when called with a
              parameter of _?_G_L___T_E_X_T_U_R_E___C_O_O_R_D___A_R_R_A_Y .

              See external documentation.

       mmuullttiiTTeexxCCoooorrdd11dd((TTaarrggeett,, SS)) -->> ookk

              Types:

                 Target = enum()
                 S = float()

              Set the current texture coordinates

              _g_l_:_m_u_l_t_i_T_e_x_C_o_o_r_d specifies texture coordinates in one, two,
              three, or four dimensions. _g_l_:_m_u_l_t_i_T_e_x_C_o_o_r_d_1 sets the current
              texture coordinates to (s 0 0 1); a call to _g_l_:_m_u_l_t_i_T_e_x_C_o_o_r_d_2
              sets them to (s t 0 1). Similarly, _g_l_:_m_u_l_t_i_T_e_x_C_o_o_r_d_3 specifies
              the texture coordinates as (s t r 1), and _g_l_:_m_u_l_t_i_T_e_x_C_o_o_r_d_4
              defines all four components explicitly as (s t r q).

              The current texture coordinates are part of the data that is
              associated with each vertex and with the current raster
              position. Initially, the values for (s t r q) are (0 0 0 1).

              See external documentation.

       mmuullttiiTTeexxCCoooorrdd11ddvv((TTaarrggeett::::eennuumm(()),, VV)) -->> ookk

              Types:

                 V = {S::float()}

              Equivalent to mmuullttiiTTeexxCCoooorrdd11dd((TTaarrggeett,, SS)).

       mmuullttiiTTeexxCCoooorrdd11ff((TTaarrggeett,, SS)) -->> ookk

              Types:

                 Target = enum()
                 S = float()

              See mmuullttiiTTeexxCCoooorrdd11dd//22

       mmuullttiiTTeexxCCoooorrdd11ffvv((TTaarrggeett::::eennuumm(()),, VV)) -->> ookk

              Types:

                 V = {S::float()}

              Equivalent to mmuullttiiTTeexxCCoooorrdd11ff((TTaarrggeett,, SS)).

       mmuullttiiTTeexxCCoooorrdd11ii((TTaarrggeett,, SS)) -->> ookk

              Types:

                 Target = enum()
                 S = integer()

              See mmuullttiiTTeexxCCoooorrdd11dd//22

       mmuullttiiTTeexxCCoooorrdd11iivv((TTaarrggeett::::eennuumm(()),, VV)) -->> ookk

              Types:

                 V = {S::integer()}

              Equivalent to mmuullttiiTTeexxCCoooorrdd11ii((TTaarrggeett,, SS)).

       mmuullttiiTTeexxCCoooorrdd11ss((TTaarrggeett,, SS)) -->> ookk

              Types:

                 Target = enum()
                 S = integer()

              See mmuullttiiTTeexxCCoooorrdd11dd//22

       mmuullttiiTTeexxCCoooorrdd11ssvv((TTaarrggeett::::eennuumm(()),, VV)) -->> ookk

              Types:

                 V = {S::integer()}

              Equivalent to mmuullttiiTTeexxCCoooorrdd11ss((TTaarrggeett,, SS)).

       mmuullttiiTTeexxCCoooorrdd22dd((TTaarrggeett,, SS,, TT)) -->> ookk

              Types:

                 Target = enum()
                 S = float()
                 T = float()

              See mmuullttiiTTeexxCCoooorrdd11dd//22

       mmuullttiiTTeexxCCoooorrdd22ddvv((TTaarrggeett::::eennuumm(()),, VV)) -->> ookk

              Types:

                 V = {S::float(), T::float()}

              Equivalent to mmuullttiiTTeexxCCoooorrdd22dd((TTaarrggeett,, SS,, TT)).

       mmuullttiiTTeexxCCoooorrdd22ff((TTaarrggeett,, SS,, TT)) -->> ookk

              Types:

                 Target = enum()
                 S = float()
                 T = float()

              See mmuullttiiTTeexxCCoooorrdd11dd//22

       mmuullttiiTTeexxCCoooorrdd22ffvv((TTaarrggeett::::eennuumm(()),, VV)) -->> ookk

              Types:

                 V = {S::float(), T::float()}

              Equivalent to mmuullttiiTTeexxCCoooorrdd22ff((TTaarrggeett,, SS,, TT)).

       mmuullttiiTTeexxCCoooorrdd22ii((TTaarrggeett,, SS,, TT)) -->> ookk

              Types:

                 Target = enum()
                 S = integer()
                 T = integer()

              See mmuullttiiTTeexxCCoooorrdd11dd//22

       mmuullttiiTTeexxCCoooorrdd22iivv((TTaarrggeett::::eennuumm(()),, VV)) -->> ookk

              Types:

                 V = {S::integer(), T::integer()}

              Equivalent to mmuullttiiTTeexxCCoooorrdd22ii((TTaarrggeett,, SS,, TT)).

       mmuullttiiTTeexxCCoooorrdd22ss((TTaarrggeett,, SS,, TT)) -->> ookk

              Types:

                 Target = enum()
                 S = integer()
                 T = integer()

              See mmuullttiiTTeexxCCoooorrdd11dd//22

       mmuullttiiTTeexxCCoooorrdd22ssvv((TTaarrggeett::::eennuumm(()),, VV)) -->> ookk

              Types:

                 V = {S::integer(), T::integer()}

              Equivalent to mmuullttiiTTeexxCCoooorrdd22ss((TTaarrggeett,, SS,, TT)).

       mmuullttiiTTeexxCCoooorrdd33dd((TTaarrggeett,, SS,, TT,, RR)) -->> ookk

              Types:

                 Target = enum()
                 S = float()
                 T = float()
                 R = float()

              See mmuullttiiTTeexxCCoooorrdd11dd//22

       mmuullttiiTTeexxCCoooorrdd33ddvv((TTaarrggeett::::eennuumm(()),, VV)) -->> ookk

              Types:

                 V = {S::float(), T::float(), R::float()}

              Equivalent to mmuullttiiTTeexxCCoooorrdd33dd((TTaarrggeett,, SS,, TT,, RR)).

       mmuullttiiTTeexxCCoooorrdd33ff((TTaarrggeett,, SS,, TT,, RR)) -->> ookk

              Types:

                 Target = enum()
                 S = float()
                 T = float()
                 R = float()

              See mmuullttiiTTeexxCCoooorrdd11dd//22

       mmuullttiiTTeexxCCoooorrdd33ffvv((TTaarrggeett::::eennuumm(()),, VV)) -->> ookk

              Types:

                 V = {S::float(), T::float(), R::float()}

              Equivalent to mmuullttiiTTeexxCCoooorrdd33ff((TTaarrggeett,, SS,, TT,, RR)).

       mmuullttiiTTeexxCCoooorrdd33ii((TTaarrggeett,, SS,, TT,, RR)) -->> ookk

              Types:

                 Target = enum()
                 S = integer()
                 T = integer()
                 R = integer()

              See mmuullttiiTTeexxCCoooorrdd11dd//22

       mmuullttiiTTeexxCCoooorrdd33iivv((TTaarrggeett::::eennuumm(()),, VV)) -->> ookk

              Types:

                 V = {S::integer(), T::integer(), R::integer()}

              Equivalent to mmuullttiiTTeexxCCoooorrdd33ii((TTaarrggeett,, SS,, TT,, RR)).

       mmuullttiiTTeexxCCoooorrdd33ss((TTaarrggeett,, SS,, TT,, RR)) -->> ookk

              Types:

                 Target = enum()
                 S = integer()
                 T = integer()
                 R = integer()

              See mmuullttiiTTeexxCCoooorrdd11dd//22

       mmuullttiiTTeexxCCoooorrdd33ssvv((TTaarrggeett::::eennuumm(()),, VV)) -->> ookk

              Types:

                 V = {S::integer(), T::integer(), R::integer()}

              Equivalent to mmuullttiiTTeexxCCoooorrdd33ss((TTaarrggeett,, SS,, TT,, RR)).

       mmuullttiiTTeexxCCoooorrdd44dd((TTaarrggeett,, SS,, TT,, RR,, QQ)) -->> ookk

              Types:

                 Target = enum()
                 S = float()
                 T = float()
                 R = float()
                 Q = float()

              See mmuullttiiTTeexxCCoooorrdd11dd//22

       mmuullttiiTTeexxCCoooorrdd44ddvv((TTaarrggeett::::eennuumm(()),, VV)) -->> ookk

              Types:

                 V = {S::float(), T::float(), R::float(), Q::float()}

              Equivalent to mmuullttiiTTeexxCCoooorrdd44dd((TTaarrggeett,, SS,, TT,, RR,, QQ)).

       mmuullttiiTTeexxCCoooorrdd44ff((TTaarrggeett,, SS,, TT,, RR,, QQ)) -->> ookk

              Types:

                 Target = enum()
                 S = float()
                 T = float()
                 R = float()
                 Q = float()

              See mmuullttiiTTeexxCCoooorrdd11dd//22

       mmuullttiiTTeexxCCoooorrdd44ffvv((TTaarrggeett::::eennuumm(()),, VV)) -->> ookk

              Types:

                 V = {S::float(), T::float(), R::float(), Q::float()}

              Equivalent to mmuullttiiTTeexxCCoooorrdd44ff((TTaarrggeett,, SS,, TT,, RR,, QQ)).

       mmuullttiiTTeexxCCoooorrdd44ii((TTaarrggeett,, SS,, TT,, RR,, QQ)) -->> ookk

              Types:

                 Target = enum()
                 S = integer()
                 T = integer()
                 R = integer()
                 Q = integer()

              See mmuullttiiTTeexxCCoooorrdd11dd//22

       mmuullttiiTTeexxCCoooorrdd44iivv((TTaarrggeett::::eennuumm(()),, VV)) -->> ookk

              Types:

                 V = {S::integer(), T::integer(), R::integer(), Q::integer()}

              Equivalent to mmuullttiiTTeexxCCoooorrdd44ii((TTaarrggeett,, SS,, TT,, RR,, QQ)).

       mmuullttiiTTeexxCCoooorrdd44ss((TTaarrggeett,, SS,, TT,, RR,, QQ)) -->> ookk

              Types:

                 Target = enum()
                 S = integer()
                 T = integer()
                 R = integer()
                 Q = integer()

              See mmuullttiiTTeexxCCoooorrdd11dd//22

       mmuullttiiTTeexxCCoooorrdd44ssvv((TTaarrggeett::::eennuumm(()),, VV)) -->> ookk

              Types:

                 V = {S::integer(), T::integer(), R::integer(), Q::integer()}

              Equivalent to mmuullttiiTTeexxCCoooorrdd44ss((TTaarrggeett,, SS,, TT,, RR,, QQ)).

       llooaaddTTrraannssppoosseeMMaattrriixxff((MM)) -->> ookk

              Types:

                 M = matrix()

              Replace the current matrix with the specified row-major ordered
              matrix

              _g_l_:_l_o_a_d_T_r_a_n_s_p_o_s_e_M_a_t_r_i_x replaces the current matrix with the one
              whose elements are specified by _M . The current matrix is the
              projection matrix, modelview matrix, or texture matrix,
              depending on the current matrix mode (see ggll::mmaattrriixxMMooddee//11 ).

              The current matrix, M, defines a transformation of coordinates.
              For instance, assume M refers to the modelview matrix. If
              v=(v[0] v[1] v[2] v[3]) is the set of object coordinates of a
              vertex, and _M points to an array of 16 single- or double-
              precision floating-point values m={m[0] m[1] ... m[15]}, then
              the modelview transformation M(v) does the following:

              M(v)=(m[0] m[1] m[2] m[3] m[4] m[5] m[6] m[7] m[8] m[9] m[10]
              m[11] m[12] m[13] m[14] m[15])*(v[0] v[1] v[2] v[3])

              Projection and texture transformations are similarly defined.

              Calling _g_l_:_l_o_a_d_T_r_a_n_s_p_o_s_e_M_a_t_r_i_x with matrix M is identical in
              operation to ggll::llooaaddMMaattrriixxdd//11 with M T, where T represents the
              transpose.

              See external documentation.

       llooaaddTTrraannssppoosseeMMaattrriixxdd((MM)) -->> ookk

              Types:

                 M = matrix()

              See llooaaddTTrraannssppoosseeMMaattrriixxff//11

       mmuullttTTrraannssppoosseeMMaattrriixxff((MM)) -->> ookk

              Types:

                 M = matrix()

              Multiply the current matrix with the specified row-major ordered
              matrix

              _g_l_:_m_u_l_t_T_r_a_n_s_p_o_s_e_M_a_t_r_i_x multiplies the current matrix with the
              one specified using _M , and replaces the current matrix with the
              product.

              The current matrix is determined by the current matrix mode (see
              ggll::mmaattrriixxMMooddee//11 ). It is either the projection matrix, modelview
              matrix, or the texture matrix.

              See external documentation.

       mmuullttTTrraannssppoosseeMMaattrriixxdd((MM)) -->> ookk

              Types:

                 M = matrix()

              See mmuullttTTrraannssppoosseeMMaattrriixxff//11

       bblleennddFFuunnccSSeeppaarraattee((SSffaaccttoorrRRGGBB,, DDffaaccttoorrRRGGBB,, SSffaaccttoorrAAllpphhaa,, DDffaaccttoorrAAllpphhaa))
       -->> ookk

              Types:

                 SfactorRGB = enum()
                 DfactorRGB = enum()
                 SfactorAlpha = enum()
                 DfactorAlpha = enum()

              Specify pixel arithmetic for RGB and alpha components separately

              Pixels can be drawn using a function that blends the incoming
              (source) RGBA values with the RGBA values that are already in
              the frame buffer (the destination values). Blending is initially
              disabled. Use ggll::eennaabbllee//11 and ggll::eennaabbllee//11 with argument
              _?_G_L___B_L_E_N_D to enable and disable blending.

              _g_l_:_b_l_e_n_d_F_u_n_c_S_e_p_a_r_a_t_e defines the operation of blending for all
              draw buffers when it is enabled. _g_l_:_b_l_e_n_d_F_u_n_c_S_e_p_a_r_a_t_e_i defines
              the operation of blending for a single draw buffer specified by
              _B_u_f when enabled for that draw buffer. _S_r_c_R_G_B specifies which
              method is used to scale the source RGB-color components. _D_s_t_R_G_B
              specifies which method is used to scale the destination RGB-
              color components. Likewise, _S_r_c_A_l_p_h_a specifies which method is
              used to scale the source alpha color component, and _D_s_t_A_l_p_h_a
              specifies which method is used to scale the destination alpha
              component. The possible methods are described in the following
              table. Each method defines four scale factors, one each for red,
              green, blue, and alpha.

              In the table and in subsequent equations, first source, second
              source and destination color components are referred to as (R s0
              G s0 B s0 A s0), (R s1 G s1 B s1 A s1), and (R d G d B d A d),
              respectively. The color specified by ggll::bblleennddCCoolloorr//44 is referred
              to as (R c G c B c A c). They are understood to have integer
              values between 0 and (k R k G k B k A), where

              k c= 2(m c)-1

              and (m R m G m B m A) is the number of red, green, blue, and
              alpha bitplanes.

              Source and destination scale factors are referred to as (s R s G
              s B s A) and (d R d G d B d A). All scale factors have range [0
              1]._P_a_r_a_m_e_t_e_r_R_G_B _F_a_c_t_o_r_A_l_p_h_a _F_a_c_t_o_r
              _?_G_L___Z_E_R_O(0 0 0) 0
              _?_G_L___O_N_E (1 1 1) 1
              _?_G_L___S_R_C___C_O_L_O_R(R s0 k/R G s0 k/G B s0 k/B) A s0 k/A
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___C_O_L_O_R(1 1 1 1)-(R s0 k/R G s0 k/G B s0 k/B)
              1-A s0 k/A
              _?_G_L___D_S_T___C_O_L_O_R(R d k/R G d k/G B d k/B) A d k/A
              _?_G_L___O_N_E___M_I_N_U_S___D_S_T___C_O_L_O_R (1 1 1)-(R d k/R G d k/G B d k/B) 1-A d
              k/A
              _?_G_L___S_R_C___A_L_P_H_A(A s0 k/A A s0 k/A A s0 k/A) A s0 k/A
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___A_L_P_H_A(1 1 1)-(A s0 k/A A s0 k/A A s0 k/A ) 1-A
              s0 k/A
              _?_G_L___D_S_T___A_L_P_H_A(A d k/A A d k/A A d k/A) A d k/A
              _?_G_L___O_N_E___M_I_N_U_S___D_S_T___A_L_P_H_A (1 1 1)-(A d k/A A d k/A A d k/A) 1-A d
              k/A
              _?_G_L___C_O_N_S_T_A_N_T___C_O_L_O_R(R c G c B c) A c
              _?_G_L___O_N_E___M_I_N_U_S___C_O_N_S_T_A_N_T___C_O_L_O_R(1 1 1)-(R c G c B c) 1-A c
              _?_G_L___C_O_N_S_T_A_N_T___A_L_P_H_A(A c A c A c) A c
              _?_G_L___O_N_E___M_I_N_U_S___C_O_N_S_T_A_N_T___A_L_P_H_A (1 1 1)-(A c A c A c) 1-A c
              _?_G_L___S_R_C___A_L_P_H_A___S_A_T_U_R_A_T_E(i i i) 1
              _?_G_L___S_R_C_1___C_O_L_O_R(R s1 k/R G s1 k/G B s1 k/B) A s1 k/A
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___C_O_L_O_R (1 1 1 1)-(R s1 k/R G s1 k/G B s1 k/B)
              1-A s1 k/A
              _?_G_L___S_R_C_1___A_L_P_H_A(A s1 k/A A s1 k/A A s1 k/A) A s1 k/A
              _?_G_L___O_N_E___M_I_N_U_S___S_R_C___A_L_P_H_A(1 1 1)-(A s1 k/A A s1 k/A A s1 k/A ) 1-A
              s1 k/A


              In the table,

              i= min(A s 1-(A d))

              To determine the blended RGBA values of a pixel, the system uses
              the following equations:

              R d= min(k R R s s R+R d d R) G d= min(k G G s s G+G d d G) B d=
              min(k B B s s B+B d d B) A d= min(k A A s s A+A d d A)

              Despite the apparent precision of the above equations, blending
              arithmetic is not exactly specified, because blending operates
              with imprecise integer color values. However, a blend factor
              that should be equal to 1 is guaranteed not to modify its
              multiplicand, and a blend factor equal to 0 reduces its
              multiplicand to 0. For example, when _S_r_c_R_G_B is _?_G_L___S_R_C___A_L_P_H_A ,
              _D_s_t_R_G_B is _?_G_L___O_N_E___M_I_N_U_S___S_R_C___A_L_P_H_A, and A s is equal to k A, the
              equations reduce to simple replacement:

              R d= R s G d= G s B d= B s A d= A s

              See external documentation.

       mmuullttiiDDrraawwAArrrraayyss((MMooddee,, FFiirrsstt,, CCoouunntt)) -->> ookk

              Types:

                 Mode = enum()
                 First = [integer()]
                 Count = [integer()]

              Render multiple sets of primitives from array data

              _g_l_:_m_u_l_t_i_D_r_a_w_A_r_r_a_y_s specifies multiple sets of geometric
              primitives with very few subroutine calls. Instead of calling a
              GL procedure to pass each individual vertex, normal, texture
              coordinate, edge flag, or color, you can prespecify separate
              arrays of vertices, normals, and colors and use them to
              construct a sequence of primitives with a single call to
              _g_l_:_m_u_l_t_i_D_r_a_w_A_r_r_a_y_s.

              _g_l_:_m_u_l_t_i_D_r_a_w_A_r_r_a_y_s behaves identically to ggll::ddrraawwAArrrraayyss//33 except
              that _P_r_i_m_c_o_u_n_t separate ranges of elements are specified
              instead.

              When _g_l_:_m_u_l_t_i_D_r_a_w_A_r_r_a_y_s is called, it uses _C_o_u_n_t sequential
              elements from each enabled array to construct a sequence of
              geometric primitives, beginning with element _F_i_r_s_t . _M_o_d_e
              specifies what kind of primitives are constructed, and how the
              array elements construct those primitives.

              Vertex attributes that are modified by _g_l_:_m_u_l_t_i_D_r_a_w_A_r_r_a_y_s have
              an unspecified value after _g_l_:_m_u_l_t_i_D_r_a_w_A_r_r_a_y_s returns.
              Attributes that aren't modified remain well defined.

              See external documentation.

       ppooiinnttPPaarraammeetteerrff((PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Pname = enum()
                 Param = float()

              Specify point parameters

              The following values are accepted for _P_n_a_m_e :

              _?_G_L___P_O_I_N_T___F_A_D_E___T_H_R_E_S_H_O_L_D___S_I_Z_E: _P_a_r_a_m_s is a single floating-point
              value that specifies the threshold value to which point sizes
              are clamped if they exceed the specified value. The default
              value is 1.0.

              _?_G_L___P_O_I_N_T___S_P_R_I_T_E___C_O_O_R_D___O_R_I_G_I_N: _P_a_r_a_m_s is a single enum
              specifying the point sprite texture coordinate origin, either
              _?_G_L___L_O_W_E_R___L_E_F_T or _?_G_L___U_P_P_E_R___L_E_F_T. The default value is
              _?_G_L___U_P_P_E_R___L_E_F_T.

              See external documentation.

       ppooiinnttPPaarraammeetteerrffvv((PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Pname = enum()
                 Params = {float()}

              See ppooiinnttPPaarraammeetteerrff//22

       ppooiinnttPPaarraammeetteerrii((PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Pname = enum()
                 Param = integer()

              See ppooiinnttPPaarraammeetteerrff//22

       ppooiinnttPPaarraammeetteerriivv((PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Pname = enum()
                 Params = {integer()}

              See ppooiinnttPPaarraammeetteerrff//22

       ffooggCCoooorrddff((CCoooorrdd)) -->> ookk

              Types:

                 Coord = float()

              Set the current fog coordinates

              _g_l_:_f_o_g_C_o_o_r_d specifies the fog coordinate that is associated with
              each vertex and the current raster position. The value specified
              is interpolated and used in computing the fog color (see
              ggll::ffooggff//22 ).

              See external documentation.

       ffooggCCoooorrddffvv((CCoooorrdd)) -->> ookk

              Types:

                 Coord = {Coord::float()}

              Equivalent to ffooggCCoooorrddff((CCoooorrdd)).

       ffooggCCoooorrdddd((CCoooorrdd)) -->> ookk

              Types:

                 Coord = float()

              See ffooggCCoooorrddff//11

       ffooggCCoooorrddddvv((CCoooorrdd)) -->> ookk

              Types:

                 Coord = {Coord::float()}

              Equivalent to ffooggCCoooorrdddd((CCoooorrdd)).

       ffooggCCoooorrddPPooiinntteerr((TTyyppee,, SSttrriiddee,, PPooiinntteerr)) -->> ookk

              Types:

                 Type = enum()
                 Stride = integer()
                 Pointer = offset() | mem()

              Define an array of fog coordinates

              _g_l_:_f_o_g_C_o_o_r_d_P_o_i_n_t_e_r specifies the location and data format of an
              array of fog coordinates to use when rendering. _T_y_p_e specifies
              the data type of each fog coordinate, and _S_t_r_i_d_e specifies the
              byte stride from one fog coordinate to the next, allowing
              vertices and attributes to be packed into a single array or
              stored in separate arrays.

              If a non-zero named buffer object is bound to the
              _?_G_L___A_R_R_A_Y___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a fog
              coordinate array is specified, _P_o_i_n_t_e_r is treated as a byte
              offset into the buffer object's data store. Also, the buffer
              object binding (_?_G_L___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G ) is saved as fog
              coordinate vertex array client-side state
              (_?_G_L___F_O_G___C_O_O_R_D___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G ).

              When a fog coordinate array is specified, _T_y_p_e , _S_t_r_i_d_e , and
              _P_o_i_n_t_e_r are saved as client-side state, in addition to the
              current vertex array buffer object binding.

              To enable and disable the fog coordinate array, call
              ggll::eennaabblleeCClliieennttSSttaattee//11 and ggll::eennaabblleeCClliieennttSSttaattee//11 with the
              argument _?_G_L___F_O_G___C_O_O_R_D___A_R_R_A_Y. If enabled, the fog coordinate
              array is used when ggll::ddrraawwAArrrraayyss//33 , ggll::mmuullttiiDDrraawwAArrrraayyss//33 ,
              ggll::ddrraawwEElleemmeennttss//44 , see _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s ,
              ggll::ddrraawwRRaannggeeEElleemmeennttss//66 , or ggll::aarrrraayyEElleemmeenntt//11 is called.

              See external documentation.

       sseeccoonnddaarryyCCoolloorr33bb((RReedd,, GGrreeeenn,, BBlluuee)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()

              Set the current secondary color

              The GL stores both a primary four-valued RGBA color and a
              secondary four-valued RGBA color (where alpha is always set to
              0.0) that is associated with every vertex.

              The secondary color is interpolated and applied to each fragment
              during rasterization when _?_G_L___C_O_L_O_R___S_U_M is enabled. When
              lighting is enabled, and _?_G_L___S_E_P_A_R_A_T_E___S_P_E_C_U_L_A_R___C_O_L_O_R is
              specified, the value of the secondary color is assigned the
              value computed from the specular term of the lighting
              computation. Both the primary and secondary current colors are
              applied to each fragment, regardless of the state of
              _?_G_L___C_O_L_O_R___S_U_M, under such conditions. When
              _?_G_L___S_E_P_A_R_A_T_E___S_P_E_C_U_L_A_R___C_O_L_O_R is specified, the value returned
              from querying the current secondary color is undefined.

              _g_l_:_s_e_c_o_n_d_a_r_y_C_o_l_o_r_3_b, _g_l_:_s_e_c_o_n_d_a_r_y_C_o_l_o_r_3_s, and
              _g_l_:_s_e_c_o_n_d_a_r_y_C_o_l_o_r_3_i take three signed byte, short, or long
              integers as arguments. When _v is appended to the name, the color
              commands can take a pointer to an array of such values.

              Color values are stored in floating-point format, with
              unspecified mantissa and exponent sizes. Unsigned integer color
              components, when specified, are linearly mapped to floating-
              point values such that the largest representable value maps to
              1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed
              integer color components, when specified, are linearly mapped to
              floating-point values such that the most positive representable
              value maps to 1.0, and the most negative representable value
              maps to -1.0. (Note that this mapping does not convert 0
              precisely to 0.0). Floating-point values are mapped directly.

              Neither floating-point nor signed integer values are clamped to
              the range [0 1] before the current color is updated. However,
              color components are clamped to this range before they are
              interpolated or written into a color buffer.

              See external documentation.

       sseeccoonnddaarryyCCoolloorr33bbvv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer()}

              Equivalent to sseeccoonnddaarryyCCoolloorr33bb((RReedd,, GGrreeeenn,, BBlluuee)).

       sseeccoonnddaarryyCCoolloorr33dd((RReedd,, GGrreeeenn,, BBlluuee)) -->> ookk

              Types:

                 Red = float()
                 Green = float()
                 Blue = float()

              See sseeccoonnddaarryyCCoolloorr33bb//33

       sseeccoonnddaarryyCCoolloorr33ddvv((VV)) -->> ookk

              Types:

                 V = {Red::float(), Green::float(), Blue::float()}

              Equivalent to sseeccoonnddaarryyCCoolloorr33dd((RReedd,, GGrreeeenn,, BBlluuee)).

       sseeccoonnddaarryyCCoolloorr33ff((RReedd,, GGrreeeenn,, BBlluuee)) -->> ookk

              Types:

                 Red = float()
                 Green = float()
                 Blue = float()

              See sseeccoonnddaarryyCCoolloorr33bb//33

       sseeccoonnddaarryyCCoolloorr33ffvv((VV)) -->> ookk

              Types:

                 V = {Red::float(), Green::float(), Blue::float()}

              Equivalent to sseeccoonnddaarryyCCoolloorr33ff((RReedd,, GGrreeeenn,, BBlluuee)).

       sseeccoonnddaarryyCCoolloorr33ii((RReedd,, GGrreeeenn,, BBlluuee)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()

              See sseeccoonnddaarryyCCoolloorr33bb//33

       sseeccoonnddaarryyCCoolloorr33iivv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer()}

              Equivalent to sseeccoonnddaarryyCCoolloorr33ii((RReedd,, GGrreeeenn,, BBlluuee)).

       sseeccoonnddaarryyCCoolloorr33ss((RReedd,, GGrreeeenn,, BBlluuee)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()

              See sseeccoonnddaarryyCCoolloorr33bb//33

       sseeccoonnddaarryyCCoolloorr33ssvv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer()}

              Equivalent to sseeccoonnddaarryyCCoolloorr33ss((RReedd,, GGrreeeenn,, BBlluuee)).

       sseeccoonnddaarryyCCoolloorr33uubb((RReedd,, GGrreeeenn,, BBlluuee)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()

              See sseeccoonnddaarryyCCoolloorr33bb//33

       sseeccoonnddaarryyCCoolloorr33uubbvv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer()}

              Equivalent to sseeccoonnddaarryyCCoolloorr33uubb((RReedd,, GGrreeeenn,, BBlluuee)).

       sseeccoonnddaarryyCCoolloorr33uuii((RReedd,, GGrreeeenn,, BBlluuee)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()

              See sseeccoonnddaarryyCCoolloorr33bb//33

       sseeccoonnddaarryyCCoolloorr33uuiivv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer()}

              Equivalent to sseeccoonnddaarryyCCoolloorr33uuii((RReedd,, GGrreeeenn,, BBlluuee)).

       sseeccoonnddaarryyCCoolloorr33uuss((RReedd,, GGrreeeenn,, BBlluuee)) -->> ookk

              Types:

                 Red = integer()
                 Green = integer()
                 Blue = integer()

              See sseeccoonnddaarryyCCoolloorr33bb//33

       sseeccoonnddaarryyCCoolloorr33uussvv((VV)) -->> ookk

              Types:

                 V = {Red::integer(), Green::integer(), Blue::integer()}

              Equivalent to sseeccoonnddaarryyCCoolloorr33uuss((RReedd,, GGrreeeenn,, BBlluuee)).

       sseeccoonnddaarryyCCoolloorrPPooiinntteerr((SSiizzee,, TTyyppee,, SSttrriiddee,, PPooiinntteerr)) -->> ookk

              Types:

                 Size = integer()
                 Type = enum()
                 Stride = integer()
                 Pointer = offset() | mem()

              Define an array of secondary colors

              _g_l_:_s_e_c_o_n_d_a_r_y_C_o_l_o_r_P_o_i_n_t_e_r specifies the location and data format
              of an array of color components to use when rendering. _S_i_z_e
              specifies the number of components per color, and must be 3.
              _T_y_p_e specifies the data type of each color component, and _S_t_r_i_d_e
              specifies the byte stride from one color to the next, allowing
              vertices and attributes to be packed into a single array or
              stored in separate arrays.

              If a non-zero named buffer object is bound to the
              _?_G_L___A_R_R_A_Y___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ) while a secondary
              color array is specified, _P_o_i_n_t_e_r is treated as a byte offset
              into the buffer object's data store. Also, the buffer object
              binding (_?_G_L___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G ) is saved as secondary color
              vertex array client-side state
              (_?_G_L___S_E_C_O_N_D_A_R_Y___C_O_L_O_R___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G ).

              When a secondary color array is specified, _S_i_z_e , _T_y_p_e , _S_t_r_i_d_e
              , and _P_o_i_n_t_e_r are saved as client-side state, in addition to the
              current vertex array buffer object binding.

              To enable and disable the secondary color array, call
              ggll::eennaabblleeCClliieennttSSttaattee//11 and ggll::eennaabblleeCClliieennttSSttaattee//11 with the
              argument _?_G_L___S_E_C_O_N_D_A_R_Y___C_O_L_O_R___A_R_R_A_Y. If enabled, the secondary
              color array is used when ggll::aarrrraayyEElleemmeenntt//11 , ggll::ddrraawwAArrrraayyss//33 ,
              ggll::mmuullttiiDDrraawwAArrrraayyss//33 , ggll::ddrraawwEElleemmeennttss//44 , see
              _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s, or ggll::ddrraawwRRaannggeeEElleemmeennttss//66 is called.

              See external documentation.

       wwiinnddoowwPPooss22dd((XX,, YY)) -->> ookk

              Types:

                 X = float()
                 Y = float()

              Specify the raster position in window coordinates for pixel
              operations

              The GL maintains a 3D position in window coordinates. This
              position, called the raster position, is used to position pixel
              and bitmap write operations. It is maintained with subpixel
              accuracy. See ggll::bbiittmmaapp//77 , ggll::ddrraawwPPiixxeellss//55 , and
              ggll::ccooppyyPPiixxeellss//55 .

              _g_l_:_w_i_n_d_o_w_P_o_s_2 specifies the x and y coordinates, while z is
              implicitly set to 0. _g_l_:_w_i_n_d_o_w_P_o_s_3 specifies all three
              coordinates. The w coordinate of the current raster position is
              always set to 1.0.

              _g_l_:_w_i_n_d_o_w_P_o_s directly updates the x and y coordinates of the
              current raster position with the values specified. That is, the
              values are neither transformed by the current modelview and
              projection matrices, nor by the viewport-to-window transform.
              The z coordinate of the current raster position is updated in
              the following manner:

              z={n f(n+z*(f-n)) if z<= 0 if z>= 1(otherwise))

              where n is _?_G_L___D_E_P_T_H___R_A_N_G_E's near value, and f is
              _?_G_L___D_E_P_T_H___R_A_N_G_E's far value. See ggll::ddeepptthhRRaannggee//22 .

              The specified coordinates are not clip-tested, causing the
              raster position to always be valid.

              The current raster position also includes some associated color
              data and texture coordinates. If lighting is enabled, then
              _?_G_L___C_U_R_R_E_N_T___R_A_S_T_E_R___C_O_L_O_R (in RGBA mode) or
              _?_G_L___C_U_R_R_E_N_T___R_A_S_T_E_R___I_N_D_E_X (in color index mode) is set to the
              color produced by the lighting calculation (see ggll::lliigghhttff//33 ,
              ggll::lliigghhttMMooddeellff//22 , and ggll::sshhaaddeeMMooddeell//11 ). If lighting is
              disabled, current color (in RGBA mode, state variable
              _?_G_L___C_U_R_R_E_N_T___C_O_L_O_R) or color index (in color index mode, state
              variable _?_G_L___C_U_R_R_E_N_T___I_N_D_E_X) is used to update the current raster
              color. _?_G_L___C_U_R_R_E_N_T___R_A_S_T_E_R___S_E_C_O_N_D_A_R_Y___C_O_L_O_R (in RGBA mode) is
              likewise updated.

              Likewise, _?_G_L___C_U_R_R_E_N_T___R_A_S_T_E_R___T_E_X_T_U_R_E___C_O_O_R_D_S is updated as a
              function of _?_G_L___C_U_R_R_E_N_T___T_E_X_T_U_R_E___C_O_O_R_D_S , based on the texture
              matrix and the texture generation functions (see ggll::tteexxGGeenndd//33 ).
              The _?_G_L___C_U_R_R_E_N_T___R_A_S_T_E_R___D_I_S_T_A_N_C_E is set to the
              _?_G_L___C_U_R_R_E_N_T___F_O_G___C_O_O_R_D.

              See external documentation.

       wwiinnddoowwPPooss22ddvv((VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float()}

              Equivalent to wwiinnddoowwPPooss22dd((XX,, YY)).

       wwiinnddoowwPPooss22ff((XX,, YY)) -->> ookk

              Types:

                 X = float()
                 Y = float()

              See wwiinnddoowwPPooss22dd//22

       wwiinnddoowwPPooss22ffvv((VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float()}

              Equivalent to wwiinnddoowwPPooss22ff((XX,, YY)).

       wwiinnddoowwPPooss22ii((XX,, YY)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()

              See wwiinnddoowwPPooss22dd//22

       wwiinnddoowwPPooss22iivv((VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer()}

              Equivalent to wwiinnddoowwPPooss22ii((XX,, YY)).

       wwiinnddoowwPPooss22ss((XX,, YY)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()

              See wwiinnddoowwPPooss22dd//22

       wwiinnddoowwPPooss22ssvv((VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer()}

              Equivalent to wwiinnddoowwPPooss22ss((XX,, YY)).

       wwiinnddoowwPPooss33dd((XX,, YY,, ZZ)) -->> ookk

              Types:

                 X = float()
                 Y = float()
                 Z = float()

              See wwiinnddoowwPPooss22dd//22

       wwiinnddoowwPPooss33ddvv((VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float(), Z::float()}

              Equivalent to wwiinnddoowwPPooss33dd((XX,, YY,, ZZ)).

       wwiinnddoowwPPooss33ff((XX,, YY,, ZZ)) -->> ookk

              Types:

                 X = float()
                 Y = float()
                 Z = float()

              See wwiinnddoowwPPooss22dd//22

       wwiinnddoowwPPooss33ffvv((VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float(), Z::float()}

              Equivalent to wwiinnddoowwPPooss33ff((XX,, YY,, ZZ)).

       wwiinnddoowwPPooss33ii((XX,, YY,, ZZ)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()
                 Z = integer()

              See wwiinnddoowwPPooss22dd//22

       wwiinnddoowwPPooss33iivv((VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer()}

              Equivalent to wwiinnddoowwPPooss33ii((XX,, YY,, ZZ)).

       wwiinnddoowwPPooss33ss((XX,, YY,, ZZ)) -->> ookk

              Types:

                 X = integer()
                 Y = integer()
                 Z = integer()

              See wwiinnddoowwPPooss22dd//22

       wwiinnddoowwPPooss33ssvv((VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer()}

              Equivalent to wwiinnddoowwPPooss33ss((XX,, YY,, ZZ)).

       ggeennQQuueerriieess((NN)) -->> [[iinntteeggeerr(())]]

              Types:

                 N = integer()

              Generate query object names

              _g_l_:_g_e_n_Q_u_e_r_i_e_s returns _N query object names in _I_d_s . There is no
              guarantee that the names form a contiguous set of integers;
              however, it is guaranteed that none of the returned names was in
              use immediately before the call to _g_l_:_g_e_n_Q_u_e_r_i_e_s.

              Query object names returned by a call to _g_l_:_g_e_n_Q_u_e_r_i_e_s are not
              returned by subsequent calls, unless they are first deleted with
              ggll::ddeelleetteeQQuueerriieess//11 .

              No query objects are associated with the returned query object
              names until they are first used by calling ggll::bbeeggiinnQQuueerryy//22 .

              See external documentation.

       ddeelleetteeQQuueerriieess((IIddss)) -->> ookk

              Types:

                 Ids = [integer()]

              Delete named query objects

              _g_l_:_d_e_l_e_t_e_Q_u_e_r_i_e_s deletes _N query objects named by the elements
              of the array _I_d_s . After a query object is deleted, it has no
              contents, and its name is free for reuse (for example by
              ggll::ggeennQQuueerriieess//11 ).

              _g_l_:_d_e_l_e_t_e_Q_u_e_r_i_e_s silently ignores 0's and names that do not
              correspond to existing query objects.

              See external documentation.

       iissQQuueerryy((IIdd)) -->> 00 || 11

              Types:

                 Id = integer()

              Determine if a name corresponds to a query object

              _g_l_:_i_s_Q_u_e_r_y returns _?_G_L___T_R_U_E if _I_d is currently the name of a
              query object. If _I_d is zero, or is a non-zero value that is not
              currently the name of a query object, or if an error occurs,
              _g_l_:_i_s_Q_u_e_r_y returns _?_G_L___F_A_L_S_E.

              A name returned by ggll::ggeennQQuueerriieess//11 , but not yet associated with
              a query object by calling ggll::bbeeggiinnQQuueerryy//22 , is not the name of a
              query object.

              See external documentation.

       bbeeggiinnQQuueerryy((TTaarrggeett,, IIdd)) -->> ookk

              Types:

                 Target = enum()
                 Id = integer()

              Delimit the boundaries of a query object

              _g_l_:_b_e_g_i_n_Q_u_e_r_y and ggll::bbeeggiinnQQuueerryy//22 delimit the boundaries of a
              query object. _Q_u_e_r_y must be a name previously returned from a
              call to ggll::ggeennQQuueerriieess//11 . If a query object with name _I_d does
              not yet exist it is created with the type determined by _T_a_r_g_e_t .
              _T_a_r_g_e_t must be one of _?_G_L___S_A_M_P_L_E_S___P_A_S_S_E_D,
              _?_G_L___A_N_Y___S_A_M_P_L_E_S___P_A_S_S_E_D, _?_G_L___P_R_I_M_I_T_I_V_E_S___G_E_N_E_R_A_T_E_D ,
              _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___P_R_I_M_I_T_I_V_E_S___W_R_I_T_T_E_N, or _?_G_L___T_I_M_E___E_L_A_P_S_E_D.
              The behavior of the query object depends on its type and is as
              follows.

              If _T_a_r_g_e_t is _?_G_L___S_A_M_P_L_E_S___P_A_S_S_E_D, _I_d must be an unused name, or
              the name of an existing occlusion query object. When
              _g_l_:_b_e_g_i_n_Q_u_e_r_y is executed, the query object's samples-passed
              counter is reset to 0. Subsequent rendering will increment the
              counter for every sample that passes the depth test. If the
              value of _?_G_L___S_A_M_P_L_E___B_U_F_F_E_R_S is 0, then the samples-passed count
              is incremented by 1 for each fragment. If the value of
              _?_G_L___S_A_M_P_L_E___B_U_F_F_E_R_S is 1, then the samples-passed count is
              incremented by the number of samples whose coverage bit is set.
              However, implementations, at their discression may instead
              increase the samples-passed count by the value of _?_G_L___S_A_M_P_L_E_S if
              any sample in the fragment is covered. When _g_l_:_e_n_d_Q_u_e_r_y is
              executed, the samples-passed counter is assigned to the query
              object's result value. This value can be queried by calling
              ggll::ggeettQQuueerryyOObbjjeeccttiivv//22 with _P_n_a_m_e _?_G_L___Q_U_E_R_Y___R_E_S_U_L_T.

              If _T_a_r_g_e_t is _?_G_L___A_N_Y___S_A_M_P_L_E_S___P_A_S_S_E_D, _I_d must be an unused name,
              or the name of an existing boolean occlusion query object. When
              _g_l_:_b_e_g_i_n_Q_u_e_r_y is executed, the query object's samples-passed
              flag is reset to _?_G_L___F_A_L_S_E. Subsequent rendering causes the flag
              to be set to _?_G_L___T_R_U_E if any sample passes the depth test. When
              _g_l_:_e_n_d_Q_u_e_r_y is executed, the samples-passed flag is assigned to
              the query object's result value. This value can be queried by
              calling ggll::ggeettQQuueerryyOObbjjeeccttiivv//22 with _P_n_a_m_e _?_G_L___Q_U_E_R_Y___R_E_S_U_L_T.

              If _T_a_r_g_e_t is _?_G_L___P_R_I_M_I_T_I_V_E_S___G_E_N_E_R_A_T_E_D, _I_d must be an unused
              name, or the name of an existing primitive query object
              previously bound to the _?_G_L___P_R_I_M_I_T_I_V_E_S___G_E_N_E_R_A_T_E_D query binding.
              When _g_l_:_b_e_g_i_n_Q_u_e_r_y is executed, the query object's primitives-
              generated counter is reset to 0. Subsequent rendering will
              increment the counter once for every vertex that is emitted from
              the geometry shader, or from the vertex shader if no geometry
              shader is present. When _g_l_:_e_n_d_Q_u_e_r_y is executed, the primitives-
              generated counter is assigned to the query object's result
              value. This value can be queried by calling
              ggll::ggeettQQuueerryyOObbjjeeccttiivv//22 with _P_n_a_m_e _?_G_L___Q_U_E_R_Y___R_E_S_U_L_T.

              If _T_a_r_g_e_t is _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___P_R_I_M_I_T_I_V_E_S___W_R_I_T_T_E_N, _I_d must
              be an unused name, or the name of an existing primitive query
              object previously bound to the
              _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___P_R_I_M_I_T_I_V_E_S___W_R_I_T_T_E_N query binding. When
              _g_l_:_b_e_g_i_n_Q_u_e_r_y is executed, the query object's primitives-written
              counter is reset to 0. Subsequent rendering will increment the
              counter once for every vertex that is written into the bound
              transform feedback buffer(s). If transform feedback mode is not
              activated between the call to _g_l_:_b_e_g_i_n_Q_u_e_r_y and _g_l_:_e_n_d_Q_u_e_r_y, the
              counter will not be incremented. When _g_l_:_e_n_d_Q_u_e_r_y is executed,
              the primitives-written counter is assigned to the query object's
              result value. This value can be queried by calling
              ggll::ggeettQQuueerryyOObbjjeeccttiivv//22 with _P_n_a_m_e _?_G_L___Q_U_E_R_Y___R_E_S_U_L_T.

              If _T_a_r_g_e_t is _?_G_L___T_I_M_E___E_L_A_P_S_E_D, _I_d must be an unused name, or the
              name of an existing timer query object previously bound to the
              _?_G_L___T_I_M_E___E_L_A_P_S_E_D query binding. When _g_l_:_b_e_g_i_n_Q_u_e_r_y is executed,
              the query object's time counter is reset to 0. When _g_l_:_e_n_d_Q_u_e_r_y
              is executed, the elapsed server time that has passed since the
              call to _g_l_:_b_e_g_i_n_Q_u_e_r_y is written into the query object's time
              counter. This value can be queried by calling
              ggll::ggeettQQuueerryyOObbjjeeccttiivv//22 with _P_n_a_m_e _?_G_L___Q_U_E_R_Y___R_E_S_U_L_T .

              Querying the _?_G_L___Q_U_E_R_Y___R_E_S_U_L_T implicitly flushes the GL pipeline
              until the rendering delimited by the query object has completed
              and the result is available. _?_G_L___Q_U_E_R_Y___R_E_S_U_L_T___A_V_A_I_L_A_B_L_E can be
              queried to determine if the result is immediately available or
              if the rendering is not yet complete.

              See external documentation.

       eennddQQuueerryy((TTaarrggeett)) -->> ookk

              Types:

                 Target = enum()

              See bbeeggiinnQQuueerryy//22

       ggeettQQuueerryyiivv((TTaarrggeett,, PPnnaammee)) -->> iinntteeggeerr(())

              Types:

                 Target = enum()
                 Pname = enum()

              glGetQuery

              See external documentation.

       ggeettQQuueerryyOObbjjeeccttiivv((IIdd,, PPnnaammee)) -->> iinntteeggeerr(())

              Types:

                 Id = integer()
                 Pname = enum()

              Return parameters of a query object

              _g_l_:_g_e_t_Q_u_e_r_y_O_b_j_e_c_t returns in _P_a_r_a_m_s a selected parameter of the
              query object specified by _I_d .

              _P_n_a_m_e names a specific query object parameter. _P_n_a_m_e can be as
              follows:

              _?_G_L___Q_U_E_R_Y___R_E_S_U_L_T: _P_a_r_a_m_s returns the value of the query object's
              passed samples counter. The initial value is 0.

              _?_G_L___Q_U_E_R_Y___R_E_S_U_L_T___A_V_A_I_L_A_B_L_E: _P_a_r_a_m_s returns whether the passed
              samples counter is immediately available. If a delay would occur
              waiting for the query result, _?_G_L___F_A_L_S_E is returned. Otherwise,
              _?_G_L___T_R_U_E is returned, which also indicates that the results of
              all previous queries are available as well.

              See external documentation.

       ggeettQQuueerryyOObbjjeeccttuuiivv((IIdd,, PPnnaammee)) -->> iinntteeggeerr(())

              Types:

                 Id = integer()
                 Pname = enum()

              See ggeettQQuueerryyOObbjjeeccttiivv//22

       bbiinnddBBuuffffeerr((TTaarrggeett,, BBuuffffeerr)) -->> ookk

              Types:

                 Target = enum()
                 Buffer = integer()

              Bind a named buffer object

              _g_l_:_b_i_n_d_B_u_f_f_e_r binds a buffer object to the specified buffer
              binding point. Calling _g_l_:_b_i_n_d_B_u_f_f_e_r with _T_a_r_g_e_t set to one of
              the accepted symbolic constants and _B_u_f_f_e_r set to the name of a
              buffer object binds that buffer object name to the target. If no
              buffer object with name _B_u_f_f_e_r exists, one is created with that
              name. When a buffer object is bound to a target, the previous
              binding for that target is automatically broken.

              Buffer object names are unsigned integers. The value zero is
              reserved, but there is no default buffer object for each buffer
              object target. Instead, _B_u_f_f_e_r set to zero effectively unbinds
              any buffer object previously bound, and restores client memory
              usage for that buffer object target (if supported for that
              target). Buffer object names and the corresponding buffer object
              contents are local to the shared object space of the current GL
              rendering context; two rendering contexts share buffer object
              names only if they explicitly enable sharing between contexts
              through the appropriate GL windows interfaces functions.

              ggll::ggeennBBuuffffeerrss//11 must be used to generate a set of unused buffer
              object names.

              The state of a buffer object immediately after it is first bound
              is an unmapped zero-sized memory buffer with _?_G_L___R_E_A_D___W_R_I_T_E
              access and _?_G_L___S_T_A_T_I_C___D_R_A_W usage.

              While a non-zero buffer object name is bound, GL operations on
              the target to which it is bound affect the bound buffer object,
              and queries of the target to which it is bound return state from
              the bound buffer object. While buffer object name zero is bound,
              as in the initial state, attempts to modify or query state on
              the target to which it is bound generates an
              _?_G_L___I_N_V_A_L_I_D___O_P_E_R_A_T_I_O_N error.

              When a non-zero buffer object is bound to the _?_G_L___A_R_R_A_Y___B_U_F_F_E_R
              target, the vertex array pointer parameter is interpreted as an
              offset within the buffer object measured in basic machine units.

              When a non-zero buffer object is bound to the
              _?_G_L___D_R_A_W___I_N_D_I_R_E_C_T___B_U_F_F_E_R target, parameters for draws issued
              through ggll::ddrraawwAArrrraayyssIInnddiirreecctt//22 and ggll::ddrraawwEElleemmeennttssIInnddiirreecctt//33
              are sourced from that buffer object.

              While a non-zero buffer object is bound to the
              _?_G_L___E_L_E_M_E_N_T___A_R_R_A_Y___B_U_F_F_E_R target, the indices parameter of
              ggll::ddrraawwEElleemmeennttss//44 , ggll::ddrraawwEElleemmeennttssIInnssttaanncceedd//55 ,
              ggll::ddrraawwEElleemmeennttssBBaasseeVVeerrtteexx//55 , ggll::ddrraawwRRaannggeeEElleemmeennttss//66 ,
              ggll::ddrraawwRRaannggeeEElleemmeennttssBBaasseeVVeerrtteexx//77 , see _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s , or
              see _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s_B_a_s_e_V_e_r_t_e_x is interpreted as an offset
              within the buffer object measured in basic machine units.

              While a non-zero buffer object is bound to the
              _?_G_L___P_I_X_E_L___P_A_C_K___B_U_F_F_E_R target, the following commands are
              affected: ggll::ggeettCCoommpprreesssseeddTTeexxIImmaaggee//33 , ggll::ggeettTTeexxIImmaaggee//55 , and
              ggll::rreeaaddPPiixxeellss//77 . The pointer parameter is interpreted as an
              offset within the buffer object measured in basic machine units.

              While a non-zero buffer object is bound to the
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R target, the following commands are
              affected: ggll::ccoommpprreesssseeddTTeexxIImmaaggee11DD//77 , ggll::ccoommpprreesssseeddTTeexxIImmaaggee22DD//88
              , ggll::ccoommpprreesssseeddTTeexxIImmaaggee33DD//99 , ggll::ccoommpprreesssseeddTTeexxSSuubbIImmaaggee11DD//77 ,
              ggll::ccoommpprreesssseeddTTeexxSSuubbIImmaaggee22DD//99 , ggll::ccoommpprreesssseeddTTeexxSSuubbIImmaaggee33DD//1111 ,
              ggll::tteexxIImmaaggee11DD//88 , ggll::tteexxIImmaaggee22DD//99 , ggll::tteexxIImmaaggee33DD//1100 ,
              ggll::tteexxSSuubbIImmaaggee11DD//77 , ggll::tteexxSSuubbIImmaaggee11DD//77 , and ggll::tteexxSSuubbIImmaaggee11DD//77
              . The pointer parameter is interpreted as an offset within the
              buffer object measured in basic machine units.

              The buffer targets _?_G_L___C_O_P_Y___R_E_A_D___B_U_F_F_E_R and
              _?_G_L___C_O_P_Y___W_R_I_T_E___B_U_F_F_E_R are provided to allow
              ggll::ccooppyyBBuuffffeerrSSuubbDDaattaa//55 to be used without disturbing the state
              of other bindings. However, ggll::ccooppyyBBuuffffeerrSSuubbDDaattaa//55 may be used
              with any pair of buffer binding points.

              The _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___B_U_F_F_E_R buffer binding point may be
              passed to _g_l_:_b_i_n_d_B_u_f_f_e_r , but will not directly affect transform
              feedback state. Instead, the indexed
              _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___B_U_F_F_E_R bindings must be used through a
              call to ggll::bbiinnddBBuuffffeerrBBaassee//33 or ggll::bbiinnddBBuuffffeerrRRaannggee//55 . This will
              affect the generic _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_A_B_C_K___B_U_F_F_E_R binding.

              Likewise, the _?_G_L___U_N_I_F_O_R_M___B_U_F_F_E_R and _?_G_L___A_T_O_M_I_C___C_O_U_N_T_E_R___B_U_F_F_E_R
              buffer binding points may be used, but do not directly affect
              uniform buffer or atomic counter buffer state, respectively.
              ggll::bbiinnddBBuuffffeerrBBaassee//33 or ggll::bbiinnddBBuuffffeerrRRaannggee//55 must be used to bind
              a buffer to an indexed uniform buffer or atomic counter buffer
              binding point.

              A buffer object binding created with _g_l_:_b_i_n_d_B_u_f_f_e_r remains
              active until a different buffer object name is bound to the same
              target, or until the bound buffer object is deleted with
              ggll::ddeelleetteeBBuuffffeerrss//11 .

              Once created, a named buffer object may be re-bound to any
              target as often as needed. However, the GL implementation may
              make choices about how to optimize the storage of a buffer
              object based on its initial binding target.

              See external documentation.

       ddeelleetteeBBuuffffeerrss((BBuuffffeerrss)) -->> ookk

              Types:

                 Buffers = [integer()]

              Delete named buffer objects

              _g_l_:_d_e_l_e_t_e_B_u_f_f_e_r_s deletes _N buffer objects named by the elements
              of the array _B_u_f_f_e_r_s . After a buffer object is deleted, it has
              no contents, and its name is free for reuse (for example by
              ggll::ggeennBBuuffffeerrss//11 ). If a buffer object that is currently bound is
              deleted, the binding reverts to 0 (the absence of any buffer
              object).

              _g_l_:_d_e_l_e_t_e_B_u_f_f_e_r_s silently ignores 0's and names that do not
              correspond to existing buffer objects.

              See external documentation.

       ggeennBBuuffffeerrss((NN)) -->> [[iinntteeggeerr(())]]

              Types:

                 N = integer()

              Generate buffer object names

              _g_l_:_g_e_n_B_u_f_f_e_r_s returns _N buffer object names in _B_u_f_f_e_r_s . There
              is no guarantee that the names form a contiguous set of
              integers; however, it is guaranteed that none of the returned
              names was in use immediately before the call to _g_l_:_g_e_n_B_u_f_f_e_r_s .

              Buffer object names returned by a call to _g_l_:_g_e_n_B_u_f_f_e_r_s are not
              returned by subsequent calls, unless they are first deleted with
              ggll::ddeelleetteeBBuuffffeerrss//11 .

              No buffer objects are associated with the returned buffer object
              names until they are first bound by calling ggll::bbiinnddBBuuffffeerr//22 .

              See external documentation.

       iissBBuuffffeerr((BBuuffffeerr)) -->> 00 || 11

              Types:

                 Buffer = integer()

              Determine if a name corresponds to a buffer object

              _g_l_:_i_s_B_u_f_f_e_r returns _?_G_L___T_R_U_E if _B_u_f_f_e_r is currently the name of
              a buffer object. If _B_u_f_f_e_r is zero, or is a non-zero value that
              is not currently the name of a buffer object, or if an error
              occurs, _g_l_:_i_s_B_u_f_f_e_r returns _?_G_L___F_A_L_S_E .

              A name returned by ggll::ggeennBBuuffffeerrss//11 , but not yet associated with
              a buffer object by calling ggll::bbiinnddBBuuffffeerr//22 , is not the name of
              a buffer object.

              See external documentation.

       bbuuffffeerrDDaattaa((TTaarrggeett,, SSiizzee,, DDaattaa,, UUssaaggee)) -->> ookk

              Types:

                 Target = enum()
                 Size = integer()
                 Data = offset() | mem()
                 Usage = enum()

              Creates and initializes a buffer object's data store

              _g_l_:_b_u_f_f_e_r_D_a_t_a creates a new data store for the buffer object
              currently bound to _T_a_r_g_e_t . Any pre-existing data store is
              deleted. The new data store is created with the specified _S_i_z_e
              in bytes and _U_s_a_g_e . If _D_a_t_a is not _?_N_U_L_L, the data store is
              initialized with data from this pointer. In its initial state,
              the new data store is not mapped, it has a _?_N_U_L_L mapped pointer,
              and its mapped access is _?_G_L___R_E_A_D___W_R_I_T_E .

              _U_s_a_g_e is a hint to the GL implementation as to how a buffer
              object's data store will be accessed. This enables the GL
              implementation to make more intelligent decisions that may
              significantly impact buffer object performance. It does not,
              however, constrain the actual usage of the data store. _U_s_a_g_e can
              be broken down into two parts: first, the frequency of access
              (modification and usage), and second, the nature of that access.
              The frequency of access may be one of these:

              STREAM: The data store contents will be modified once and used
              at most a few times.

              STATIC: The data store contents will be modified once and used
              many times.

              DYNAMIC: The data store contents will be modified repeatedly and
              used many times.

              The nature of access may be one of these:

              DRAW: The data store contents are modified by the application,
              and used as the source for GL drawing and image specification
              commands.

              READ: The data store contents are modified by reading data from
              the GL, and used to return that data when queried by the
              application.

              COPY: The data store contents are modified by reading data from
              the GL, and used as the source for GL drawing and image
              specification commands.

              See external documentation.

       bbuuffffeerrSSuubbDDaattaa((TTaarrggeett,, OOffffsseett,, SSiizzee,, DDaattaa)) -->> ookk

              Types:

                 Target = enum()
                 Offset = integer()
                 Size = integer()
                 Data = offset() | mem()

              Updates a subset of a buffer object's data store

              _g_l_:_b_u_f_f_e_r_S_u_b_D_a_t_a redefines some or all of the data store for the
              buffer object currently bound to _T_a_r_g_e_t . Data starting at byte
              offset _O_f_f_s_e_t and extending for _S_i_z_e bytes is copied to the data
              store from the memory pointed to by _D_a_t_a . An error is thrown if
              _O_f_f_s_e_t and _S_i_z_e together define a range beyond the bounds of the
              buffer object's data store.

              See external documentation.

       ggeettBBuuffffeerrSSuubbDDaattaa((TTaarrggeett,, OOffffsseett,, SSiizzee,, DDaattaa)) -->> ookk

              Types:

                 Target = enum()
                 Offset = integer()
                 Size = integer()
                 Data = mem()

              Returns a subset of a buffer object's data store

              _g_l_:_g_e_t_B_u_f_f_e_r_S_u_b_D_a_t_a returns some or all of the data from the
              buffer object currently bound to _T_a_r_g_e_t . Data starting at byte
              offset _O_f_f_s_e_t and extending for _S_i_z_e bytes is copied from the
              data store to the memory pointed to by _D_a_t_a . An error is thrown
              if the buffer object is currently mapped, or if _O_f_f_s_e_t and _S_i_z_e
              together define a range beyond the bounds of the buffer object's
              data store.

              See external documentation.

       ggeettBBuuffffeerrPPaarraammeetteerriivv((TTaarrggeett,, PPnnaammee)) -->> iinntteeggeerr(())

              Types:

                 Target = enum()
                 Pname = enum()

              Return parameters of a buffer object

              _g_l_:_g_e_t_B_u_f_f_e_r_P_a_r_a_m_e_t_e_r_i_v returns in _D_a_t_a a selected parameter of
              the buffer object specified by _T_a_r_g_e_t .

              _V_a_l_u_e names a specific buffer object parameter, as follows:

              _?_G_L___B_U_F_F_E_R___A_C_C_E_S_S: _P_a_r_a_m_s returns the access policy set while
              mapping the buffer object. The initial value is _?_G_L___R_E_A_D___W_R_I_T_E.

              _?_G_L___B_U_F_F_E_R___M_A_P_P_E_D: _P_a_r_a_m_s returns a flag indicating whether the
              buffer object is currently mapped. The initial value is
              _?_G_L___F_A_L_S_E.

              _?_G_L___B_U_F_F_E_R___S_I_Z_E: _P_a_r_a_m_s returns the size of the buffer object,
              measured in bytes. The initial value is 0.

              _?_G_L___B_U_F_F_E_R___U_S_A_G_E: _P_a_r_a_m_s returns the buffer object's usage
              pattern. The initial value is _?_G_L___S_T_A_T_I_C___D_R_A_W.

              See external documentation.

       bblleennddEEqquuaattiioonnSSeeppaarraattee((MMooddeeRRGGBB,, MMooddeeAAllpphhaa)) -->> ookk

              Types:

                 ModeRGB = enum()
                 ModeAlpha = enum()

              Set the RGB blend equation and the alpha blend equation
              separately

              The blend equations determines how a new pixel (the ''source''
              color) is combined with a pixel already in the framebuffer (the
              ''destination'' color). These functions specifie one blend
              equation for the RGB-color components and one blend equation for
              the alpha component. _g_l_:_b_l_e_n_d_E_q_u_a_t_i_o_n_S_e_p_a_r_a_t_e_i specifies the
              blend equations for a single draw buffer whereas
              _g_l_:_b_l_e_n_d_E_q_u_a_t_i_o_n_S_e_p_a_r_a_t_e sets the blend equations for all draw
              buffers.

              The blend equations use the source and destination blend factors
              specified by either ggll::bblleennddFFuunncc//22 or ggll::bblleennddFFuunnccSSeeppaarraattee//44 .
              See ggll::bblleennddFFuunncc//22 or ggll::bblleennddFFuunnccSSeeppaarraattee//44 for a description
              of the various blend factors.

              In the equations that follow, source and destination color
              components are referred to as (R s G s B s A s) and (R d G d B d
              A d), respectively. The result color is referred to as (R r G r
              B r A r). The source and destination blend factors are denoted
              (s R s G s B s A) and (d R d G d B d A), respectively. For these
              equations all color components are understood to have values in
              the range [0 1]._M_o_d_e_R_G_B _C_o_m_p_o_n_e_n_t_s_A_l_p_h_a _C_o_m_p_o_n_e_n_t
              _?_G_L___F_U_N_C___A_D_D Rr= R s s R+R d d R Gr= G s s G+G d d G Br= B s s
              B+B d d B Ar= A s s A+A d d A
              _?_G_L___F_U_N_C___S_U_B_T_R_A_C_T Rr= R s s R-R d d R Gr= G s s G-G d d G Br= B
              s s B-B d d B Ar= A s s A-A d d A
              _?_G_L___F_U_N_C___R_E_V_E_R_S_E___S_U_B_T_R_A_C_T Rr= R d d R-R s s R Gr= G d d G-G s s
              G Br= B d d B-B s s B Ar= A d d A-A s s A
              _?_G_L___M_I_N Rr= min(R s R d) Gr= min(G s G d) Br= min(B s B d) Ar=
              min(A s A d)
              _?_G_L___M_A_X Rr= max(R s R d) Gr= max(G s G d) Br= max(B s B d) Ar=
              max(A s A d)


              The results of these equations are clamped to the range [0 1].

              The _?_G_L___M_I_N and _?_G_L___M_A_X equations are useful for applications
              that analyze image data (image thresholding against a constant
              color, for example). The _?_G_L___F_U_N_C___A_D_D equation is useful for
              antialiasing and transparency, among other things.

              Initially, both the RGB blend equation and the alpha blend
              equation are set to _?_G_L___F_U_N_C___A_D_D .

              See external documentation.

       ddrraawwBBuuffffeerrss((BBuuffss)) -->> ookk

              Types:

                 Bufs = [enum()]

              Specifies a list of color buffers to be drawn into

              _g_l_:_d_r_a_w_B_u_f_f_e_r_s defines an array of buffers into which outputs
              from the fragment shader data will be written. If a fragment
              shader writes a value to one or more user defined output
              variables, then the value of each variable will be written into
              the buffer specified at a location within _B_u_f_s corresponding to
              the location assigned to that user defined output. The draw
              buffer used for user defined outputs assigned to locations
              greater than or equal to _N is implicitly set to _?_G_L___N_O_N_E and any
              data written to such an output is discarded.

              The symbolic constants contained in _B_u_f_s may be any of the
              following:

              _?_G_L___N_O_N_E: The fragment shader output value is not written into
              any color buffer.

              _?_G_L___F_R_O_N_T___L_E_F_T: The fragment shader output value is written into
              the front left color buffer.

              _?_G_L___F_R_O_N_T___R_I_G_H_T: The fragment shader output value is written
              into the front right color buffer.

              _?_G_L___B_A_C_K___L_E_F_T: The fragment shader output value is written into
              the back left color buffer.

              _?_G_L___B_A_C_K___R_I_G_H_T: The fragment shader output value is written into
              the back right color buffer.

              _?_G_L___C_O_L_O_R___A_T_T_A_C_H_M_E_N_T_n: The fragment shader output value is
              written into the _nth color attachment of the current
              framebuffer. _n may range from 0 to the value of
              _?_G_L___M_A_X___C_O_L_O_R___A_T_T_A_C_H_M_E_N_T_S.

              Except for _?_G_L___N_O_N_E, the preceding symbolic constants may not
              appear more than once in _B_u_f_s . The maximum number of draw
              buffers supported is implementation dependent and can be queried
              by calling ggll::ggeettBBoooolleeaannvv//11 with the argument
              _?_G_L___M_A_X___D_R_A_W___B_U_F_F_E_R_S .

              See external documentation.

       sstteenncciillOOppSSeeppaarraattee((FFaaccee,, SSffaaiill,, DDppffaaiill,, DDppppaassss)) -->> ookk

              Types:

                 Face = enum()
                 Sfail = enum()
                 Dpfail = enum()
                 Dppass = enum()

              Set front and/or back stencil test actions

              Stenciling, like depth-buffering, enables and disables drawing
              on a per-pixel basis. You draw into the stencil planes using GL
              drawing primitives, then render geometry and images, using the
              stencil planes to mask out portions of the screen. Stenciling is
              typically used in multipass rendering algorithms to achieve
              special effects, such as decals, outlining, and constructive
              solid geometry rendering.

              The stencil test conditionally eliminates a pixel based on the
              outcome of a comparison between the value in the stencil buffer
              and a reference value. To enable and disable the test, call
              ggll::eennaabbllee//11 and ggll::eennaabbllee//11 with argument _?_G_L___S_T_E_N_C_I_L___T_E_S_T ; to
              control it, call ggll::sstteenncciillFFuunncc//33 or ggll::sstteenncciillFFuunnccSSeeppaarraattee//44 .

              There can be two separate sets of _S_f_a_i_l , _D_p_f_a_i_l , and _D_p_p_a_s_s
              parameters; one affects back-facing polygons, and the other
              affects front-facing polygons as well as other non-polygon
              primitives. ggll::sstteenncciillOOpp//33 sets both front and back stencil
              state to the same values, as if ggll::sstteenncciillOOppSSeeppaarraattee//44 were
              called with _F_a_c_e set to _?_G_L___F_R_O_N_T___A_N_D___B_A_C_K.

              _g_l_:_s_t_e_n_c_i_l_O_p_S_e_p_a_r_a_t_e takes three arguments that indicate what
              happens to the stored stencil value while stenciling is enabled.
              If the stencil test fails, no change is made to the pixel's
              color or depth buffers, and _S_f_a_i_l specifies what happens to the
              stencil buffer contents. The following eight actions are
              possible.

              _?_G_L___K_E_E_P: Keeps the current value.

              _?_G_L___Z_E_R_O: Sets the stencil buffer value to 0.

              _?_G_L___R_E_P_L_A_C_E: Sets the stencil buffer value to _r_e_f, as specified
              by ggll::sstteenncciillFFuunncc//33 .

              _?_G_L___I_N_C_R: Increments the current stencil buffer value. Clamps to
              the maximum representable unsigned value.

              _?_G_L___I_N_C_R___W_R_A_P: Increments the current stencil buffer value.
              Wraps stencil buffer value to zero when incrementing the maximum
              representable unsigned value.

              _?_G_L___D_E_C_R: Decrements the current stencil buffer value. Clamps to
              0.

              _?_G_L___D_E_C_R___W_R_A_P: Decrements the current stencil buffer value.
              Wraps stencil buffer value to the maximum representable unsigned
              value when decrementing a stencil buffer value of zero.

              _?_G_L___I_N_V_E_R_T: Bitwise inverts the current stencil buffer value.

              Stencil buffer values are treated as unsigned integers. When
              incremented and decremented, values are clamped to 0 and 2 n-1,
              where n is the value returned by querying _?_G_L___S_T_E_N_C_I_L___B_I_T_S .

              The other two arguments to _g_l_:_s_t_e_n_c_i_l_O_p_S_e_p_a_r_a_t_e specify stencil
              buffer actions that depend on whether subsequent depth buffer
              tests succeed ( _D_p_p_a_s_s ) or fail ( _D_p_f_a_i_l ) (see ggll::ddeepptthhFFuunncc//11
              ). The actions are specified using the same eight symbolic
              constants as _S_f_a_i_l . Note that _D_p_f_a_i_l is ignored when there is
              no depth buffer, or when the depth buffer is not enabled. In
              these cases, _S_f_a_i_l and _D_p_p_a_s_s specify stencil action when the
              stencil test fails and passes, respectively.

              See external documentation.

       sstteenncciillFFuunnccSSeeppaarraattee((FFaaccee,, FFuunncc,, RReeff,, MMaasskk)) -->> ookk

              Types:

                 Face = enum()
                 Func = enum()
                 Ref = integer()
                 Mask = integer()

              Set front and/or back function and reference value for stencil
              testing

              Stenciling, like depth-buffering, enables and disables drawing
              on a per-pixel basis. You draw into the stencil planes using GL
              drawing primitives, then render geometry and images, using the
              stencil planes to mask out portions of the screen. Stenciling is
              typically used in multipass rendering algorithms to achieve
              special effects, such as decals, outlining, and constructive
              solid geometry rendering.

              The stencil test conditionally eliminates a pixel based on the
              outcome of a comparison between the reference value and the
              value in the stencil buffer. To enable and disable the test,
              call ggll::eennaabbllee//11 and ggll::eennaabbllee//11 with argument _?_G_L___S_T_E_N_C_I_L___T_E_S_T
              . To specify actions based on the outcome of the stencil test,
              call ggll::sstteenncciillOOpp//33 or ggll::sstteenncciillOOppSSeeppaarraattee//44 .

              There can be two separate sets of _F_u_n_c , _R_e_f , and _M_a_s_k
              parameters; one affects back-facing polygons, and the other
              affects front-facing polygons as well as other non-polygon
              primitives. ggll::sstteenncciillFFuunncc//33 sets both front and back stencil
              state to the same values, as if ggll::sstteenncciillFFuunnccSSeeppaarraattee//44 were
              called with _F_a_c_e set to _?_G_L___F_R_O_N_T___A_N_D___B_A_C_K.

              _F_u_n_c is a symbolic constant that determines the stencil
              comparison function. It accepts one of eight values, shown in
              the following list. _R_e_f is an integer reference value that is
              used in the stencil comparison. It is clamped to the range [0 2
              n-1], where n is the number of bitplanes in the stencil buffer.
              _M_a_s_k is bitwise ANDed with both the reference value and the
              stored stencil value, with the ANDed values participating in the
              comparison.

              If _s_t_e_n_c_i_l represents the value stored in the corresponding
              stencil buffer location, the following list shows the effect of
              each comparison function that can be specified by _F_u_n_c . Only if
              the comparison succeeds is the pixel passed through to the next
              stage in the rasterization process (see ggll::sstteenncciillOOpp//33 ). All
              tests treat _s_t_e_n_c_i_l values as unsigned integers in the range [0
              2 n-1], where n is the number of bitplanes in the stencil
              buffer.

              The following values are accepted by _F_u_n_c :

              _?_G_L___N_E_V_E_R: Always fails.

              _?_G_L___L_E_S_S: Passes if ( _R_e_f & _M_a_s_k ) < ( _s_t_e_n_c_i_l & _M_a_s_k ).

              _?_G_L___L_E_Q_U_A_L: Passes if ( _R_e_f & _M_a_s_k ) <= ( _s_t_e_n_c_i_l & _M_a_s_k ).

              _?_G_L___G_R_E_A_T_E_R: Passes if ( _R_e_f & _M_a_s_k ) > ( _s_t_e_n_c_i_l & _M_a_s_k ).

              _?_G_L___G_E_Q_U_A_L: Passes if ( _R_e_f & _M_a_s_k ) >= ( _s_t_e_n_c_i_l & _M_a_s_k ).

              _?_G_L___E_Q_U_A_L: Passes if ( _R_e_f & _M_a_s_k ) = ( _s_t_e_n_c_i_l & _M_a_s_k ).

              _?_G_L___N_O_T_E_Q_U_A_L: Passes if ( _R_e_f & _M_a_s_k ) != ( _s_t_e_n_c_i_l & _M_a_s_k ).

              _?_G_L___A_L_W_A_Y_S: Always passes.

              See external documentation.

       sstteenncciillMMaasskkSSeeppaarraattee((FFaaccee,, MMaasskk)) -->> ookk

              Types:

                 Face = enum()
                 Mask = integer()

              Control the front and/or back writing of individual bits in the
              stencil planes

              _g_l_:_s_t_e_n_c_i_l_M_a_s_k_S_e_p_a_r_a_t_e controls the writing of individual bits
              in the stencil planes. The least significant n bits of _M_a_s_k ,
              where n is the number of bits in the stencil buffer, specify a
              mask. Where a 1 appears in the mask, it's possible to write to
              the corresponding bit in the stencil buffer. Where a 0 appears,
              the corresponding bit is write-protected. Initially, all bits
              are enabled for writing.

              There can be two separate _M_a_s_k writemasks; one affects back-
              facing polygons, and the other affects front-facing polygons as
              well as other non-polygon primitives. ggll::sstteenncciillMMaasskk//11 sets both
              front and back stencil writemasks to the same values, as if
              ggll::sstteenncciillMMaasskkSSeeppaarraattee//22 were called with _F_a_c_e set to
              _?_G_L___F_R_O_N_T___A_N_D___B_A_C_K.

              See external documentation.

       aattttaacchhSShhaaddeerr((PPrrooggrraamm,, SShhaaddeerr)) -->> ookk

              Types:

                 Program = integer()
                 Shader = integer()

              Attaches a shader object to a program object

              In order to create a complete shader program, there must be a
              way to specify the list of things that will be linked together.
              Program objects provide this mechanism. Shaders that are to be
              linked together in a program object must first be attached to
              that program object. _g_l_:_a_t_t_a_c_h_S_h_a_d_e_r attaches the shader object
              specified by _S_h_a_d_e_r to the program object specified by _P_r_o_g_r_a_m .
              This indicates that _S_h_a_d_e_r will be included in link operations
              that will be performed on _P_r_o_g_r_a_m .

              All operations that can be performed on a shader object are
              valid whether or not the shader object is attached to a program
              object. It is permissible to attach a shader object to a program
              object before source code has been loaded into the shader object
              or before the shader object has been compiled. It is permissible
              to attach multiple shader objects of the same type because each
              may contain a portion of the complete shader. It is also
              permissible to attach a shader object to more than one program
              object. If a shader object is deleted while it is attached to a
              program object, it will be flagged for deletion, and deletion
              will not occur until ggll::ddeettaacchhSShhaaddeerr//22 is called to detach it
              from all program objects to which it is attached.

              See external documentation.

       bbiinnddAAttttrriibbLLooccaattiioonn((PPrrooggrraamm,, IInnddeexx,, NNaammee)) -->> ookk

              Types:

                 Program = integer()
                 Index = integer()
                 Name = string()

              Associates a generic vertex attribute index with a named
              attribute variable

              _g_l_:_b_i_n_d_A_t_t_r_i_b_L_o_c_a_t_i_o_n is used to associate a user-defined
              attribute variable in the program object specified by _P_r_o_g_r_a_m
              with a generic vertex attribute index. The name of the user-
              defined attribute variable is passed as a null terminated string
              in _N_a_m_e . The generic vertex attribute index to be bound to this
              variable is specified by _I_n_d_e_x . When _P_r_o_g_r_a_m is made part of
              current state, values provided via the generic vertex attribute
              _I_n_d_e_x will modify the value of the user-defined attribute
              variable specified by _N_a_m_e .

              If _N_a_m_e refers to a matrix attribute variable, _I_n_d_e_x refers to
              the first column of the matrix. Other matrix columns are then
              automatically bound to locations _I_n_d_e_x_+_1 for a matrix of type
              _m_a_t_2; _I_n_d_e_x_+_1 and _I_n_d_e_x_+_2 for a matrix of type _m_a_t_3; and _I_n_d_e_x_+_1
              , _I_n_d_e_x_+_2 , and _I_n_d_e_x_+_3 for a matrix of type _m_a_t_4 .

              This command makes it possible for vertex shaders to use
              descriptive names for attribute variables rather than generic
              variables that are numbered from 0 to _?_G_L___M_A_X___V_E_R_T_E_X___A_T_T_R_I_B_S -1.
              The values sent to each generic attribute index are part of
              current state. If a different program object is made current by
              calling ggll::uusseePPrrooggrraamm//11 , the generic vertex attributes are
              tracked in such a way that the same values will be observed by
              attributes in the new program object that are also bound to
              _I_n_d_e_x .

              Attribute variable name-to-generic attribute index bindings for
              a program object can be explicitly assigned at any time by
              calling _g_l_:_b_i_n_d_A_t_t_r_i_b_L_o_c_a_t_i_o_n. Attribute bindings do not go into
              effect until ggll::lliinnkkPPrrooggrraamm//11 is called. After a program object
              has been linked successfully, the index values for generic
              attributes remain fixed (and their values can be queried) until
              the next link command occurs.

              Any attribute binding that occurs after the program object has
              been linked will not take effect until the next time the program
              object is linked.

              See external documentation.

       ccoommppiilleeSShhaaddeerr((SShhaaddeerr)) -->> ookk

              Types:

                 Shader = integer()

              Compiles a shader object

              _g_l_:_c_o_m_p_i_l_e_S_h_a_d_e_r compiles the source code strings that have been
              stored in the shader object specified by _S_h_a_d_e_r .

              The compilation status will be stored as part of the shader
              object's state. This value will be set to _?_G_L___T_R_U_E if the shader
              was compiled without errors and is ready for use, and _?_G_L___F_A_L_S_E
              otherwise. It can be queried by calling ggll::ggeettSShhaaddeerriivv//22 with
              arguments _S_h_a_d_e_r and _?_G_L___C_O_M_P_I_L_E___S_T_A_T_U_S.

              Compilation of a shader can fail for a number of reasons as
              specified by the OpenGL Shading Language Specification. Whether
              or not the compilation was successful, information about the
              compilation can be obtained from the shader object's information
              log by calling ggll::ggeettSShhaaddeerrIInnffooLLoogg//22 .

              See external documentation.

       ccrreeaatteePPrrooggrraamm(()) -->> iinntteeggeerr(())

              Creates a program object

              _g_l_:_c_r_e_a_t_e_P_r_o_g_r_a_m creates an empty program object and returns a
              non-zero value by which it can be referenced. A program object
              is an object to which shader objects can be attached. This
              provides a mechanism to specify the shader objects that will be
              linked to create a program. It also provides a means for
              checking the compatibility of the shaders that will be used to
              create a program (for instance, checking the compatibility
              between a vertex shader and a fragment shader). When no longer
              needed as part of a program object, shader objects can be
              detached.

              One or more executables are created in a program object by
              successfully attaching shader objects to it with
              ggll::aattttaacchhSShhaaddeerr//22 , successfully compiling the shader objects
              with ggll::ccoommppiilleeSShhaaddeerr//11 , and successfully linking the program
              object with ggll::lliinnkkPPrrooggrraamm//11 . These executables are made part
              of current state when ggll::uusseePPrrooggrraamm//11 is called. Program objects
              can be deleted by calling ggll::ddeelleetteePPrrooggrraamm//11 . The memory
              associated with the program object will be deleted when it is no
              longer part of current rendering state for any context.

              See external documentation.

       ccrreeaatteeSShhaaddeerr((TTyyppee)) -->> iinntteeggeerr(())

              Types:

                 Type = enum()

              Creates a shader object

              _g_l_:_c_r_e_a_t_e_S_h_a_d_e_r creates an empty shader object and returns a
              non-zero value by which it can be referenced. A shader object is
              used to maintain the source code strings that define a shader.
              _S_h_a_d_e_r_T_y_p_e indicates the type of shader to be created. Five
              types of shader are supported. A shader of type
              _?_G_L___V_E_R_T_E_X___S_H_A_D_E_R is a shader that is intended to run on the
              programmable vertex processor. A shader of type
              _?_G_L___T_E_S_S___C_O_N_T_R_O_L___S_H_A_D_E_R is a shader that is intended to run on
              the programmable tessellation processor in the control stage. A
              shader of type _?_G_L___T_E_S_S___E_V_A_L_U_A_T_I_O_N___S_H_A_D_E_R is a shader that is
              intended to run on the programmable tessellation processor in
              the evaluation stage. A shader of type _?_G_L___G_E_O_M_E_T_R_Y___S_H_A_D_E_R is a
              shader that is intended to run on the programmable geometry
              processor. A shader of type _?_G_L___F_R_A_G_M_E_N_T___S_H_A_D_E_R is a shader that
              is intended to run on the programmable fragment processor.

              When created, a shader object's _?_G_L___S_H_A_D_E_R___T_Y_P_E parameter is set
              to either _?_G_L___V_E_R_T_E_X___S_H_A_D_E_R , _?_G_L___T_E_S_S___C_O_N_T_R_O_L___S_H_A_D_E_R,
              _?_G_L___T_E_S_S___E_V_A_L_U_A_T_I_O_N___S_H_A_D_E_R, _?_G_L___G_E_O_M_E_T_R_Y___S_H_A_D_E_R or
              _?_G_L___F_R_A_G_M_E_N_T___S_H_A_D_E_R, depending on the value of _S_h_a_d_e_r_T_y_p_e .

              See external documentation.

       ddeelleetteePPrrooggrraamm((PPrrooggrraamm)) -->> ookk

              Types:

                 Program = integer()

              Deletes a program object

              _g_l_:_d_e_l_e_t_e_P_r_o_g_r_a_m frees the memory and invalidates the name
              associated with the program object specified by _P_r_o_g_r_a_m_. This
              command effectively undoes the effects of a call to
              ggll::ccrreeaatteePPrrooggrraamm//00 .

              If a program object is in use as part of current rendering
              state, it will be flagged for deletion, but it will not be
              deleted until it is no longer part of current state for any
              rendering context. If a program object to be deleted has shader
              objects attached to it, those shader objects will be
              automatically detached but not deleted unless they have already
              been flagged for deletion by a previous call to
              ggll::ddeelleetteeSShhaaddeerr//11 . A value of 0 for _P_r_o_g_r_a_m will be silently
              ignored.

              To determine whether a program object has been flagged for
              deletion, call ggll::ggeettPPrrooggrraammiivv//22 with arguments _P_r_o_g_r_a_m and
              _?_G_L___D_E_L_E_T_E___S_T_A_T_U_S.

              See external documentation.

       ddeelleetteeSShhaaddeerr((SShhaaddeerr)) -->> ookk

              Types:

                 Shader = integer()

              Deletes a shader object

              _g_l_:_d_e_l_e_t_e_S_h_a_d_e_r frees the memory and invalidates the name
              associated with the shader object specified by _S_h_a_d_e_r . This
              command effectively undoes the effects of a call to
              ggll::ccrreeaatteeSShhaaddeerr//11 .

              If a shader object to be deleted is attached to a program
              object, it will be flagged for deletion, but it will not be
              deleted until it is no longer attached to any program object,
              for any rendering context (i.e., it must be detached from
              wherever it was attached before it will be deleted). A value of
              0 for _S_h_a_d_e_r will be silently ignored.

              To determine whether an object has been flagged for deletion,
              call ggll::ggeettSShhaaddeerriivv//22 with arguments _S_h_a_d_e_r and
              _?_G_L___D_E_L_E_T_E___S_T_A_T_U_S.

              See external documentation.

       ddeettaacchhSShhaaddeerr((PPrrooggrraamm,, SShhaaddeerr)) -->> ookk

              Types:

                 Program = integer()
                 Shader = integer()

              Detaches a shader object from a program object to which it is
              attached

              _g_l_:_d_e_t_a_c_h_S_h_a_d_e_r detaches the shader object specified by _S_h_a_d_e_r
              from the program object specified by _P_r_o_g_r_a_m . This command can
              be used to undo the effect of the command ggll::aattttaacchhSShhaaddeerr//22 .

              If _S_h_a_d_e_r has already been flagged for deletion by a call to
              ggll::ddeelleetteeSShhaaddeerr//11 and it is not attached to any other program
              object, it will be deleted after it has been detached.

              See external documentation.

       ddiissaabblleeVVeerrtteexxAAttttrriibbAArrrraayy((IInnddeexx)) -->> ookk

              Types:

                 Index = integer()

              Enable or disable a generic vertex attribute array

              _g_l_:_e_n_a_b_l_e_V_e_r_t_e_x_A_t_t_r_i_b_A_r_r_a_y enables the generic vertex attribute
              array specified by _I_n_d_e_x . _g_l_:_d_i_s_a_b_l_e_V_e_r_t_e_x_A_t_t_r_i_b_A_r_r_a_y disables
              the generic vertex attribute array specified by _I_n_d_e_x . By
              default, all client-side capabilities are disabled, including
              all generic vertex attribute arrays. If enabled, the values in
              the generic vertex attribute array will be accessed and used for
              rendering when calls are made to vertex array commands such as
              ggll::ddrraawwAArrrraayyss//33 , ggll::ddrraawwEElleemmeennttss//44 , ggll::ddrraawwRRaannggeeEElleemmeennttss//66 ,
              see _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s , or ggll::mmuullttiiDDrraawwAArrrraayyss//33 .

              See external documentation.

       eennaabblleeVVeerrtteexxAAttttrriibbAArrrraayy((IInnddeexx)) -->> ookk

              Types:

                 Index = integer()

              See ddiissaabblleeVVeerrtteexxAAttttrriibbAArrrraayy//11

       ggeettAAccttiivveeAAttttrriibb((PPrrooggrraamm,, IInnddeexx,, BBuuffSSiizzee)) -->> {{SSiizzee::::iinntteeggeerr(()),,
       TTyyppee::::eennuumm(()),, NNaammee::::ssttrriinngg(())}}

              Types:

                 Program = integer()
                 Index = integer()
                 BufSize = integer()

              Returns information about an active attribute variable for the
              specified program object

              _g_l_:_g_e_t_A_c_t_i_v_e_A_t_t_r_i_b returns information about an active attribute
              variable in the program object specified by _P_r_o_g_r_a_m . The number
              of active attributes can be obtained by calling
              ggll::ggeettPPrrooggrraammiivv//22 with the value _?_G_L___A_C_T_I_V_E___A_T_T_R_I_B_U_T_E_S. A value
              of 0 for _I_n_d_e_x selects the first active attribute variable.
              Permissible values for _I_n_d_e_x range from 0 to the number of
              active attribute variables minus 1.

              A vertex shader may use either built-in attribute variables,
              user-defined attribute variables, or both. Built-in attribute
              variables have a prefix of "gl_" and reference conventional
              OpenGL vertex attribtes (e.g., _G_l___V_e_r_t_e_x , _G_l___N_o_r_m_a_l , etc., see
              the OpenGL Shading Language specification for a complete list.)
              User-defined attribute variables have arbitrary names and obtain
              their values through numbered generic vertex attributes. An
              attribute variable (either built-in or user-defined) is
              considered active if it is determined during the link operation
              that it may be accessed during program execution. Therefore,
              _P_r_o_g_r_a_m should have previously been the target of a call to
              ggll::lliinnkkPPrrooggrraamm//11 , but it is not necessary for it to have been
              linked successfully.

              The size of the character buffer required to store the longest
              attribute variable name in _P_r_o_g_r_a_m can be obtained by calling
              ggll::ggeettPPrrooggrraammiivv//22 with the value _?_G_L___A_C_T_I_V_E___A_T_T_R_I_B_U_T_E___M_A_X___L_E_N_G_T_H
              . This value should be used to allocate a buffer of sufficient
              size to store the returned attribute name. The size of this
              character buffer is passed in _B_u_f_S_i_z_e , and a pointer to this
              character buffer is passed in _N_a_m_e .

              _g_l_:_g_e_t_A_c_t_i_v_e_A_t_t_r_i_b returns the name of the attribute variable
              indicated by _I_n_d_e_x , storing it in the character buffer
              specified by _N_a_m_e . The string returned will be null terminated.
              The actual number of characters written into this buffer is
              returned in _L_e_n_g_t_h , and this count does not include the null
              termination character. If the length of the returned string is
              not required, a value of _?_N_U_L_L can be passed in the _L_e_n_g_t_h
              argument.

              The _T_y_p_e argument specifies a pointer to a variable into which
              the attribute variable's data type will be written. The symbolic
              constants _?_G_L___F_L_O_A_T, _?_G_L___F_L_O_A_T___V_E_C_2, _?_G_L___F_L_O_A_T___V_E_C_3,
              _?_G_L___F_L_O_A_T___V_E_C_4, _?_G_L___F_L_O_A_T___M_A_T_2, _?_G_L___F_L_O_A_T___M_A_T_3, _?_G_L___F_L_O_A_T___M_A_T_4,
              _?_G_L___F_L_O_A_T___M_A_T_2_x_3, _?_G_L___F_L_O_A_T___M_A_T_2_x_4, _?_G_L___F_L_O_A_T___M_A_T_3_x_2 ,
              _?_G_L___F_L_O_A_T___M_A_T_3_x_4, _?_G_L___F_L_O_A_T___M_A_T_4_x_2, _?_G_L___F_L_O_A_T___M_A_T_4_x_3, _?_G_L___I_N_T ,
              _?_G_L___I_N_T___V_E_C_2, _?_G_L___I_N_T___V_E_C_3, _?_G_L___I_N_T___V_E_C_4, _?_G_L___U_N_S_I_G_N_E_D___I_N_T___V_E_C ,
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___V_E_C_2, _?_G_L___U_N_S_I_G_N_E_D___I_N_T___V_E_C_3,
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___V_E_C_4, _?_D_O_U_B_L_E, _?_D_O_U_B_L_E___V_E_C_2, _?_D_O_U_B_L_E___V_E_C_3,
              _?_D_O_U_B_L_E___V_E_C_4, _?_D_O_U_B_L_E___M_A_T_2 , _?_D_O_U_B_L_E___M_A_T_3, _?_D_O_U_B_L_E___M_A_T_4,
              _?_D_O_U_B_L_E___M_A_T_2_x_3, _?_D_O_U_B_L_E___M_A_T_2_x_4, _?_D_O_U_B_L_E___M_A_T_3_x_2, _?_D_O_U_B_L_E___M_A_T_3_x_4,
              _?_D_O_U_B_L_E___M_A_T_4_x_2, or _?_D_O_U_B_L_E___M_A_T_4_x_3 may be returned. The _S_i_z_e
              argument will return the size of the attribute, in units of the
              type returned in _T_y_p_e .

              The list of active attribute variables may include both built-in
              attribute variables (which begin with the prefix "gl_") as well
              as user-defined attribute variable names.

              This function will return as much information as it can about
              the specified active attribute variable. If no information is
              available, _L_e_n_g_t_h will be 0, and _N_a_m_e will be an empty string.
              This situation could occur if this function is called after a
              link operation that failed. If an error occurs, the return
              values _L_e_n_g_t_h , _S_i_z_e , _T_y_p_e , and _N_a_m_e will be unmodified.

              See external documentation.

       ggeettAAccttiivveeUUnniiffoorrmm((PPrrooggrraamm,, IInnddeexx,, BBuuffSSiizzee)) -->> {{SSiizzee::::iinntteeggeerr(()),,
       TTyyppee::::eennuumm(()),, NNaammee::::ssttrriinngg(())}}

              Types:

                 Program = integer()
                 Index = integer()
                 BufSize = integer()

              Returns information about an active uniform variable for the
              specified program object

              _g_l_:_g_e_t_A_c_t_i_v_e_U_n_i_f_o_r_m returns information about an active uniform
              variable in the program object specified by _P_r_o_g_r_a_m . The number
              of active uniform variables can be obtained by calling
              ggll::ggeettPPrrooggrraammiivv//22 with the value _?_G_L___A_C_T_I_V_E___U_N_I_F_O_R_M_S. A value of
              0 for _I_n_d_e_x selects the first active uniform variable.
              Permissible values for _I_n_d_e_x range from 0 to the number of
              active uniform variables minus 1.

              Shaders may use either built-in uniform variables, user-defined
              uniform variables, or both. Built-in uniform variables have a
              prefix of "gl_" and reference existing OpenGL state or values
              derived from such state (e.g., _G_l___D_e_p_t_h_R_a_n_g_e_P_a_r_a_m_e_t_e_r_s , see the
              OpenGL Shading Language specification for a complete list.)
              User-defined uniform variables have arbitrary names and obtain
              their values from the application through calls to
              ggll::uunniiffoorrmm11ff//22 . A uniform variable (either built-in or user-
              defined) is considered active if it is determined during the
              link operation that it may be accessed during program execution.
              Therefore, _P_r_o_g_r_a_m should have previously been the target of a
              call to ggll::lliinnkkPPrrooggrraamm//11 , but it is not necessary for it to
              have been linked successfully.

              The size of the character buffer required to store the longest
              uniform variable name in _P_r_o_g_r_a_m can be obtained by calling
              ggll::ggeettPPrrooggrraammiivv//22 with the value _?_G_L___A_C_T_I_V_E___U_N_I_F_O_R_M___M_A_X___L_E_N_G_T_H .
              This value should be used to allocate a buffer of sufficient
              size to store the returned uniform variable name. The size of
              this character buffer is passed in _B_u_f_S_i_z_e , and a pointer to
              this character buffer is passed in _N_a_m_e_.

              _g_l_:_g_e_t_A_c_t_i_v_e_U_n_i_f_o_r_m returns the name of the uniform variable
              indicated by _I_n_d_e_x , storing it in the character buffer
              specified by _N_a_m_e . The string returned will be null terminated.
              The actual number of characters written into this buffer is
              returned in _L_e_n_g_t_h , and this count does not include the null
              termination character. If the length of the returned string is
              not required, a value of _?_N_U_L_L can be passed in the _L_e_n_g_t_h
              argument.

              The _T_y_p_e argument will return a pointer to the uniform
              variable's data type. The symbolic constants returned for
              uniform types are shown in the table below._R_e_t_u_r_n_e_d _S_y_m_b_o_l_i_c
              _C_o_n_t_a_n_t_S_h_a_d_e_r _U_n_i_f_o_r_m _T_y_p_e
              _?_G_L___F_L_O_A_T_?_f_l_o_a_t
              _?_G_L___F_L_O_A_T___V_E_C_2_?_v_e_c_2
              _?_G_L___F_L_O_A_T___V_E_C_3_?_v_e_c_3
              _?_G_L___F_L_O_A_T___V_E_C_4_?_v_e_c_4
              _?_G_L___D_O_U_B_L_E_?_d_o_u_b_l_e
              _?_G_L___D_O_U_B_L_E___V_E_C_2_?_d_v_e_c_2
              _?_G_L___D_O_U_B_L_E___V_E_C_3_?_d_v_e_c_3
              _?_G_L___D_O_U_B_L_E___V_E_C_4_?_d_v_e_c_4
              _?_G_L___I_N_T_?_i_n_t
              _?_G_L___I_N_T___V_E_C_2_?_i_v_e_c_2
              _?_G_L___I_N_T___V_E_C_3_?_i_v_e_c_3
              _?_G_L___I_N_T___V_E_C_4_?_i_v_e_c_4
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T_?_u_n_s_i_g_n_e_d _i_n_t
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___V_E_C_2_?_u_v_e_c_2
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___V_E_C_3_?_u_v_e_c_3
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___V_E_C_4_?_u_v_e_c_4
              _?_G_L___B_O_O_L_?_b_o_o_l
              _?_G_L___B_O_O_L___V_E_C_2_?_b_v_e_c_2
              _?_G_L___B_O_O_L___V_E_C_3_?_b_v_e_c_3
              _?_G_L___B_O_O_L___V_E_C_4_?_b_v_e_c_4
              _?_G_L___F_L_O_A_T___M_A_T_2_?_m_a_t_2
              _?_G_L___F_L_O_A_T___M_A_T_3_?_m_a_t_3
              _?_G_L___F_L_O_A_T___M_A_T_4_?_m_a_t_4
              _?_G_L___F_L_O_A_T___M_A_T_2_x_3_?_m_a_t_2_x_3
              _?_G_L___F_L_O_A_T___M_A_T_2_x_4_?_m_a_t_2_x_4
              _?_G_L___F_L_O_A_T___M_A_T_3_x_2_?_m_a_t_3_x_2
              _?_G_L___F_L_O_A_T___M_A_T_3_x_4_?_m_a_t_3_x_4
              _?_G_L___F_L_O_A_T___M_A_T_4_x_2_?_m_a_t_4_x_2
              _?_G_L___F_L_O_A_T___M_A_T_4_x_3_?_m_a_t_4_x_3
              _?_G_L___D_O_U_B_L_E___M_A_T_2_?_d_m_a_t_2
              _?_G_L___D_O_U_B_L_E___M_A_T_3_?_d_m_a_t_3
              _?_G_L___D_O_U_B_L_E___M_A_T_4_?_d_m_a_t_4
              _?_G_L___D_O_U_B_L_E___M_A_T_2_x_3_?_d_m_a_t_2_x_3
              _?_G_L___D_O_U_B_L_E___M_A_T_2_x_4_?_d_m_a_t_2_x_4
              _?_G_L___D_O_U_B_L_E___M_A_T_3_x_2_?_d_m_a_t_3_x_2
              _?_G_L___D_O_U_B_L_E___M_A_T_3_x_4_?_d_m_a_t_3_x_4
              _?_G_L___D_O_U_B_L_E___M_A_T_4_x_2_?_d_m_a_t_4_x_2
              _?_G_L___D_O_U_B_L_E___M_A_T_4_x_3_?_d_m_a_t_4_x_3
              _?_G_L___S_A_M_P_L_E_R___1_D_?_s_a_m_p_l_e_r_1_D
              _?_G_L___S_A_M_P_L_E_R___2_D_?_s_a_m_p_l_e_r_2_D
              _?_G_L___S_A_M_P_L_E_R___3_D_?_s_a_m_p_l_e_r_3_D
              _?_G_L___S_A_M_P_L_E_R___C_U_B_E_?_s_a_m_p_l_e_r_C_u_b_e
              _?_G_L___S_A_M_P_L_E_R___1_D___S_H_A_D_O_W_?_s_a_m_p_l_e_r_1_D_S_h_a_d_o_w
              _?_G_L___S_A_M_P_L_E_R___2_D___S_H_A_D_O_W_?_s_a_m_p_l_e_r_2_D_S_h_a_d_o_w
              _?_G_L___S_A_M_P_L_E_R___1_D___A_R_R_A_Y_?_s_a_m_p_l_e_r_1_D_A_r_r_a_y
              _?_G_L___S_A_M_P_L_E_R___2_D___A_R_R_A_Y_?_s_a_m_p_l_e_r_2_D_A_r_r_a_y
              _?_G_L___S_A_M_P_L_E_R___1_D___A_R_R_A_Y___S_H_A_D_O_W_?_s_a_m_p_l_e_r_1_D_A_r_r_a_y_S_h_a_d_o_w
              _?_G_L___S_A_M_P_L_E_R___2_D___A_R_R_A_Y___S_H_A_D_O_W_?_s_a_m_p_l_e_r_2_D_A_r_r_a_y_S_h_a_d_o_w
              _?_G_L___S_A_M_P_L_E_R___2_D___M_U_L_T_I_S_A_M_P_L_E_?_s_a_m_p_l_e_r_2_D_M_S
              _?_G_L___S_A_M_P_L_E_R___2_D___M_U_L_T_I_S_A_M_P_L_E___A_R_R_A_Y_?_s_a_m_p_l_e_r_2_D_M_S_A_r_r_a_y
              _?_G_L___S_A_M_P_L_E_R___C_U_B_E___S_H_A_D_O_W_?_s_a_m_p_l_e_r_C_u_b_e_S_h_a_d_o_w
              _?_G_L___S_A_M_P_L_E_R___B_U_F_F_E_R_?_s_a_m_p_l_e_r_B_u_f_f_e_r
              _?_G_L___S_A_M_P_L_E_R___2_D___R_E_C_T_?_s_a_m_p_l_e_r_2_D_R_e_c_t
              _?_G_L___S_A_M_P_L_E_R___2_D___R_E_C_T___S_H_A_D_O_W_?_s_a_m_p_l_e_r_2_D_R_e_c_t_S_h_a_d_o_w
              _?_G_L___I_N_T___S_A_M_P_L_E_R___1_D_?_i_s_a_m_p_l_e_r_1_D
              _?_G_L___I_N_T___S_A_M_P_L_E_R___2_D_?_i_s_a_m_p_l_e_r_2_D
              _?_G_L___I_N_T___S_A_M_P_L_E_R___3_D_?_i_s_a_m_p_l_e_r_3_D
              _?_G_L___I_N_T___S_A_M_P_L_E_R___C_U_B_E_?_i_s_a_m_p_l_e_r_C_u_b_e
              _?_G_L___I_N_T___S_A_M_P_L_E_R___1_D___A_R_R_A_Y_?_i_s_a_m_p_l_e_r_1_D_A_r_r_a_y
              _?_G_L___I_N_T___S_A_M_P_L_E_R___2_D___A_R_R_A_Y_?_i_s_a_m_p_l_e_r_2_D_A_r_r_a_y
              _?_G_L___I_N_T___S_A_M_P_L_E_R___2_D___M_U_L_T_I_S_A_M_P_L_E_?_i_s_a_m_p_l_e_r_2_D_M_S
              _?_G_L___I_N_T___S_A_M_P_L_E_R___2_D___M_U_L_T_I_S_A_M_P_L_E___A_R_R_A_Y_?_i_s_a_m_p_l_e_r_2_D_M_S_A_r_r_a_y
              _?_G_L___I_N_T___S_A_M_P_L_E_R___B_U_F_F_E_R_?_i_s_a_m_p_l_e_r_B_u_f_f_e_r
              _?_G_L___I_N_T___S_A_M_P_L_E_R___2_D___R_E_C_T_?_i_s_a_m_p_l_e_r_2_D_R_e_c_t
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___S_A_M_P_L_E_R___1_D_?_u_s_a_m_p_l_e_r_1_D
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___S_A_M_P_L_E_R___2_D_?_u_s_a_m_p_l_e_r_2_D
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___S_A_M_P_L_E_R___3_D_?_u_s_a_m_p_l_e_r_3_D
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___S_A_M_P_L_E_R___C_U_B_E_?_u_s_a_m_p_l_e_r_C_u_b_e
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___S_A_M_P_L_E_R___1_D___A_R_R_A_Y_?_u_s_a_m_p_l_e_r_2_D_A_r_r_a_y
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___S_A_M_P_L_E_R___2_D___A_R_R_A_Y_?_u_s_a_m_p_l_e_r_2_D_A_r_r_a_y
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___S_A_M_P_L_E_R___2_D___M_U_L_T_I_S_A_M_P_L_E_?_u_s_a_m_p_l_e_r_2_D_M_S
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___S_A_M_P_L_E_R___2_D___M_U_L_T_I_S_A_M_P_L_E___A_R_R_A_Y_?_u_s_a_m_p_l_e_r_2_D_M_S_A_r_r_a_y
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___S_A_M_P_L_E_R___B_U_F_F_E_R_?_u_s_a_m_p_l_e_r_B_u_f_f_e_r
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___S_A_M_P_L_E_R___2_D___R_E_C_T_?_u_s_a_m_p_l_e_r_2_D_R_e_c_t
              _?_G_L___I_M_A_G_E___1_D_?_i_m_a_g_e_1_D
              _?_G_L___I_M_A_G_E___2_D_?_i_m_a_g_e_2_D
              _?_G_L___I_M_A_G_E___3_D_?_i_m_a_g_e_3_D
              _?_G_L___I_M_A_G_E___2_D___R_E_C_T_?_i_m_a_g_e_2_D_R_e_c_t
              _?_G_L___I_M_A_G_E___C_U_B_E_?_i_m_a_g_e_C_u_b_e
              _?_G_L___I_M_A_G_E___B_U_F_F_E_R_?_i_m_a_g_e_B_u_f_f_e_r
              _?_G_L___I_M_A_G_E___1_D___A_R_R_A_Y_?_i_m_a_g_e_1_D_A_r_r_a_y
              _?_G_L___I_M_A_G_E___2_D___A_R_R_A_Y_?_i_m_a_g_e_2_D_A_r_r_a_y
              _?_G_L___I_M_A_G_E___2_D___M_U_L_T_I_S_A_M_P_L_E_?_i_m_a_g_e_2_D_M_S
              _?_G_L___I_M_A_G_E___2_D___M_U_L_T_I_S_A_M_P_L_E___A_R_R_A_Y_?_i_m_a_g_e_2_D_M_S_A_r_r_a_y
              _?_G_L___I_N_T___I_M_A_G_E___1_D_?_i_i_m_a_g_e_1_D
              _?_G_L___I_N_T___I_M_A_G_E___2_D_?_i_i_m_a_g_e_2_D
              _?_G_L___I_N_T___I_M_A_G_E___3_D_?_i_i_m_a_g_e_3_D
              _?_G_L___I_N_T___I_M_A_G_E___2_D___R_E_C_T_?_i_i_m_a_g_e_2_D_R_e_c_t
              _?_G_L___I_N_T___I_M_A_G_E___C_U_B_E_?_i_i_m_a_g_e_C_u_b_e
              _?_G_L___I_N_T___I_M_A_G_E___B_U_F_F_E_R_?_i_i_m_a_g_e_B_u_f_f_e_r
              _?_G_L___I_N_T___I_M_A_G_E___1_D___A_R_R_A_Y_?_i_i_m_a_g_e_1_D_A_r_r_a_y
              _?_G_L___I_N_T___I_M_A_G_E___2_D___A_R_R_A_Y_?_i_i_m_a_g_e_2_D_A_r_r_a_y
              _?_G_L___I_N_T___I_M_A_G_E___2_D___M_U_L_T_I_S_A_M_P_L_E_?_i_i_m_a_g_e_2_D_M_S
              _?_G_L___I_N_T___I_M_A_G_E___2_D___M_U_L_T_I_S_A_M_P_L_E___A_R_R_A_Y_?_i_i_m_a_g_e_2_D_M_S_A_r_r_a_y
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___I_M_A_G_E___1_D_?_u_i_m_a_g_e_1_D
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___I_M_A_G_E___2_D_?_u_i_m_a_g_e_2_D
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___I_M_A_G_E___3_D_?_u_i_m_a_g_e_3_D
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___I_M_A_G_E___2_D___R_E_C_T_?_u_i_m_a_g_e_2_D_R_e_c_t
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___I_M_A_G_E___C_U_B_E_?_u_i_m_a_g_e_C_u_b_e
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___I_M_A_G_E___B_U_F_F_E_R_?_u_i_m_a_g_e_B_u_f_f_e_r
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___I_M_A_G_E___1_D___A_R_R_A_Y_?_u_i_m_a_g_e_1_D_A_r_r_a_y
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___I_M_A_G_E___2_D___A_R_R_A_Y_?_u_i_m_a_g_e_2_D_A_r_r_a_y
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___I_M_A_G_E___2_D___M_U_L_T_I_S_A_M_P_L_E_?_u_i_m_a_g_e_2_D_M_S
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___I_M_A_G_E___2_D___M_U_L_T_I_S_A_M_P_L_E___A_R_R_A_Y_?_u_i_m_a_g_e_2_D_M_S_A_r_r_a_y
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T___A_T_O_M_I_C___C_O_U_N_T_E_R_?_a_t_o_m_i_c___u_i_n_t


              If one or more elements of an array are active, the name of the
              array is returned in _N_a_m_e , the type is returned in _T_y_p_e , and
              the _S_i_z_e parameter returns the highest array element index used,
              plus one, as determined by the compiler and/or linker. Only one
              active uniform variable will be reported for a uniform array.

              Uniform variables that are declared as structures or arrays of
              structures will not be returned directly by this function.
              Instead, each of these uniform variables will be reduced to its
              fundamental components containing the "." and "[]" operators
              such that each of the names is valid as an argument to
              ggll::ggeettUUnniiffoorrmmLLooccaattiioonn//22 . Each of these reduced uniform
              variables is counted as one active uniform variable and is
              assigned an index. A valid name cannot be a structure, an array
              of structures, or a subcomponent of a vector or matrix.

              The size of the uniform variable will be returned in _S_i_z_e .
              Uniform variables other than arrays will have a size of 1.
              Structures and arrays of structures will be reduced as described
              earlier, such that each of the names returned will be a data
              type in the earlier list. If this reduction results in an array,
              the size returned will be as described for uniform arrays;
              otherwise, the size returned will be 1.

              The list of active uniform variables may include both built-in
              uniform variables (which begin with the prefix "gl_") as well as
              user-defined uniform variable names.

              This function will return as much information as it can about
              the specified active uniform variable. If no information is
              available, _L_e_n_g_t_h will be 0, and _N_a_m_e will be an empty string.
              This situation could occur if this function is called after a
              link operation that failed. If an error occurs, the return
              values _L_e_n_g_t_h , _S_i_z_e , _T_y_p_e , and _N_a_m_e will be unmodified.

              See external documentation.

       ggeettAAttttaacchheeddSShhaaddeerrss((PPrrooggrraamm,, MMaaxxCCoouunntt)) -->> [[iinntteeggeerr(())]]

              Types:

                 Program = integer()
                 MaxCount = integer()

              Returns the handles of the shader objects attached to a program
              object

              _g_l_:_g_e_t_A_t_t_a_c_h_e_d_S_h_a_d_e_r_s returns the names of the shader objects
              attached to _P_r_o_g_r_a_m . The names of shader objects that are
              attached to _P_r_o_g_r_a_m will be returned in _S_h_a_d_e_r_s_. The actual
              number of shader names written into _S_h_a_d_e_r_s is returned in
              _C_o_u_n_t_. If no shader objects are attached to _P_r_o_g_r_a_m , _C_o_u_n_t is
              set to 0. The maximum number of shader names that may be
              returned in _S_h_a_d_e_r_s is specified by _M_a_x_C_o_u_n_t .

              If the number of names actually returned is not required (for
              instance, if it has just been obtained by calling
              ggll::ggeettPPrrooggrraammiivv//22 ), a value of _?_N_U_L_L may be passed for count.
              If no shader objects are attached to _P_r_o_g_r_a_m , a value of 0 will
              be returned in _C_o_u_n_t . The actual number of attached shaders can
              be obtained by calling ggll::ggeettPPrrooggrraammiivv//22 with the value
              _?_G_L___A_T_T_A_C_H_E_D___S_H_A_D_E_R_S.

              See external documentation.

       ggeettAAttttrriibbLLooccaattiioonn((PPrrooggrraamm,, NNaammee)) -->> iinntteeggeerr(())

              Types:

                 Program = integer()
                 Name = string()

              Returns the location of an attribute variable

              _g_l_:_g_e_t_A_t_t_r_i_b_L_o_c_a_t_i_o_n queries the previously linked program
              object specified by _P_r_o_g_r_a_m for the attribute variable specified
              by _N_a_m_e and returns the index of the generic vertex attribute
              that is bound to that attribute variable. If _N_a_m_e is a matrix
              attribute variable, the index of the first column of the matrix
              is returned. If the named attribute variable is not an active
              attribute in the specified program object or if _N_a_m_e starts with
              the reserved prefix "gl_", a value of -1 is returned.

              The association between an attribute variable name and a generic
              attribute index can be specified at any time by calling
              ggll::bbiinnddAAttttrriibbLLooccaattiioonn//33 . Attribute bindings do not go into
              effect until ggll::lliinnkkPPrrooggrraamm//11 is called. After a program object
              has been linked successfully, the index values for attribute
              variables remain fixed until the next link command occurs. The
              attribute values can only be queried after a link if the link
              was successful. _g_l_:_g_e_t_A_t_t_r_i_b_L_o_c_a_t_i_o_n returns the binding that
              actually went into effect the last time ggll::lliinnkkPPrrooggrraamm//11 was
              called for the specified program object. Attribute bindings that
              have been specified since the last link operation are not
              returned by _g_l_:_g_e_t_A_t_t_r_i_b_L_o_c_a_t_i_o_n.

              See external documentation.

       ggeettPPrrooggrraammiivv((PPrrooggrraamm,, PPnnaammee)) -->> iinntteeggeerr(())

              Types:

                 Program = integer()
                 Pname = enum()

              Returns a parameter from a program object

              _g_l_:_g_e_t_P_r_o_g_r_a_m returns in _P_a_r_a_m_s the value of a parameter for a
              specific program object. The following parameters are defined:

              _?_G_L___D_E_L_E_T_E___S_T_A_T_U_S: _P_a_r_a_m_s returns _?_G_L___T_R_U_E if _P_r_o_g_r_a_m is
              currently flagged for deletion, and _?_G_L___F_A_L_S_E otherwise.

              _?_G_L___L_I_N_K___S_T_A_T_U_S: _P_a_r_a_m_s returns _?_G_L___T_R_U_E if the last link
              operation on _P_r_o_g_r_a_m was successful, and _?_G_L___F_A_L_S_E otherwise.

              _?_G_L___V_A_L_I_D_A_T_E___S_T_A_T_U_S: _P_a_r_a_m_s returns _?_G_L___T_R_U_E or if the last
              validation operation on _P_r_o_g_r_a_m was successful, and _?_G_L___F_A_L_S_E
              otherwise.

              _?_G_L___I_N_F_O___L_O_G___L_E_N_G_T_H: _P_a_r_a_m_s returns the number of characters in
              the information log for _P_r_o_g_r_a_m including the null termination
              character (i.e., the size of the character buffer required to
              store the information log). If _P_r_o_g_r_a_m has no information log, a
              value of 0 is returned.

              _?_G_L___A_T_T_A_C_H_E_D___S_H_A_D_E_R_S: _P_a_r_a_m_s returns the number of shader
              objects attached to _P_r_o_g_r_a_m .

              _?_G_L___A_C_T_I_V_E___A_T_O_M_I_C___C_O_U_N_T_E_R___B_U_F_F_E_R_S: _P_a_r_a_m_s returns the number of
              active attribute atomic counter buffers used by _P_r_o_g_r_a_m .

              _?_G_L___A_C_T_I_V_E___A_T_T_R_I_B_U_T_E_S: _P_a_r_a_m_s returns the number of active
              attribute variables for _P_r_o_g_r_a_m .

              _?_G_L___A_C_T_I_V_E___A_T_T_R_I_B_U_T_E___M_A_X___L_E_N_G_T_H: _P_a_r_a_m_s returns the length of
              the longest active attribute name for _P_r_o_g_r_a_m , including the
              null termination character (i.e., the size of the character
              buffer required to store the longest attribute name). If no
              active attributes exist, 0 is returned.

              _?_G_L___A_C_T_I_V_E___U_N_I_F_O_R_M_S: _P_a_r_a_m_s returns the number of active uniform
              variables for _P_r_o_g_r_a_m .

              _?_G_L___A_C_T_I_V_E___U_N_I_F_O_R_M___M_A_X___L_E_N_G_T_H: _P_a_r_a_m_s returns the length of the
              longest active uniform variable name for _P_r_o_g_r_a_m , including the
              null termination character (i.e., the size of the character
              buffer required to store the longest uniform variable name). If
              no active uniform variables exist, 0 is returned.

              _?_G_L___P_R_O_G_R_A_M___B_I_N_A_R_Y___L_E_N_G_T_H: _P_a_r_a_m_s returns the length of the
              program binary, in bytes that will be returned by a call to
              ggll::ggeettPPrrooggrraammBBiinnaarryy//22 . When a progam's _?_G_L___L_I_N_K___S_T_A_T_U_S is
              _?_G_L___F_A_L_S_E, its program binary length is zero.

              _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___B_U_F_F_E_R___M_O_D_E: _P_a_r_a_m_s returns a symbolic
              constant indicating the buffer mode used when transform feedback
              is active. This may be _?_G_L___S_E_P_A_R_A_T_E___A_T_T_R_I_B_S or
              _?_G_L___I_N_T_E_R_L_E_A_V_E_D___A_T_T_R_I_B_S.

              _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___V_A_R_Y_I_N_G_S: _P_a_r_a_m_s returns the number of
              varying variables to capture in transform feedback mode for the
              program.

              _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___V_A_R_Y_I_N_G___M_A_X___L_E_N_G_T_H: _P_a_r_a_m_s returns the
              length of the longest variable name to be used for transform
              feedback, including the null-terminator.

              _?_G_L___G_E_O_M_E_T_R_Y___V_E_R_T_I_C_E_S___O_U_T: _P_a_r_a_m_s returns the maximum number of
              vertices that the geometry shader in _P_r_o_g_r_a_m will output.

              _?_G_L___G_E_O_M_E_T_R_Y___I_N_P_U_T___T_Y_P_E: _P_a_r_a_m_s returns a symbolic constant
              indicating the primitive type accepted as input to the geometry
              shader contained in _P_r_o_g_r_a_m .

              _?_G_L___G_E_O_M_E_T_R_Y___O_U_T_P_U_T___T_Y_P_E: _P_a_r_a_m_s returns a symbolic constant
              indicating the primitive type that will be output by the
              geometry shader contained in _P_r_o_g_r_a_m .

              See external documentation.

       ggeettPPrrooggrraammIInnffooLLoogg((PPrrooggrraamm,, BBuuffSSiizzee)) -->> ssttrriinngg(())

              Types:

                 Program = integer()
                 BufSize = integer()

              Returns the information log for a program object

              _g_l_:_g_e_t_P_r_o_g_r_a_m_I_n_f_o_L_o_g returns the information log for the
              specified program object. The information log for a program
              object is modified when the program object is linked or
              validated. The string that is returned will be null terminated.

              _g_l_:_g_e_t_P_r_o_g_r_a_m_I_n_f_o_L_o_g returns in _I_n_f_o_L_o_g as much of the
              information log as it can, up to a maximum of _M_a_x_L_e_n_g_t_h
              characters. The number of characters actually returned,
              excluding the null termination character, is specified by _L_e_n_g_t_h
              . If the length of the returned string is not required, a value
              of _?_N_U_L_L can be passed in the _L_e_n_g_t_h argument. The size of the
              buffer required to store the returned information log can be
              obtained by calling ggll::ggeettPPrrooggrraammiivv//22 with the value
              _?_G_L___I_N_F_O___L_O_G___L_E_N_G_T_H .

              The information log for a program object is either an empty
              string, or a string containing information about the last link
              operation, or a string containing information about the last
              validation operation. It may contain diagnostic messages,
              warning messages, and other information. When a program object
              is created, its information log will be a string of length 0.

              See external documentation.

       ggeettSShhaaddeerriivv((SShhaaddeerr,, PPnnaammee)) -->> iinntteeggeerr(())

              Types:

                 Shader = integer()
                 Pname = enum()

              Returns a parameter from a shader object

              _g_l_:_g_e_t_S_h_a_d_e_r returns in _P_a_r_a_m_s the value of a parameter for a
              specific shader object. The following parameters are defined:

              _?_G_L___S_H_A_D_E_R___T_Y_P_E: _P_a_r_a_m_s returns _?_G_L___V_E_R_T_E_X___S_H_A_D_E_R if _S_h_a_d_e_r is a
              vertex shader object, _?_G_L___G_E_O_M_E_T_R_Y___S_H_A_D_E_R if _S_h_a_d_e_r is a
              geometry shader object, and _?_G_L___F_R_A_G_M_E_N_T___S_H_A_D_E_R if _S_h_a_d_e_r is a
              fragment shader object.

              _?_G_L___D_E_L_E_T_E___S_T_A_T_U_S: _P_a_r_a_m_s returns _?_G_L___T_R_U_E if _S_h_a_d_e_r is
              currently flagged for deletion, and _?_G_L___F_A_L_S_E otherwise.

              _?_G_L___C_O_M_P_I_L_E___S_T_A_T_U_S: _P_a_r_a_m_s returns _?_G_L___T_R_U_E if the last compile
              operation on _S_h_a_d_e_r was successful, and _?_G_L___F_A_L_S_E otherwise.

              _?_G_L___I_N_F_O___L_O_G___L_E_N_G_T_H: _P_a_r_a_m_s returns the number of characters in
              the information log for _S_h_a_d_e_r including the null termination
              character (i.e., the size of the character buffer required to
              store the information log). If _S_h_a_d_e_r has no information log, a
              value of 0 is returned.

              _?_G_L___S_H_A_D_E_R___S_O_U_R_C_E___L_E_N_G_T_H: _P_a_r_a_m_s returns the length of the
              concatenation of the source strings that make up the shader
              source for the _S_h_a_d_e_r , including the null termination
              character. (i.e., the size of the character buffer required to
              store the shader source). If no source code exists, 0 is
              returned.

              See external documentation.

       ggeettSShhaaddeerrIInnffooLLoogg((SShhaaddeerr,, BBuuffSSiizzee)) -->> ssttrriinngg(())

              Types:

                 Shader = integer()
                 BufSize = integer()

              Returns the information log for a shader object

              _g_l_:_g_e_t_S_h_a_d_e_r_I_n_f_o_L_o_g returns the information log for the
              specified shader object. The information log for a shader object
              is modified when the shader is compiled. The string that is
              returned will be null terminated.

              _g_l_:_g_e_t_S_h_a_d_e_r_I_n_f_o_L_o_g returns in _I_n_f_o_L_o_g as much of the
              information log as it can, up to a maximum of _M_a_x_L_e_n_g_t_h
              characters. The number of characters actually returned,
              excluding the null termination character, is specified by _L_e_n_g_t_h
              . If the length of the returned string is not required, a value
              of _?_N_U_L_L can be passed in the _L_e_n_g_t_h argument. The size of the
              buffer required to store the returned information log can be
              obtained by calling ggll::ggeettSShhaaddeerriivv//22 with the value
              _?_G_L___I_N_F_O___L_O_G___L_E_N_G_T_H .

              The information log for a shader object is a string that may
              contain diagnostic messages, warning messages, and other
              information about the last compile operation. When a shader
              object is created, its information log will be a string of
              length 0.

              See external documentation.

       ggeettSShhaaddeerrSSoouurrccee((SShhaaddeerr,, BBuuffSSiizzee)) -->> ssttrriinngg(())

              Types:

                 Shader = integer()
                 BufSize = integer()

              Returns the source code string from a shader object

              _g_l_:_g_e_t_S_h_a_d_e_r_S_o_u_r_c_e returns the concatenation of the source code
              strings from the shader object specified by _S_h_a_d_e_r . The source
              code strings for a shader object are the result of a previous
              call to ggll::sshhaaddeerrSSoouurrccee//22 . The string returned by the function
              will be null terminated.

              _g_l_:_g_e_t_S_h_a_d_e_r_S_o_u_r_c_e returns in _S_o_u_r_c_e as much of the source code
              string as it can, up to a maximum of _B_u_f_S_i_z_e characters. The
              number of characters actually returned, excluding the null
              termination character, is specified by _L_e_n_g_t_h . If the length of
              the returned string is not required, a value of _?_N_U_L_L can be
              passed in the _L_e_n_g_t_h argument. The size of the buffer required
              to store the returned source code string can be obtained by
              calling ggll::ggeettSShhaaddeerriivv//22 with the value _?_G_L___S_H_A_D_E_R___S_O_U_R_C_E___L_E_N_G_T_H
              .

              See external documentation.

       ggeettUUnniiffoorrmmLLooccaattiioonn((PPrrooggrraamm,, NNaammee)) -->> iinntteeggeerr(())

              Types:

                 Program = integer()
                 Name = string()

              Returns the location of a uniform variable

              _g_l_:_g_e_t_U_n_i_f_o_r_m_L_o_c_a_t_i_o_n returns an integer that represents the
              location of a specific uniform variable within a program object.
              _N_a_m_e must be a null terminated string that contains no white
              space. _N_a_m_e must be an active uniform variable name in _P_r_o_g_r_a_m
              that is not a structure, an array of structures, or a
              subcomponent of a vector or a matrix. This function returns -1
              if _N_a_m_e does not correspond to an active uniform variable in
              _P_r_o_g_r_a_m , if _N_a_m_e starts with the reserved prefix "gl_", or if
              _N_a_m_e is associated with an atomic counter or a named uniform
              block.

              Uniform variables that are structures or arrays of structures
              may be queried by calling _g_l_:_g_e_t_U_n_i_f_o_r_m_L_o_c_a_t_i_o_n for each field
              within the structure. The array element operator "[]" and the
              structure field operator "." may be used in _N_a_m_e in order to
              select elements within an array or fields within a structure.
              The result of using these operators is not allowed to be another
              structure, an array of structures, or a subcomponent of a vector
              or a matrix. Except if the last part of _N_a_m_e indicates a uniform
              variable array, the location of the first element of an array
              can be retrieved by using the name of the array, or by using the
              name appended by "[0]".

              The actual locations assigned to uniform variables are not known
              until the program object is linked successfully. After linking
              has occurred, the command _g_l_:_g_e_t_U_n_i_f_o_r_m_L_o_c_a_t_i_o_n can be used to
              obtain the location of a uniform variable. This location value
              can then be passed to ggll::uunniiffoorrmm11ff//22 to set the value of the
              uniform variable or to ggll::ggeettUUnniiffoorrmmffvv//22 in order to query the
              current value of the uniform variable. After a program object
              has been linked successfully, the index values for uniform
              variables remain fixed until the next link command occurs.
              Uniform variable locations and values can only be queried after
              a link if the link was successful.

              See external documentation.

       ggeettUUnniiffoorrmmffvv((PPrrooggrraamm,, LLooccaattiioonn)) -->> mmaattrriixx(())

              Types:

                 Program = integer()
                 Location = integer()

              Returns the value of a uniform variable

              _g_l_:_g_e_t_U_n_i_f_o_r_m returns in _P_a_r_a_m_s the value(s) of the specified
              uniform variable. The type of the uniform variable specified by
              _L_o_c_a_t_i_o_n determines the number of values returned. If the
              uniform variable is defined in the shader as a boolean, int, or
              float, a single value will be returned. If it is defined as a
              vec2, ivec2, or bvec2, two values will be returned. If it is
              defined as a vec3, ivec3, or bvec3, three values will be
              returned, and so on. To query values stored in uniform variables
              declared as arrays, call _g_l_:_g_e_t_U_n_i_f_o_r_m for each element of the
              array. To query values stored in uniform variables declared as
              structures, call _g_l_:_g_e_t_U_n_i_f_o_r_m for each field in the structure.
              The values for uniform variables declared as a matrix will be
              returned in column major order.

              The locations assigned to uniform variables are not known until
              the program object is linked. After linking has occurred, the
              command ggll::ggeettUUnniiffoorrmmLLooccaattiioonn//22 can be used to obtain the
              location of a uniform variable. This location value can then be
              passed to _g_l_:_g_e_t_U_n_i_f_o_r_m in order to query the current value of
              the uniform variable. After a program object has been linked
              successfully, the index values for uniform variables remain
              fixed until the next link command occurs. The uniform variable
              values can only be queried after a link if the link was
              successful.

              See external documentation.

       ggeettUUnniiffoorrmmiivv((PPrrooggrraamm,, LLooccaattiioonn)) -->> {{iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(())}}

              Types:

                 Program = integer()
                 Location = integer()

              See ggeettUUnniiffoorrmmffvv//22

       ggeettVVeerrtteexxAAttttrriibbddvv((IInnddeexx,, PPnnaammee)) -->> {{ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(())}}

              Types:

                 Index = integer()
                 Pname = enum()

              Return a generic vertex attribute parameter

              _g_l_:_g_e_t_V_e_r_t_e_x_A_t_t_r_i_b returns in _P_a_r_a_m_s the value of a generic
              vertex attribute parameter. The generic vertex attribute to be
              queried is specified by _I_n_d_e_x , and the parameter to be queried
              is specified by _P_n_a_m_e .

              The accepted parameter names are as follows:

              _?_G_L___V_E_R_T_E_X___A_T_T_R_I_B___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G: _P_a_r_a_m_s returns a single
              value, the name of the buffer object currently bound to the
              binding point corresponding to generic vertex attribute array
              _I_n_d_e_x . If no buffer object is bound, 0 is returned. The initial
              value is 0.

              _?_G_L___V_E_R_T_E_X___A_T_T_R_I_B___A_R_R_A_Y___E_N_A_B_L_E_D: _P_a_r_a_m_s returns a single value
              that is non-zero (true) if the vertex attribute array for _I_n_d_e_x
              is enabled and 0 (false) if it is disabled. The initial value is
              _?_G_L___F_A_L_S_E.

              _?_G_L___V_E_R_T_E_X___A_T_T_R_I_B___A_R_R_A_Y___S_I_Z_E: _P_a_r_a_m_s returns a single value, the
              size of the vertex attribute array for _I_n_d_e_x . The size is the
              number of values for each element of the vertex attribute array,
              and it will be 1, 2, 3, or 4. The initial value is 4.

              _?_G_L___V_E_R_T_E_X___A_T_T_R_I_B___A_R_R_A_Y___S_T_R_I_D_E: _P_a_r_a_m_s returns a single value,
              the array stride for (number of bytes between successive
              elements in) the vertex attribute array for _I_n_d_e_x . A value of 0
              indicates that the array elements are stored sequentially in
              memory. The initial value is 0.

              _?_G_L___V_E_R_T_E_X___A_T_T_R_I_B___A_R_R_A_Y___T_Y_P_E: _P_a_r_a_m_s returns a single value, a
              symbolic constant indicating the array type for the vertex
              attribute array for _I_n_d_e_x . Possible values are _?_G_L___B_Y_T_E,
              _?_G_L___U_N_S_I_G_N_E_D___B_Y_T_E, _?_G_L___S_H_O_R_T, _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T , _?_G_L___I_N_T,
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T, _?_G_L___F_L_O_A_T, and _?_G_L___D_O_U_B_L_E. The initial value
              is _?_G_L___F_L_O_A_T.

              _?_G_L___V_E_R_T_E_X___A_T_T_R_I_B___A_R_R_A_Y___N_O_R_M_A_L_I_Z_E_D: _P_a_r_a_m_s returns a single
              value that is non-zero (true) if fixed-point data types for the
              vertex attribute array indicated by _I_n_d_e_x are normalized when
              they are converted to floating point, and 0 (false) otherwise.
              The initial value is _?_G_L___F_A_L_S_E.

              _?_G_L___V_E_R_T_E_X___A_T_T_R_I_B___A_R_R_A_Y___I_N_T_E_G_E_R: _P_a_r_a_m_s returns a single value
              that is non-zero (true) if fixed-point data types for the vertex
              attribute array indicated by _I_n_d_e_x have integer data types, and
              0 (false) otherwise. The initial value is 0 (_?_G_L___F_A_L_S_E).

              _?_G_L___V_E_R_T_E_X___A_T_T_R_I_B___A_R_R_A_Y___D_I_V_I_S_O_R: _P_a_r_a_m_s returns a single value
              that is the frequency divisor used for instanced rendering. See
              ggll::vveerrtteexxAAttttrriibbDDiivviissoorr//22 . The initial value is 0.

              _?_G_L___C_U_R_R_E_N_T___V_E_R_T_E_X___A_T_T_R_I_B: _P_a_r_a_m_s returns four values that
              represent the current value for the generic vertex attribute
              specified by index. Generic vertex attribute 0 is unique in that
              it has no current state, so an error will be generated if _I_n_d_e_x
              is 0. The initial value for all other generic vertex attributes
              is (0,0,0,1).

              _g_l_:_g_e_t_V_e_r_t_e_x_A_t_t_r_i_b_d_v and _g_l_:_g_e_t_V_e_r_t_e_x_A_t_t_r_i_b_f_v return the current
              attribute values as four single-precision floating-point values;
              _g_l_:_g_e_t_V_e_r_t_e_x_A_t_t_r_i_b_i_v reads them as floating-point values and
              converts them to four integer values; _g_l_:_g_e_t_V_e_r_t_e_x_A_t_t_r_i_b_I_i_v and
              _g_l_:_g_e_t_V_e_r_t_e_x_A_t_t_r_i_b_I_u_i_v read and return them as signed or
              unsigned integer values, respectively; _g_l_:_g_e_t_V_e_r_t_e_x_A_t_t_r_i_b_L_d_v
              reads and returns them as four double-precision floating-point
              values.

              All of the parameters except _?_G_L___C_U_R_R_E_N_T___V_E_R_T_E_X___A_T_T_R_I_B represent
              state stored in the currently bound vertex array object.

              See external documentation.

       ggeettVVeerrtteexxAAttttrriibbffvv((IInnddeexx,, PPnnaammee)) -->> {{ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(())}}

              Types:

                 Index = integer()
                 Pname = enum()

              See ggeettVVeerrtteexxAAttttrriibbddvv//22

       ggeettVVeerrtteexxAAttttrriibbiivv((IInnddeexx,, PPnnaammee)) -->> {{iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(())}}

              Types:

                 Index = integer()
                 Pname = enum()

              See ggeettVVeerrtteexxAAttttrriibbddvv//22

       iissPPrrooggrraamm((PPrrooggrraamm)) -->> 00 || 11

              Types:

                 Program = integer()

              Determines if a name corresponds to a program object

              _g_l_:_i_s_P_r_o_g_r_a_m returns _?_G_L___T_R_U_E if _P_r_o_g_r_a_m is the name of a
              program object previously created with ggll::ccrreeaatteePPrrooggrraamm//00 and
              not yet deleted with ggll::ddeelleetteePPrrooggrraamm//11 . If _P_r_o_g_r_a_m is zero or
              a non-zero value that is not the name of a program object, or if
              an error occurs, _g_l_:_i_s_P_r_o_g_r_a_m returns _?_G_L___F_A_L_S_E.

              See external documentation.

       iissSShhaaddeerr((SShhaaddeerr)) -->> 00 || 11

              Types:

                 Shader = integer()

              Determines if a name corresponds to a shader object

              _g_l_:_i_s_S_h_a_d_e_r returns _?_G_L___T_R_U_E if _S_h_a_d_e_r is the name of a shader
              object previously created with ggll::ccrreeaatteeSShhaaddeerr//11 and not yet
              deleted with ggll::ddeelleetteeSShhaaddeerr//11 . If _S_h_a_d_e_r is zero or a non-zero
              value that is not the name of a shader object, or if an error
              occurs, _g_l_:_i_s_S_h_a_d_e_r returns _?_G_L___F_A_L_S_E.

              See external documentation.

       lliinnkkPPrrooggrraamm((PPrrooggrraamm)) -->> ookk

              Types:

                 Program = integer()

              Links a program object

              _g_l_:_l_i_n_k_P_r_o_g_r_a_m links the program object specified by _P_r_o_g_r_a_m .
              If any shader objects of type _?_G_L___V_E_R_T_E_X___S_H_A_D_E_R are attached to
              _P_r_o_g_r_a_m , they will be used to create an executable that will
              run on the programmable vertex processor. If any shader objects
              of type _?_G_L___G_E_O_M_E_T_R_Y___S_H_A_D_E_R are attached to _P_r_o_g_r_a_m , they will
              be used to create an executable that will run on the
              programmable geometry processor. If any shader objects of type
              _?_G_L___F_R_A_G_M_E_N_T___S_H_A_D_E_R are attached to _P_r_o_g_r_a_m , they will be used
              to create an executable that will run on the programmable
              fragment processor.

              The status of the link operation will be stored as part of the
              program object's state. This value will be set to _?_G_L___T_R_U_E if
              the program object was linked without errors and is ready for
              use, and _?_G_L___F_A_L_S_E otherwise. It can be queried by calling
              ggll::ggeettPPrrooggrraammiivv//22 with arguments _P_r_o_g_r_a_m and _?_G_L___L_I_N_K___S_T_A_T_U_S.

              As a result of a successful link operation, all active user-
              defined uniform variables belonging to _P_r_o_g_r_a_m will be
              initialized to 0, and each of the program object's active
              uniform variables will be assigned a location that can be
              queried by calling ggll::ggeettUUnniiffoorrmmLLooccaattiioonn//22 . Also, any active
              user-defined attribute variables that have not been bound to a
              generic vertex attribute index will be bound to one at this
              time.

              Linking of a program object can fail for a number of reasons as
              specified in the _O_p_e_n_G_L _S_h_a_d_i_n_g _L_a_n_g_u_a_g_e _S_p_e_c_i_f_i_c_a_t_i_o_n . The
              following lists some of the conditions that will cause a link
              error.

              The number of active attribute variables supported by the
              implementation has been exceeded.

              The storage limit for uniform variables has been exceeded.

              The number of active uniform variables supported by the
              implementation has been exceeded.

              The _m_a_i_n function is missing for the vertex, geometry or
              fragment shader.

              A varying variable actually used in the fragment shader is not
              declared in the same way (or is not declared at all) in the
              vertex shader, or geometry shader shader if present.

              A reference to a function or variable name is unresolved.

              A shared global is declared with two different types or two
              different initial values.

              One or more of the attached shader objects has not been
              successfully compiled.

              Binding a generic attribute matrix caused some rows of the
              matrix to fall outside the allowed maximum of
              _?_G_L___M_A_X___V_E_R_T_E_X___A_T_T_R_I_B_S.

              Not enough contiguous vertex attribute slots could be found to
              bind attribute matrices.

              The program object contains objects to form a fragment shader
              but does not contain objects to form a vertex shader.

              The program object contains objects to form a geometry shader
              but does not contain objects to form a vertex shader.

              The program object contains objects to form a geometry shader
              and the input primitive type, output primitive type, or maximum
              output vertex count is not specified in any compiled geometry
              shader object.

              The program object contains objects to form a geometry shader
              and the input primitive type, output primitive type, or maximum
              output vertex count is specified differently in multiple
              geometry shader objects.

              The number of active outputs in the fragment shader is greater
              than the value of _?_G_L___M_A_X___D_R_A_W___B_U_F_F_E_R_S .

              The program has an active output assigned to a location greater
              than or equal to the value of _?_G_L___M_A_X___D_U_A_L___S_O_U_R_C_E___D_R_A_W___B_U_F_F_E_R_S
              and has an active output assigned an index greater than or equal
              to one.

              More than one varying out variable is bound to the same number
              and index.

              The explicit binding assigments do not leave enough space for
              the linker to automatically assign a location for a varying out
              array, which requires multiple contiguous locations.

              The _C_o_u_n_t specified by ggll::ttrraannssffoorrmmFFeeeeddbbaacckkVVaarryyiinnggss//33 is non-
              zero, but the program object has no vertex or geometry shader.

              Any variable name specified to ggll::ttrraannssffoorrmmFFeeeeddbbaacckkVVaarryyiinnggss//33 in
              the _V_a_r_y_i_n_g_s array is not declared as an output in the vertex
              shader (or the geometry shader, if active).

              Any two entries in the _V_a_r_y_i_n_g_s array given
              ggll::ttrraannssffoorrmmFFeeeeddbbaacckkVVaarryyiinnggss//33 specify the same varying
              variable.

              The total number of components to capture in any transform
              feedback varying variable is greater than the constant
              _?_G_L___M_A_X___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___S_E_P_A_R_A_T_E___C_O_M_P_O_N_E_N_T_S and the buffer
              mode is _?_S_E_P_A_R_A_T_E___A_T_T_R_I_B_S.

              When a program object has been successfully linked, the program
              object can be made part of current state by calling
              ggll::uusseePPrrooggrraamm//11 . Whether or not the link operation was
              successful, the program object's information log will be
              overwritten. The information log can be retrieved by calling
              ggll::ggeettPPrrooggrraammIInnffooLLoogg//22 .

              _g_l_:_l_i_n_k_P_r_o_g_r_a_m will also install the generated executables as
              part of the current rendering state if the link operation was
              successful and the specified program object is already currently
              in use as a result of a previous call to ggll::uusseePPrrooggrraamm//11 . If
              the program object currently in use is relinked unsuccessfully,
              its link status will be set to _?_G_L___F_A_L_S_E , but the executables
              and associated state will remain part of the current state until
              a subsequent call to _g_l_:_u_s_e_P_r_o_g_r_a_m removes it from use. After it
              is removed from use, it cannot be made part of current state
              until it has been successfully relinked.

              If _P_r_o_g_r_a_m contains shader objects of type _?_G_L___V_E_R_T_E_X___S_H_A_D_E_R,
              and optionally of type _?_G_L___G_E_O_M_E_T_R_Y___S_H_A_D_E_R, but does not contain
              shader objects of type _?_G_L___F_R_A_G_M_E_N_T___S_H_A_D_E_R , the vertex shader
              executable will be installed on the programmable vertex
              processor, the geometry shader executable, if present, will be
              installed on the programmable geometry processor, but no
              executable will be installed on the fragment processor. The
              results of rasterizing primitives with such a program will be
              undefined.

              The program object's information log is updated and the program
              is generated at the time of the link operation. After the link
              operation, applications are free to modify attached shader
              objects, compile attached shader objects, detach shader objects,
              delete shader objects, and attach additional shader objects.
              None of these operations affects the information log or the
              program that is part of the program object.

              See external documentation.

       sshhaaddeerrSSoouurrccee((SShhaaddeerr,, SSttrriinngg)) -->> ookk

              Types:

                 Shader = integer()
                 String = [string()]

              Replaces the source code in a shader object

              _g_l_:_s_h_a_d_e_r_S_o_u_r_c_e sets the source code in _S_h_a_d_e_r to the source
              code in the array of strings specified by _S_t_r_i_n_g . Any source
              code previously stored in the shader object is completely
              replaced. The number of strings in the array is specified by
              _C_o_u_n_t . If _L_e_n_g_t_h is _?_N_U_L_L, each string is assumed to be null
              terminated. If _L_e_n_g_t_h is a value other than _?_N_U_L_L, it points to
              an array containing a string length for each of the
              corresponding elements of _S_t_r_i_n_g . Each element in the _L_e_n_g_t_h
              array may contain the length of the corresponding string (the
              null character is not counted as part of the string length) or a
              value less than 0 to indicate that the string is null
              terminated. The source code strings are not scanned or parsed at
              this time; they are simply copied into the specified shader
              object.

              See external documentation.

       uusseePPrrooggrraamm((PPrrooggrraamm)) -->> ookk

              Types:

                 Program = integer()

              Installs a program object as part of current rendering state

              _g_l_:_u_s_e_P_r_o_g_r_a_m installs the program object specified by _P_r_o_g_r_a_m
              as part of current rendering state. One or more executables are
              created in a program object by successfully attaching shader
              objects to it with ggll::aattttaacchhSShhaaddeerr//22 , successfully compiling
              the shader objects with ggll::ccoommppiilleeSShhaaddeerr//11 , and successfully
              linking the program object with ggll::lliinnkkPPrrooggrraamm//11 .

              A program object will contain an executable that will run on the
              vertex processor if it contains one or more shader objects of
              type _?_G_L___V_E_R_T_E_X___S_H_A_D_E_R that have been successfully compiled and
              linked. A program object will contain an executable that will
              run on the geometry processor if it contains one or more shader
              objects of type _?_G_L___G_E_O_M_E_T_R_Y___S_H_A_D_E_R that have been successfully
              compiled and linked. Similarly, a program object will contain an
              executable that will run on the fragment processor if it
              contains one or more shader objects of type _?_G_L___F_R_A_G_M_E_N_T___S_H_A_D_E_R
              that have been successfully compiled and linked.

              While a program object is in use, applications are free to
              modify attached shader objects, compile attached shader objects,
              attach additional shader objects, and detach or delete shader
              objects. None of these operations will affect the executables
              that are part of the current state. However, relinking the
              program object that is currently in use will install the program
              object as part of the current rendering state if the link
              operation was successful (see ggll::lliinnkkPPrrooggrraamm//11 ). If the program
              object currently in use is relinked unsuccessfully, its link
              status will be set to _?_G_L___F_A_L_S_E, but the executables and
              associated state will remain part of the current state until a
              subsequent call to _g_l_:_u_s_e_P_r_o_g_r_a_m removes it from use. After it
              is removed from use, it cannot be made part of current state
              until it has been successfully relinked.

              If _P_r_o_g_r_a_m is zero, then the current rendering state refers to
              an _i_n_v_a_l_i_d program object and the results of shader execution
              are undefined. However, this is not an error.

              If _P_r_o_g_r_a_m does not contain shader objects of type
              _?_G_L___F_R_A_G_M_E_N_T___S_H_A_D_E_R, an executable will be installed on the
              vertex, and possibly geometry processors, but the results of
              fragment shader execution will be undefined.

              See external documentation.

       uunniiffoorrmm11ff((LLooccaattiioonn,, VV00)) -->> ookk

              Types:

                 Location = integer()
                 V0 = float()

              Specify the value of a uniform variable for the current program
              object

              _g_l_:_u_n_i_f_o_r_m modifies the value of a uniform variable or a uniform
              variable array. The location of the uniform variable to be
              modified is specified by _L_o_c_a_t_i_o_n , which should be a value
              returned by ggll::ggeettUUnniiffoorrmmLLooccaattiioonn//22 . _g_l_:_u_n_i_f_o_r_m operates on the
              program object that was made part of current state by calling
              ggll::uusseePPrrooggrraamm//11 .

              The commands _g_l_:_u_n_i_f_o_r_m_{_1_|_2_|_3_|_4_}_{_f_|_i_|_u_i_} are used to change the
              value of the uniform variable specified by _L_o_c_a_t_i_o_n using the
              values passed as arguments. The number specified in the command
              should match the number of components in the data type of the
              specified uniform variable (e.g., _1 for float, int, unsigned
              int, bool; _2 for vec2, ivec2, uvec2, bvec2, etc.). The suffix _f
              indicates that floating-point values are being passed; the
              suffix _i indicates that integer values are being passed; the
              suffix _u_i indicates that unsigned integer values are being
              passed, and this type should also match the data type of the
              specified uniform variable. The _i variants of this function
              should be used to provide values for uniform variables defined
              as int, ivec2 , ivec3, ivec4, or arrays of these. The _u_i
              variants of this function should be used to provide values for
              uniform variables defined as unsigned int, uvec2, uvec3, uvec4,
              or arrays of these. The _f variants should be used to provide
              values for uniform variables of type float, vec2, vec3, vec4, or
              arrays of these. Either the _i, _u_i or _f variants may be used to
              provide values for uniform variables of type bool, bvec2 ,
              bvec3, bvec4, or arrays of these. The uniform variable will be
              set to false if the input value is 0 or 0.0f, and it will be set
              to true otherwise.

              All active uniform variables defined in a program object are
              initialized to 0 when the program object is linked successfully.
              They retain the values assigned to them by a call to _g_l_:_u_n_i_f_o_r_m
              until the next successful link operation occurs on the program
              object, when they are once again initialized to 0.

              The commands _g_l_:_u_n_i_f_o_r_m_{_1_|_2_|_3_|_4_}_{_f_|_i_|_u_i_}_v can be used to modify
              a single uniform variable or a uniform variable array. These
              commands pass a count and a pointer to the values to be loaded
              into a uniform variable or a uniform variable array. A count of
              1 should be used if modifying the value of a single uniform
              variable, and a count of 1 or greater can be used to modify an
              entire array or part of an array. When loading _n elements
              starting at an arbitrary position _m in a uniform variable array,
              elements _m + _n - 1 in the array will be replaced with the new
              values. If _M + _N - 1 is larger than the size of the uniform
              variable array, values for all array elements beyond the end of
              the array will be ignored. The number specified in the name of
              the command indicates the number of components for each element
              in _V_a_l_u_e , and it should match the number of components in the
              data type of the specified uniform variable (e.g., _1 for float,
              int, bool; _2 for vec2, ivec2, bvec2, etc.). The data type
              specified in the name of the command must match the data type
              for the specified uniform variable as described previously for
              _g_l_:_u_n_i_f_o_r_m_{_1_|_2_|_3_|_4_}_{_f_|_i_|_u_i_}.

              For uniform variable arrays, each element of the array is
              considered to be of the type indicated in the name of the
              command (e.g., _g_l_:_u_n_i_f_o_r_m_3_f or _g_l_:_u_n_i_f_o_r_m_3_f_v can be used to load
              a uniform variable array of type vec3). The number of elements
              of the uniform variable array to be modified is specified by
              _C_o_u_n_t

              The commands _g_l_:_u_n_i_f_o_r_m_M_a_t_r_i_x_{_2_|_3_|_4_|_2_x_3_|_3_x_2_|_2_x_4_|_4_x_2_|_3_x_4_|_4_x_3_}_f_v
              are used to modify a matrix or an array of matrices. The numbers
              in the command name are interpreted as the dimensionality of the
              matrix. The number _2 indicates a 2 ~A 2 matrix (i.e., 4 values),
              the number _3 indicates a 3 ~A 3 matrix (i.e., 9 values), and the
              number _4 indicates a 4 ~A 4 matrix (i.e., 16 values). Non-square
              matrix dimensionality is explicit, with the first number
              representing the number of columns and the second number
              representing the number of rows. For example, _2_x_4 indicates a 2
              ~A 4 matrix with 2 columns and 4 rows (i.e., 8 values). If
              _T_r_a_n_s_p_o_s_e is _?_G_L___F_A_L_S_E, each matrix is assumed to be supplied in
              column major order. If _T_r_a_n_s_p_o_s_e is _?_G_L___T_R_U_E, each matrix is
              assumed to be supplied in row major order. The _C_o_u_n_t argument
              indicates the number of matrices to be passed. A count of 1
              should be used if modifying the value of a single matrix, and a
              count greater than 1 can be used to modify an array of matrices.

              See external documentation.

       uunniiffoorrmm22ff((LLooccaattiioonn,, VV00,, VV11)) -->> ookk

              Types:

                 Location = integer()
                 V0 = float()
                 V1 = float()

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm33ff((LLooccaattiioonn,, VV00,, VV11,, VV22)) -->> ookk

              Types:

                 Location = integer()
                 V0 = float()
                 V1 = float()
                 V2 = float()

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm44ff((LLooccaattiioonn,, VV00,, VV11,, VV22,, VV33)) -->> ookk

              Types:

                 Location = integer()
                 V0 = float()
                 V1 = float()
                 V2 = float()
                 V3 = float()

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm11ii((LLooccaattiioonn,, VV00)) -->> ookk

              Types:

                 Location = integer()
                 V0 = integer()

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm22ii((LLooccaattiioonn,, VV00,, VV11)) -->> ookk

              Types:

                 Location = integer()
                 V0 = integer()
                 V1 = integer()

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm33ii((LLooccaattiioonn,, VV00,, VV11,, VV22)) -->> ookk

              Types:

                 Location = integer()
                 V0 = integer()
                 V1 = integer()
                 V2 = integer()

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm44ii((LLooccaattiioonn,, VV00,, VV11,, VV22,, VV33)) -->> ookk

              Types:

                 Location = integer()
                 V0 = integer()
                 V1 = integer()
                 V2 = integer()
                 V3 = integer()

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm11ffvv((LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Value = [float()]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm22ffvv((LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Value = [{float(), float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm33ffvv((LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Value = [{float(), float(), float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm44ffvv((LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Value = [{float(), float(), float(), float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm11iivv((LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Value = [integer()]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm22iivv((LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Value = [{integer(), integer()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm33iivv((LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Value = [{integer(), integer(), integer()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm44iivv((LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Value = [{integer(), integer(), integer(), integer()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx22ffvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx33ffvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float(), float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx44ffvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float(), float(), float(), float(),
                 float(), float(), float(), float(), float()}]

              See uunniiffoorrmm11ff//22

       vvaalliiddaatteePPrrooggrraamm((PPrrooggrraamm)) -->> ookk

              Types:

                 Program = integer()

              Validates a program object

              _g_l_:_v_a_l_i_d_a_t_e_P_r_o_g_r_a_m checks to see whether the executables
              contained in _P_r_o_g_r_a_m can execute given the current OpenGL state.
              The information generated by the validation process will be
              stored in _P_r_o_g_r_a_m 's information log. The validation information
              may consist of an empty string, or it may be a string containing
              information about how the current program object interacts with
              the rest of current OpenGL state. This provides a way for OpenGL
              implementers to convey more information about why the current
              program is inefficient, suboptimal, failing to execute, and so
              on.

              The status of the validation operation will be stored as part of
              the program object's state. This value will be set to _?_G_L___T_R_U_E
              if the validation succeeded, and _?_G_L___F_A_L_S_E otherwise. It can be
              queried by calling ggll::ggeettPPrrooggrraammiivv//22 with arguments _P_r_o_g_r_a_m and
              _?_G_L___V_A_L_I_D_A_T_E___S_T_A_T_U_S. If validation is successful, _P_r_o_g_r_a_m is
              guaranteed to execute given the current state. Otherwise,
              _P_r_o_g_r_a_m is guaranteed to not execute.

              This function is typically useful only during application
              development. The informational string stored in the information
              log is completely implementation dependent; therefore, an
              application should not expect different OpenGL implementations
              to produce identical information strings.

              See external documentation.

       vveerrtteexxAAttttrriibb11dd((IInnddeexx,, XX)) -->> ookk

              Types:

                 Index = integer()
                 X = float()

              Specifies the value of a generic vertex attribute

              The _g_l_:_v_e_r_t_e_x_A_t_t_r_i_b family of entry points allows an application
              to pass generic vertex attributes in numbered locations.

              Generic attributes are defined as four-component values that are
              organized into an array. The first entry of this array is
              numbered 0, and the size of the array is specified by the
              implementation-dependent constant _?_G_L___M_A_X___V_E_R_T_E_X___A_T_T_R_I_B_S.
              Individual elements of this array can be modified with a
              _g_l_:_v_e_r_t_e_x_A_t_t_r_i_b call that specifies the index of the element to
              be modified and a value for that element.

              These commands can be used to specify one, two, three, or all
              four components of the generic vertex attribute specified by
              _I_n_d_e_x . A _1 in the name of the command indicates that only one
              value is passed, and it will be used to modify the first
              component of the generic vertex attribute. The second and third
              components will be set to 0, and the fourth component will be
              set to 1. Similarly, a _2 in the name of the command indicates
              that values are provided for the first two components, the third
              component will be set to 0, and the fourth component will be set
              to 1. A _3 in the name of the command indicates that values are
              provided for the first three components and the fourth component
              will be set to 1, whereas a _4 in the name indicates that values
              are provided for all four components.

              The letters _s, _f, _i, _d, _u_b, _u_s, and _u_i indicate whether the
              arguments are of type short, float, int, double, unsigned byte,
              unsigned short, or unsigned int. When _v is appended to the name,
              the commands can take a pointer to an array of such values.

              Additional capitalized letters can indicate further alterations
              to the default behavior of the glVertexAttrib function:

              The commands containing _N indicate that the arguments will be
              passed as fixed-point values that are scaled to a normalized
              range according to the component conversion rules defined by the
              OpenGL specification. Signed values are understood to represent
              fixed-point values in the range [-1,1], and unsigned values are
              understood to represent fixed-point values in the range [0,1].

              The commands containing _I indicate that the arguments are
              extended to full signed or unsigned integers.

              The commands containing _P indicate that the arguments are stored
              as packed components within a larger natural type.

              The commands containing _L indicate that the arguments are full
              64-bit quantities and should be passed directly to shader inputs
              declared as 64-bit double precision types.

              OpenGL Shading Language attribute variables are allowed to be of
              type mat2, mat3, or mat4. Attributes of these types may be
              loaded using the _g_l_:_v_e_r_t_e_x_A_t_t_r_i_b entry points. Matrices must be
              loaded into successive generic attribute slots in column major
              order, with one column of the matrix in each generic attribute
              slot.

              A user-defined attribute variable declared in a vertex shader
              can be bound to a generic attribute index by calling
              ggll::bbiinnddAAttttrriibbLLooccaattiioonn//33 . This allows an application to use more
              descriptive variable names in a vertex shader. A subsequent
              change to the specified generic vertex attribute will be
              immediately reflected as a change to the corresponding attribute
              variable in the vertex shader.

              The binding between a generic vertex attribute index and a user-
              defined attribute variable in a vertex shader is part of the
              state of a program object, but the current value of the generic
              vertex attribute is not. The value of each generic vertex
              attribute is part of current state, just like standard vertex
              attributes, and it is maintained even if a different program
              object is used.

              An application may freely modify generic vertex attributes that
              are not bound to a named vertex shader attribute variable. These
              values are simply maintained as part of current state and will
              not be accessed by the vertex shader. If a generic vertex
              attribute bound to an attribute variable in a vertex shader is
              not updated while the vertex shader is executing, the vertex
              shader will repeatedly use the current value for the generic
              vertex attribute.

              See external documentation.

       vveerrtteexxAAttttrriibb11ddvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::float()}

              Equivalent to vveerrtteexxAAttttrriibb11dd((IInnddeexx,, XX)).

       vveerrtteexxAAttttrriibb11ff((IInnddeexx,, XX)) -->> ookk

              Types:

                 Index = integer()
                 X = float()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb11ffvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::float()}

              Equivalent to vveerrtteexxAAttttrriibb11ff((IInnddeexx,, XX)).

       vveerrtteexxAAttttrriibb11ss((IInnddeexx,, XX)) -->> ookk

              Types:

                 Index = integer()
                 X = integer()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb11ssvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::integer()}

              Equivalent to vveerrtteexxAAttttrriibb11ss((IInnddeexx,, XX)).

       vveerrtteexxAAttttrriibb22dd((IInnddeexx,, XX,, YY)) -->> ookk

              Types:

                 Index = integer()
                 X = float()
                 Y = float()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb22ddvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float()}

              Equivalent to vveerrtteexxAAttttrriibb22dd((IInnddeexx,, XX,, YY)).

       vveerrtteexxAAttttrriibb22ff((IInnddeexx,, XX,, YY)) -->> ookk

              Types:

                 Index = integer()
                 X = float()
                 Y = float()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb22ffvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float()}

              Equivalent to vveerrtteexxAAttttrriibb22ff((IInnddeexx,, XX,, YY)).

       vveerrtteexxAAttttrriibb22ss((IInnddeexx,, XX,, YY)) -->> ookk

              Types:

                 Index = integer()
                 X = integer()
                 Y = integer()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb22ssvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer()}

              Equivalent to vveerrtteexxAAttttrriibb22ss((IInnddeexx,, XX,, YY)).

       vveerrtteexxAAttttrriibb33dd((IInnddeexx,, XX,, YY,, ZZ)) -->> ookk

              Types:

                 Index = integer()
                 X = float()
                 Y = float()
                 Z = float()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb33ddvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float(), Z::float()}

              Equivalent to vveerrtteexxAAttttrriibb33dd((IInnddeexx,, XX,, YY,, ZZ)).

       vveerrtteexxAAttttrriibb33ff((IInnddeexx,, XX,, YY,, ZZ)) -->> ookk

              Types:

                 Index = integer()
                 X = float()
                 Y = float()
                 Z = float()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb33ffvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float(), Z::float()}

              Equivalent to vveerrtteexxAAttttrriibb33ff((IInnddeexx,, XX,, YY,, ZZ)).

       vveerrtteexxAAttttrriibb33ss((IInnddeexx,, XX,, YY,, ZZ)) -->> ookk

              Types:

                 Index = integer()
                 X = integer()
                 Y = integer()
                 Z = integer()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb33ssvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer()}

              Equivalent to vveerrtteexxAAttttrriibb33ss((IInnddeexx,, XX,, YY,, ZZ)).

       vveerrtteexxAAttttrriibb44NNbbvv((IInnddeexx,, VV)) -->> ookk

              Types:

                 Index = integer()
                 V = {integer(), integer(), integer(), integer()}

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb44NNiivv((IInnddeexx,, VV)) -->> ookk

              Types:

                 Index = integer()
                 V = {integer(), integer(), integer(), integer()}

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb44NNssvv((IInnddeexx,, VV)) -->> ookk

              Types:

                 Index = integer()
                 V = {integer(), integer(), integer(), integer()}

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb44NNuubb((IInnddeexx,, XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 Index = integer()
                 X = integer()
                 Y = integer()
                 Z = integer()
                 W = integer()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb44NNuubbvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer(), W::integer()}

              Equivalent to vveerrtteexxAAttttrriibb44NNuubb((IInnddeexx,, XX,, YY,, ZZ,, WW)).

       vveerrtteexxAAttttrriibb44NNuuiivv((IInnddeexx,, VV)) -->> ookk

              Types:

                 Index = integer()
                 V = {integer(), integer(), integer(), integer()}

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb44NNuussvv((IInnddeexx,, VV)) -->> ookk

              Types:

                 Index = integer()
                 V = {integer(), integer(), integer(), integer()}

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb44bbvv((IInnddeexx,, VV)) -->> ookk

              Types:

                 Index = integer()
                 V = {integer(), integer(), integer(), integer()}

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb44dd((IInnddeexx,, XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 Index = integer()
                 X = float()
                 Y = float()
                 Z = float()
                 W = float()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb44ddvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float(), Z::float(), W::float()}

              Equivalent to vveerrtteexxAAttttrriibb44dd((IInnddeexx,, XX,, YY,, ZZ,, WW)).

       vveerrtteexxAAttttrriibb44ff((IInnddeexx,, XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 Index = integer()
                 X = float()
                 Y = float()
                 Z = float()
                 W = float()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb44ffvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float(), Z::float(), W::float()}

              Equivalent to vveerrtteexxAAttttrriibb44ff((IInnddeexx,, XX,, YY,, ZZ,, WW)).

       vveerrtteexxAAttttrriibb44iivv((IInnddeexx,, VV)) -->> ookk

              Types:

                 Index = integer()
                 V = {integer(), integer(), integer(), integer()}

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb44ss((IInnddeexx,, XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 Index = integer()
                 X = integer()
                 Y = integer()
                 Z = integer()
                 W = integer()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb44ssvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer(), W::integer()}

              Equivalent to vveerrtteexxAAttttrriibb44ss((IInnddeexx,, XX,, YY,, ZZ,, WW)).

       vveerrtteexxAAttttrriibb44uubbvv((IInnddeexx,, VV)) -->> ookk

              Types:

                 Index = integer()
                 V = {integer(), integer(), integer(), integer()}

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb44uuiivv((IInnddeexx,, VV)) -->> ookk

              Types:

                 Index = integer()
                 V = {integer(), integer(), integer(), integer()}

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibb44uussvv((IInnddeexx,, VV)) -->> ookk

              Types:

                 Index = integer()
                 V = {integer(), integer(), integer(), integer()}

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibbPPooiinntteerr((IInnddeexx,, SSiizzee,, TTyyppee,, NNoorrmmaalliizzeedd,, SSttrriiddee,, PPooiinntteerr)) -->>
       ookk

              Types:

                 Index = integer()
                 Size = integer()
                 Type = enum()
                 Normalized = 0 | 1
                 Stride = integer()
                 Pointer = offset() | mem()

              Define an array of generic vertex attribute data

              _g_l_:_v_e_r_t_e_x_A_t_t_r_i_b_P_o_i_n_t_e_r, _g_l_:_v_e_r_t_e_x_A_t_t_r_i_b_I_P_o_i_n_t_e_r and
              _g_l_:_v_e_r_t_e_x_A_t_t_r_i_b_L_P_o_i_n_t_e_r specify the location and data format of
              the array of generic vertex attributes at index _I_n_d_e_x to use
              when rendering. _S_i_z_e specifies the number of components per
              attribute and must be 1, 2, 3, 4, or _?_G_L___B_G_R_A. _T_y_p_e specifies
              the data type of each component, and _S_t_r_i_d_e specifies the byte
              stride from one attribute to the next, allowing vertices and
              attributes to be packed into a single array or stored in
              separate arrays.

              For _g_l_:_v_e_r_t_e_x_A_t_t_r_i_b_P_o_i_n_t_e_r, if _N_o_r_m_a_l_i_z_e_d is set to _?_G_L___T_R_U_E, it
              indicates that values stored in an integer format are to be
              mapped to the range [-1,1] (for signed values) or [0,1] (for
              unsigned values) when they are accessed and converted to
              floating point. Otherwise, values will be converted to floats
              directly without normalization.

              For _g_l_:_v_e_r_t_e_x_A_t_t_r_i_b_I_P_o_i_n_t_e_r, only the integer types _?_G_L___B_Y_T_E,
              _?_G_L___U_N_S_I_G_N_E_D___B_Y_T_E , _?_G_L___S_H_O_R_T, _?_G_L___U_N_S_I_G_N_E_D___S_H_O_R_T, _?_G_L___I_N_T,
              _?_G_L___U_N_S_I_G_N_E_D___I_N_T are accepted. Values are always left as integer
              values.

              _g_l_:_v_e_r_t_e_x_A_t_t_r_i_b_L_P_o_i_n_t_e_r specifies state for a generic vertex
              attribute array associated with a shader attribute variable
              declared with 64-bit double precision components. _T_y_p_e must be
              _?_G_L___D_O_U_B_L_E. _I_n_d_e_x , _S_i_z_e , and _S_t_r_i_d_e behave as described for
              _g_l_:_v_e_r_t_e_x_A_t_t_r_i_b_P_o_i_n_t_e_r and _g_l_:_v_e_r_t_e_x_A_t_t_r_i_b_I_P_o_i_n_t_e_r.

              If _P_o_i_n_t_e_r is not NULL, a non-zero named buffer object must be
              bound to the _?_G_L___A_R_R_A_Y___B_U_F_F_E_R target (see ggll::bbiinnddBBuuffffeerr//22 ),
              otherwise an error is generated. _P_o_i_n_t_e_r is treated as a byte
              offset into the buffer object's data store. The buffer object
              binding (_?_G_L___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G) is saved as generic vertex
              attribute array state (_?_G_L___V_E_R_T_E_X___A_T_T_R_I_B___A_R_R_A_Y___B_U_F_F_E_R___B_I_N_D_I_N_G )
              for index _I_n_d_e_x .

              When a generic vertex attribute array is specified, _S_i_z_e , _T_y_p_e
              , _N_o_r_m_a_l_i_z_e_d , _S_t_r_i_d_e , and _P_o_i_n_t_e_r are saved as vertex array
              state, in addition to the current vertex array buffer object
              binding.

              To enable and disable a generic vertex attribute array, call
              ggll::ddiissaabblleeVVeerrtteexxAAttttrriibbAArrrraayy//11 and ggll::ddiissaabblleeVVeerrtteexxAAttttrriibbAArrrraayy//11
              with _I_n_d_e_x . If enabled, the generic vertex attribute array is
              used when ggll::ddrraawwAArrrraayyss//33 , ggll::mmuullttiiDDrraawwAArrrraayyss//33 ,
              ggll::ddrraawwEElleemmeennttss//44 , see _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s, or
              ggll::ddrraawwRRaannggeeEElleemmeennttss//66 is called.

              See external documentation.

       uunniiffoorrmmMMaattrriixx22xx33ffvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx33xx22ffvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx22xx44ffvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx44xx22ffvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx33xx44ffvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float(), float(), float(), float(),
                 float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx44xx33ffvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float(), float(), float(), float(),
                 float()}]

              See uunniiffoorrmm11ff//22

       ccoolloorrMMaasskkii((IInnddeexx,, RR,, GG,, BB,, AA)) -->> ookk

              Types:

                 Index = integer()
                 R = 0 | 1
                 G = 0 | 1
                 B = 0 | 1
                 A = 0 | 1

              glColorMaski

              See external documentation.

       ggeettBBoooolleeaannii__vv((TTaarrggeett,, IInnddeexx)) -->> [[00 || 11]]

              Types:

                 Target = enum()
                 Index = integer()

              See ggeettBBoooolleeaannvv//11

       ggeettIInntteeggeerrii__vv((TTaarrggeett,, IInnddeexx)) -->> [[iinntteeggeerr(())]]

              Types:

                 Target = enum()
                 Index = integer()

              See ggeettBBoooolleeaannvv//11

       eennaabblleeii((TTaarrggeett,, IInnddeexx)) -->> ookk

              Types:

                 Target = enum()
                 Index = integer()

              See eennaabbllee//11

       ddiissaabblleeii((TTaarrggeett,, IInnddeexx)) -->> ookk

              Types:

                 Target = enum()
                 Index = integer()

              glEnablei

              See external documentation.

       iissEEnnaabblleeddii((TTaarrggeett,, IInnddeexx)) -->> 00 || 11

              Types:

                 Target = enum()
                 Index = integer()

              glIsEnabledi

              See external documentation.

       bbeeggiinnTTrraannssffoorrmmFFeeeeddbbaacckk((PPrriimmiittiivveeMMooddee)) -->> ookk

              Types:

                 PrimitiveMode = enum()

              Start transform feedback operation

              Transform feedback mode captures the values of varying variables
              written by the vertex shader (or, if active, the geometry
              shader). Transform feedback is said to be active after a call to
              _g_l_:_b_e_g_i_n_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k until a subsequent call to
              ggll::bbeeggiinnTTrraannssffoorrmmFFeeeeddbbaacckk//11 . Transform feedback commands must
              be paired.

              If no geometry shader is present, while transform feedback is
              active the _M_o_d_e parameter to ggll::ddrraawwAArrrraayyss//33 must match those
              specified in the following table:_T_r_a_n_s_f_o_r_m
              _F_e_e_d_b_a_c_k_P_r_i_m_i_t_i_v_e_M_o_d_e_A_l_l_o_w_e_d _R_e_n_d_e_r _P_r_i_m_i_t_i_v_e_M_o_d_e_s
              _?_G_L___P_O_I_N_T_S_?_G_L___P_O_I_N_T_S
              _?_G_L___L_I_N_E_S_?_G_L___L_I_N_E_S, _?_G_L___L_I_N_E___L_O_O_P, _?_G_L___L_I_N_E___S_T_R_I_P ,
              _?_G_L___L_I_N_E_S___A_D_J_A_C_E_N_C_Y, _?_G_L___L_I_N_E___S_T_R_I_P___A_D_J_A_C_E_N_C_Y
              _?_G_L___T_R_I_A_N_G_L_E_S_?_G_L___T_R_I_A_N_G_L_E_S, _?_G_L___T_R_I_A_N_G_L_E___S_T_R_I_P,
              _?_G_L___T_R_I_A_N_G_L_E___F_A_N, _?_G_L___T_R_I_A_N_G_L_E_S___A_D_J_A_C_E_N_C_Y ,
              _?_G_L___T_R_I_A_N_G_L_E___S_T_R_I_P___A_D_J_A_C_E_N_C_Y


              If a geometry shader is present, the output primitive type from
              the geometry shader must match those provided in the following
              table:_T_r_a_n_s_f_o_r_m _F_e_e_d_b_a_c_k_P_r_i_m_i_t_i_v_e_M_o_d_e_A_l_l_o_w_e_d _G_e_o_m_e_t_r_y _S_h_a_d_e_r
              _O_u_t_p_u_t _P_r_i_m_i_t_i_v_e _T_y_p_e
              _?_G_L___P_O_I_N_T_S_?_p_o_i_n_t_s
              _?_G_L___L_I_N_E_S_?_l_i_n_e___s_t_r_i_p
              _?_G_L___T_R_I_A_N_G_L_E_S_?_t_r_i_a_n_g_l_e___s_t_r_i_p


              See external documentation.

       eennddTTrraannssffoorrmmFFeeeeddbbaacckk(()) -->> ookk

              See bbeeggiinnTTrraannssffoorrmmFFeeeeddbbaacckk//11

       bbiinnddBBuuffffeerrRRaannggee((TTaarrggeett,, IInnddeexx,, BBuuffffeerr,, OOffffsseett,, SSiizzee)) -->> ookk

              Types:

                 Target = enum()
                 Index = integer()
                 Buffer = integer()
                 Offset = integer()
                 Size = integer()

              Bind a range within a buffer object to an indexed buffer target

              _g_l_:_b_i_n_d_B_u_f_f_e_r_R_a_n_g_e binds a range the buffer object _B_u_f_f_e_r
              represented by _O_f_f_s_e_t and _S_i_z_e to the binding point at index
              _I_n_d_e_x of the array of targets specified by _T_a_r_g_e_t . Each _T_a_r_g_e_t
              represents an indexed array of buffer binding points, as well as
              a single general binding point that can be used by other buffer
              manipulation functions such as ggll::bbiinnddBBuuffffeerr//22 or see
              _g_l_M_a_p_B_u_f_f_e_r. In addition to binding a range of _B_u_f_f_e_r to the
              indexed buffer binding target, _g_l_:_b_i_n_d_B_u_f_f_e_r_B_a_s_e also binds the
              range to the generic buffer binding point specified by _T_a_r_g_e_t .

              _O_f_f_s_e_t specifies the offset in basic machine units into the
              buffer object _B_u_f_f_e_r and _S_i_z_e specifies the amount of data that
              can be read from the buffer object while used as an indexed
              target.

              See external documentation.

       bbiinnddBBuuffffeerrBBaassee((TTaarrggeett,, IInnddeexx,, BBuuffffeerr)) -->> ookk

              Types:

                 Target = enum()
                 Index = integer()
                 Buffer = integer()

              Bind a buffer object to an indexed buffer target

              _g_l_:_b_i_n_d_B_u_f_f_e_r_B_a_s_e binds the buffer object _B_u_f_f_e_r to the binding
              point at index _I_n_d_e_x of the array of targets specified by _T_a_r_g_e_t
              . Each _T_a_r_g_e_t represents an indexed array of buffer binding
              points, as well as a single general binding point that can be
              used by other buffer manipulation functions such as
              ggll::bbiinnddBBuuffffeerr//22 or see _g_l_M_a_p_B_u_f_f_e_r. In addition to binding
              _B_u_f_f_e_r to the indexed buffer binding target, _g_l_:_b_i_n_d_B_u_f_f_e_r_B_a_s_e
              also binds _B_u_f_f_e_r to the generic buffer binding point specified
              by _T_a_r_g_e_t .

              See external documentation.

       ttrraannssffoorrmmFFeeeeddbbaacckkVVaarryyiinnggss((PPrrooggrraamm,, VVaarryyiinnggss,, BBuuffffeerrMMooddee)) -->> ookk

              Types:

                 Program = integer()
                 Varyings = [string()]
                 BufferMode = enum()

              Specify values to record in transform feedback buffers

              The names of the vertex or geometry shader outputs to be
              recorded in transform feedback mode are specified using
              _g_l_:_t_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k_V_a_r_y_i_n_g_s. When a geometry shader is active,
              transform feedback records the values of selected geometry
              shader output variables from the emitted vertices. Otherwise,
              the values of the selected vertex shader outputs are recorded.

              The state set by _g_l_:_t_r_a_n_f_o_r_m_F_e_e_d_b_a_c_k_V_a_r_y_i_n_g_s is stored and takes
              effect next time ggll::lliinnkkPPrrooggrraamm//11 is called on _P_r_o_g_r_a_m . When
              ggll::lliinnkkPPrrooggrraamm//11 is called, _P_r_o_g_r_a_m is linked so that the values
              of the specified varying variables for the vertices of each
              primitive generated by the GL are written to a single buffer
              object if _B_u_f_f_e_r_M_o_d_e is _?_G_L___I_N_T_E_R_L_E_A_V_E_D___A_T_T_R_I_B_S or multiple
              buffer objects if _B_u_f_f_e_r_M_o_d_e is _?_G_L___S_E_P_A_R_A_T_E___A_T_T_R_I_B_S .

              In addition to the errors generated by
              _g_l_:_t_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k_V_a_r_y_i_n_g_s, the program _P_r_o_g_r_a_m will fail to
              link if:

              The count specified by _g_l_:_t_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k_V_a_r_y_i_n_g_s is non-zero,
              but the program object has no vertex or geometry shader.

              Any variable name specified in the _V_a_r_y_i_n_g_s array is not
              declared as an output in the vertex shader (or the geometry
              shader, if active).

              Any two entries in the _V_a_r_y_i_n_g_s array specify the same varying
              variable.

              The total number of components to capture in any varying
              variable in _V_a_r_y_i_n_g_s is greater than the constant
              _?_G_L___M_A_X___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___S_E_P_A_R_A_T_E___C_O_M_P_O_N_E_N_T_S and the buffer
              mode is _?_G_L___S_E_P_A_R_A_T_E___A_T_T_R_I_B_S.

              The total number of components to capture is greater than the
              constant _?_G_L___M_A_X___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___I_N_T_E_R_L_E_A_V_E_D___C_O_M_P_O_N_E_N_T_S and
              the buffer mode is _?_G_L___I_N_T_E_R_L_E_A_V_E_D___A_T_T_R_I_B_S.

              See external documentation.

       ggeettTTrraannssffoorrmmFFeeeeddbbaacckkVVaarryyiinngg((PPrrooggrraamm,, IInnddeexx,, BBuuffSSiizzee)) -->>
       {{SSiizzee::::iinntteeggeerr(()),, TTyyppee::::eennuumm(()),, NNaammee::::ssttrriinngg(())}}

              Types:

                 Program = integer()
                 Index = integer()
                 BufSize = integer()

              Retrieve information about varying variables selected for
              transform feedback

              Information about the set of varying variables in a linked
              program that will be captured during transform feedback may be
              retrieved by calling _g_l_:_g_e_t_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k_V_a_r_y_i_n_g.
              _g_l_:_g_e_t_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k_V_a_r_y_i_n_g provides information about the
              varying variable selected by _I_n_d_e_x . An _I_n_d_e_x of 0 selects the
              first varying variable specified in the _V_a_r_y_i_n_g_s array passed to
              ggll::ttrraannssffoorrmmFFeeeeddbbaacckkVVaarryyiinnggss//33 , and an _I_n_d_e_x of
              _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___V_A_R_Y_I_N_G_S_-_1 selects the last such
              variable.

              The name of the selected varying is returned as a null-
              terminated string in _N_a_m_e . The actual number of characters
              written into _N_a_m_e , excluding the null terminator, is returned
              in _L_e_n_g_t_h . If _L_e_n_g_t_h is NULL, no length is returned. The
              maximum number of characters that may be written into _N_a_m_e ,
              including the null terminator, is specified by _B_u_f_S_i_z_e .

              The length of the longest varying name in program is given by
              _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___V_A_R_Y_I_N_G___M_A_X___L_E_N_G_T_H , which can be queried
              with ggll::ggeettPPrrooggrraammiivv//22 .

              For the selected varying variable, its type is returned into
              _T_y_p_e . The size of the varying is returned into _S_i_z_e . The value
              in _S_i_z_e is in units of the type returned in _T_y_p_e . The type
              returned can be any of the scalar, vector, or matrix attribute
              types returned by ggll::ggeettAAccttiivveeAAttttrriibb//33 . If an error occurred,
              the return parameters _L_e_n_g_t_h , _S_i_z_e , _T_y_p_e and _N_a_m_e will be
              unmodified. This command will return as much information about
              the varying variables as possible. If no information is
              available, _L_e_n_g_t_h will be set to zero and _N_a_m_e will be an empty
              string. This situation could arise if
              _g_l_:_g_e_t_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k_V_a_r_y_i_n_g is called after a failed link.

              See external documentation.

       ccllaammppCCoolloorr((TTaarrggeett,, CCllaammpp)) -->> ookk

              Types:

                 Target = enum()
                 Clamp = enum()

              specify whether data read via

              ggll::rreeaaddPPiixxeellss//77 should be clamped

              _g_l_:_c_l_a_m_p_C_o_l_o_r controls color clamping that is performed during
              ggll::rreeaaddPPiixxeellss//77 . _T_a_r_g_e_t must be _?_G_L___C_L_A_M_P___R_E_A_D___C_O_L_O_R. If _C_l_a_m_p
              is _?_G_L___T_R_U_E, read color clamping is enabled; if _C_l_a_m_p is
              _?_G_L___F_A_L_S_E, read color clamping is disabled. If _C_l_a_m_p is
              _?_G_L___F_I_X_E_D___O_N_L_Y, read color clamping is enabled only if the
              selected read buffer has fixed point components and disabled
              otherwise.

              See external documentation.

       bbeeggiinnCCoonnddiittiioonnaallRReennddeerr((IIdd,, MMooddee)) -->> ookk

              Types:

                 Id = integer()
                 Mode = enum()

              Start conditional rendering

              Conditional rendering is started using _g_l_:_b_e_g_i_n_C_o_n_d_i_t_i_o_n_a_l_R_e_n_d_e_r
              and ended using _g_l_:_e_n_d_C_o_n_d_i_t_i_o_n_a_l_R_e_n_d_e_r . During conditional
              rendering, all vertex array commands, as well as ggll::cclleeaarr//11 and
              ggll::cclleeaarrBBuuffffeerriivv//33 have no effect if the (_?_G_L___S_A_M_P_L_E_S___P_A_S_S_E_D)
              result of the query object _I_d is zero, or if the
              (_?_G_L___A_N_Y___S_A_M_P_L_E_S___P_A_S_S_E_D) result is _?_G_L___F_A_L_S_E . The results of
              commands setting the current vertex state, such as
              ggll::vveerrtteexxAAttttrriibb11dd//22 are undefined. If the (_?_G_L___S_A_M_P_L_E_S___P_A_S_S_E_D)
              result is non-zero or if the (_?_G_L___A_N_Y___S_A_M_P_L_E_S___P_A_S_S_E_D ) result is
              _?_G_L___T_R_U_E, such commands are not discarded. The _I_d parameter to
              _g_l_:_b_e_g_i_n_C_o_n_d_i_t_i_o_n_a_l_R_e_n_d_e_r must be the name of a query object
              previously returned from a call to ggll::ggeennQQuueerriieess//11 . _M_o_d_e
              specifies how the results of the query object are to be
              interpreted. If _M_o_d_e is _?_G_L___Q_U_E_R_Y___W_A_I_T, the GL waits for the
              results of the query to be available and then uses the results
              to determine if subsequent rendering commands are discarded. If
              _M_o_d_e is _?_G_L___Q_U_E_R_Y___N_O___W_A_I_T, the GL may choose to unconditionally
              execute the subsequent rendering commands without waiting for
              the query to complete.

              If _M_o_d_e is _?_G_L___Q_U_E_R_Y___B_Y___R_E_G_I_O_N___W_A_I_T, the GL will also wait for
              occlusion query results and discard rendering commands if the
              result of the occlusion query is zero. If the query result is
              non-zero, subsequent rendering commands are executed, but the GL
              may discard the results of the commands for any region of the
              framebuffer that did not contribute to the sample count in the
              specified occlusion query. Any such discarding is done in an
              implementation-dependent manner, but the rendering command
              results may not be discarded for any samples that contributed to
              the occlusion query sample count. If _M_o_d_e is
              _?_G_L___Q_U_E_R_Y___B_Y___R_E_G_I_O_N___N_O___W_A_I_T, the GL operates as in
              _?_G_L___Q_U_E_R_Y___B_Y___R_E_G_I_O_N___W_A_I_T , but may choose to unconditionally
              execute the subsequent rendering commands without waiting for
              the query to complete.

              See external documentation.

       eennddCCoonnddiittiioonnaallRReennddeerr(()) -->> ookk

              See bbeeggiinnCCoonnddiittiioonnaallRReennddeerr//22

       vveerrtteexxAAttttrriibbIIPPooiinntteerr((IInnddeexx,, SSiizzee,, TTyyppee,, SSttrriiddee,, PPooiinntteerr)) -->> ookk

              Types:

                 Index = integer()
                 Size = integer()
                 Type = enum()
                 Stride = integer()
                 Pointer = offset() | mem()

              glVertexAttribIPointer

              See external documentation.

       ggeettVVeerrtteexxAAttttrriibbIIiivv((IInnddeexx,, PPnnaammee)) -->> {{iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(())}}

              Types:

                 Index = integer()
                 Pname = enum()

              See ggeettVVeerrtteexxAAttttrriibbddvv//22

       ggeettVVeerrtteexxAAttttrriibbIIuuiivv((IInnddeexx,, PPnnaammee)) -->> {{iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(())}}

              Types:

                 Index = integer()
                 Pname = enum()

              glGetVertexAttribI

              See external documentation.

       vveerrtteexxAAttttrriibbII11ii((IInnddeexx,, XX)) -->> ookk

              Types:

                 Index = integer()
                 X = integer()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibbII22ii((IInnddeexx,, XX,, YY)) -->> ookk

              Types:

                 Index = integer()
                 X = integer()
                 Y = integer()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibbII33ii((IInnddeexx,, XX,, YY,, ZZ)) -->> ookk

              Types:

                 Index = integer()
                 X = integer()
                 Y = integer()
                 Z = integer()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibbII44ii((IInnddeexx,, XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 Index = integer()
                 X = integer()
                 Y = integer()
                 Z = integer()
                 W = integer()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibbII11uuii((IInnddeexx,, XX)) -->> ookk

              Types:

                 Index = integer()
                 X = integer()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibbII22uuii((IInnddeexx,, XX,, YY)) -->> ookk

              Types:

                 Index = integer()
                 X = integer()
                 Y = integer()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibbII33uuii((IInnddeexx,, XX,, YY,, ZZ)) -->> ookk

              Types:

                 Index = integer()
                 X = integer()
                 Y = integer()
                 Z = integer()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibbII44uuii((IInnddeexx,, XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 Index = integer()
                 X = integer()
                 Y = integer()
                 Z = integer()
                 W = integer()

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibbII11iivv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::integer()}

              Equivalent to vveerrtteexxAAttttrriibbII11ii((IInnddeexx,, XX)).

       vveerrtteexxAAttttrriibbII22iivv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer()}

              Equivalent to vveerrtteexxAAttttrriibbII22ii((IInnddeexx,, XX,, YY)).

       vveerrtteexxAAttttrriibbII33iivv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer()}

              Equivalent to vveerrtteexxAAttttrriibbII33ii((IInnddeexx,, XX,, YY,, ZZ)).

       vveerrtteexxAAttttrriibbII44iivv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer(), W::integer()}

              Equivalent to vveerrtteexxAAttttrriibbII44ii((IInnddeexx,, XX,, YY,, ZZ,, WW)).

       vveerrtteexxAAttttrriibbII11uuiivv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::integer()}

              Equivalent to vveerrtteexxAAttttrriibbII11uuii((IInnddeexx,, XX)).

       vveerrtteexxAAttttrriibbII22uuiivv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer()}

              Equivalent to vveerrtteexxAAttttrriibbII22uuii((IInnddeexx,, XX,, YY)).

       vveerrtteexxAAttttrriibbII33uuiivv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer()}

              Equivalent to vveerrtteexxAAttttrriibbII33uuii((IInnddeexx,, XX,, YY,, ZZ)).

       vveerrtteexxAAttttrriibbII44uuiivv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::integer(), Y::integer(), Z::integer(), W::integer()}

              Equivalent to vveerrtteexxAAttttrriibbII44uuii((IInnddeexx,, XX,, YY,, ZZ,, WW)).

       vveerrtteexxAAttttrriibbII44bbvv((IInnddeexx,, VV)) -->> ookk

              Types:

                 Index = integer()
                 V = {integer(), integer(), integer(), integer()}

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibbII44ssvv((IInnddeexx,, VV)) -->> ookk

              Types:

                 Index = integer()
                 V = {integer(), integer(), integer(), integer()}

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibbII44uubbvv((IInnddeexx,, VV)) -->> ookk

              Types:

                 Index = integer()
                 V = {integer(), integer(), integer(), integer()}

              See vveerrtteexxAAttttrriibb11dd//22

       vveerrtteexxAAttttrriibbII44uussvv((IInnddeexx,, VV)) -->> ookk

              Types:

                 Index = integer()
                 V = {integer(), integer(), integer(), integer()}

              See vveerrtteexxAAttttrriibb11dd//22

       ggeettUUnniiffoorrmmuuiivv((PPrrooggrraamm,, LLooccaattiioonn)) -->> {{iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(())}}

              Types:

                 Program = integer()
                 Location = integer()

              See ggeettUUnniiffoorrmmffvv//22

       bbiinnddFFrraaggDDaattaaLLooccaattiioonn((PPrrooggrraamm,, CCoolloorr,, NNaammee)) -->> ookk

              Types:

                 Program = integer()
                 Color = integer()
                 Name = string()

              Bind a user-defined varying out variable to a fragment shader
              color number

              _g_l_:_b_i_n_d_F_r_a_g_D_a_t_a_L_o_c_a_t_i_o_n explicitly specifies the binding of the
              user-defined varying out variable _N_a_m_e to fragment shader color
              number _C_o_l_o_r_N_u_m_b_e_r for program _P_r_o_g_r_a_m . If _N_a_m_e was bound
              previously, its assigned binding is replaced with _C_o_l_o_r_N_u_m_b_e_r .
              _N_a_m_e must be a null-terminated string. _C_o_l_o_r_N_u_m_b_e_r must be less
              than _?_G_L___M_A_X___D_R_A_W___B_U_F_F_E_R_S .

              The bindings specified by _g_l_:_b_i_n_d_F_r_a_g_D_a_t_a_L_o_c_a_t_i_o_n have no effect
              until _P_r_o_g_r_a_m is next linked. Bindings may be specified at any
              time after _P_r_o_g_r_a_m has been created. Specifically, they may be
              specified before shader objects are attached to the program.
              Therefore, any name may be specified in _N_a_m_e , including a name
              that is never used as a varying out variable in any fragment
              shader object. Names beginning with _?_g_l__ are reserved by the GL.

              In addition to the errors generated by _g_l_:_b_i_n_d_F_r_a_g_D_a_t_a_L_o_c_a_t_i_o_n,
              the program _P_r_o_g_r_a_m will fail to link if:

              The number of active outputs is greater than the value
              _?_G_L___M_A_X___D_R_A_W___B_U_F_F_E_R_S.

              More than one varying out variable is bound to the same color
              number.

              See external documentation.

       ggeettFFrraaggDDaattaaLLooccaattiioonn((PPrrooggrraamm,, NNaammee)) -->> iinntteeggeerr(())

              Types:

                 Program = integer()
                 Name = string()

              Query the bindings of color numbers to user-defined varying out
              variables

              _g_l_:_g_e_t_F_r_a_g_D_a_t_a_L_o_c_a_t_i_o_n retrieves the assigned color number
              binding for the user-defined varying out variable _N_a_m_e for
              program _P_r_o_g_r_a_m . _P_r_o_g_r_a_m must have previously been linked. _N_a_m_e
              must be a null-terminated string. If _N_a_m_e is not the name of an
              active user-defined varying out fragment shader variable within
              _P_r_o_g_r_a_m , -1 will be returned.

              See external documentation.

       uunniiffoorrmm11uuii((LLooccaattiioonn,, VV00)) -->> ookk

              Types:

                 Location = integer()
                 V0 = integer()

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm22uuii((LLooccaattiioonn,, VV00,, VV11)) -->> ookk

              Types:

                 Location = integer()
                 V0 = integer()
                 V1 = integer()

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm33uuii((LLooccaattiioonn,, VV00,, VV11,, VV22)) -->> ookk

              Types:

                 Location = integer()
                 V0 = integer()
                 V1 = integer()
                 V2 = integer()

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm44uuii((LLooccaattiioonn,, VV00,, VV11,, VV22,, VV33)) -->> ookk

              Types:

                 Location = integer()
                 V0 = integer()
                 V1 = integer()
                 V2 = integer()
                 V3 = integer()

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm11uuiivv((LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Value = [integer()]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm22uuiivv((LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Value = [{integer(), integer()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm33uuiivv((LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Value = [{integer(), integer(), integer()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm44uuiivv((LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Value = [{integer(), integer(), integer(), integer()}]

              See uunniiffoorrmm11ff//22

       tteexxPPaarraammeetteerrIIiivv((TTaarrggeett,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Target = enum()
                 Pname = enum()
                 Params = {integer()}

              See tteexxPPaarraammeetteerrff//33

       tteexxPPaarraammeetteerrIIuuiivv((TTaarrggeett,, PPnnaammee,, PPaarraammss)) -->> ookk

              Types:

                 Target = enum()
                 Pname = enum()
                 Params = {integer()}

              glTexParameterI

              See external documentation.

       ggeettTTeexxPPaarraammeetteerrIIiivv((TTaarrggeett,, PPnnaammee)) -->> {{iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(())}}

              Types:

                 Target = enum()
                 Pname = enum()

              See ggeettTTeexxPPaarraammeetteerrffvv//22

       ggeettTTeexxPPaarraammeetteerrIIuuiivv((TTaarrggeett,, PPnnaammee)) -->> {{iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(())}}

              Types:

                 Target = enum()
                 Pname = enum()

              glGetTexParameterI

              See external documentation.

       cclleeaarrBBuuffffeerriivv((BBuuffffeerr,, DDrraawwbbuuffffeerr,, VVaalluuee)) -->> ookk

              Types:

                 Buffer = enum()
                 Drawbuffer = integer()
                 Value = {integer()}

              Clear individual buffers of the currently bound draw framebuffer

              _g_l_:_c_l_e_a_r_B_u_f_f_e_r_* clears the specified buffer to the specified
              value(s). If _B_u_f_f_e_r is _?_G_L___C_O_L_O_R, a particular draw buffer
              _?_G_L___D_R_A_W_B_U_F_F_E_R _I is specified by passing _I as _D_r_a_w_B_u_f_f_e_r . In
              this case, _V_a_l_u_e points to a four-element vector specifying the
              R, G, B and A color to clear that draw buffer to. If _B_u_f_f_e_r is
              one of _?_G_L___F_R_O_N_T, _?_G_L___B_A_C_K, _?_G_L___L_E_F_T, _?_G_L___R_I_G_H_T, or
              _?_G_L___F_R_O_N_T___A_N_D___B_A_C_K , identifying multiple buffers, each selected
              buffer is cleared to the same value. Clamping and conversion for
              fixed-point color buffers are performed in the same fashion as
              ggll::cclleeaarrCCoolloorr//44 .

              If _B_u_f_f_e_r is _?_G_L___D_E_P_T_H, _D_r_a_w_B_u_f_f_e_r must be zero, and _V_a_l_u_e
              points to a single value to clear the depth buffer to. Only
              _g_l_:_c_l_e_a_r_B_u_f_f_e_r_f_v should be used to clear depth buffers. Clamping
              and conversion for fixed-point depth buffers are performed in
              the same fashion as ggll::cclleeaarrDDeepptthh//11 .

              If _B_u_f_f_e_r is _?_G_L___S_T_E_N_C_I_L, _D_r_a_w_B_u_f_f_e_r must be zero, and _V_a_l_u_e
              points to a single value to clear the stencil buffer to. Only
              _g_l_:_c_l_e_a_r_B_u_f_f_e_r_i_v should be used to clear stencil buffers. Masing
              and type conversion are performed in the same fashion as
              ggll::cclleeaarrSStteenncciill//11 .

              _g_l_:_c_l_e_a_r_B_u_f_f_e_r_f_i may be used to clear the depth and stencil
              buffers. _B_u_f_f_e_r must be _?_G_L___D_E_P_T_H___S_T_E_N_C_I_L and _D_r_a_w_B_u_f_f_e_r must be
              zero. _D_e_p_t_h and _S_t_e_n_c_i_l are the depth and stencil values,
              respectively.

              The result of _g_l_:_c_l_e_a_r_B_u_f_f_e_r is undefined if no conversion
              between the type of _V_a_l_u_e and the buffer being cleared is
              defined. However, this is not an error.

              See external documentation.

       cclleeaarrBBuuffffeerruuiivv((BBuuffffeerr,, DDrraawwbbuuffffeerr,, VVaalluuee)) -->> ookk

              Types:

                 Buffer = enum()
                 Drawbuffer = integer()
                 Value = {integer()}

              See cclleeaarrBBuuffffeerriivv//33

       cclleeaarrBBuuffffeerrffvv((BBuuffffeerr,, DDrraawwbbuuffffeerr,, VVaalluuee)) -->> ookk

              Types:

                 Buffer = enum()
                 Drawbuffer = integer()
                 Value = {float()}

              See cclleeaarrBBuuffffeerriivv//33

       cclleeaarrBBuuffffeerrffii((BBuuffffeerr,, DDrraawwbbuuffffeerr,, DDeepptthh,, SStteenncciill)) -->> ookk

              Types:

                 Buffer = enum()
                 Drawbuffer = integer()
                 Depth = float()
                 Stencil = integer()

              glClearBufferfi

              See external documentation.

       ggeettSSttrriinnggii((NNaammee,, IInnddeexx)) -->> ssttrriinngg(())

              Types:

                 Name = enum()
                 Index = integer()

              See ggeettSSttrriinngg//11

       ddrraawwAArrrraayyssIInnssttaanncceedd((MMooddee,, FFiirrsstt,, CCoouunntt,, PPrriimmccoouunntt)) -->> ookk

              Types:

                 Mode = enum()
                 First = integer()
                 Count = integer()
                 Primcount = integer()

              glDrawArraysInstance

              See external documentation.

       ddrraawwEElleemmeennttssIInnssttaanncceedd((MMooddee,, CCoouunntt,, TTyyppee,, IInnddiicceess,, PPrriimmccoouunntt)) -->> ookk

              Types:

                 Mode = enum()
                 Count = integer()
                 Type = enum()
                 Indices = offset() | mem()
                 Primcount = integer()

              glDrawElementsInstance

              See external documentation.

       tteexxBBuuffffeerr((TTaarrggeett,, IInntteerrnnaallffoorrmmaatt,, BBuuffffeerr)) -->> ookk

              Types:

                 Target = enum()
                 Internalformat = enum()
                 Buffer = integer()

              Attach the storage for a buffer object to the active buffer
              texture

              _g_l_:_t_e_x_B_u_f_f_e_r attaches the storage for the buffer object named
              _B_u_f_f_e_r to the active buffer texture, and specifies the internal
              format for the texel array found in the attached buffer object.
              If _B_u_f_f_e_r is zero, any buffer object attached to the buffer
              texture is detached and no new buffer object is attached. If
              _B_u_f_f_e_r is non-zero, it must be the name of an existing buffer
              object. _T_a_r_g_e_t must be _?_G_L___T_E_X_T_U_R_E___B_U_F_F_E_R . _I_n_t_e_r_n_a_l_f_o_r_m_a_t
              specifies the storage format, and must be one of the following
              sized internal formats:_C_o_m_p_o_n_e_n_t
              _S_i_z_e_d _I_n_t_e_r_n_a_l _F_o_r_m_a_t_B_a_s_e _T_y_p_e_C_o_m_p_o_n_e_n_t_s_N_o_r_m0123
              _?_G_L___R_8ubyte1YESR00 1
              _?_G_L___R_1_6ushort1YESR 001
              _?_G_L___R_1_6_Fhalf1NO R001
              _?_G_L___R_3_2_Ffloat 1NOR001
              _?_G_L___R_8_I byte1NOR001
              _?_G_L___R_1_6_I short1NOR001
              _?_G_L___R_3_2_Iint1NOR001
              _?_G_L___R_8_U_Iubyte1NOR0 01
              _?_G_L___R_1_6_U_Iushort1NO R001
              _?_G_L___R_3_2_U_Iuint1 NOR001
              _?_G_L___R_G_8ubyte 2YESRG01
              _?_G_L___R_G_1_6 ushort2YESRG01
              _?_G_L___R_G_1_6_Fhalf2NORG0 1
              _?_G_L___R_G_3_2_Ffloat2NORG 01
              _?_G_L___R_G_8_Ibyte2NO RG01
              _?_G_L___R_G_1_6_Ishort 2NORG01
              _?_G_L___R_G_3_2_I int2NORG01
              _?_G_L___R_G_8_U_I ubyte2NORG01
              _?_G_L___R_G_1_6_U_Iushort2NORG0 1
              _?_G_L___R_G_3_2_U_Iuint2NORG 01
              _?_G_L___R_G_B_3_2_Ffloat3NO RGB1
              _?_G_L___R_G_B_3_2_Iint 3NORGB1
              _?_G_L___R_G_B_3_2_U_I uint3NORGB1
              _?_G_L___R_G_B_A_8uint4YESRGB A
              _?_G_L___R_G_B_A_1_6short4YESR GBA
              _?_G_L___R_G_B_A_1_6_Fhalf4NO RGBA
              _?_G_L___R_G_B_A_3_2_Ffloat 4NORGBA
              _?_G_L___R_G_B_A_8_I byte4NORGBA
              _?_G_L___R_G_B_A_1_6_Ishort4NORGB A
              _?_G_L___R_G_B_A_3_2_Iint4NORG BA
              _?_G_L___R_G_B_A_8_U_Iubyte4NO RGBA
              _?_G_L___R_G_B_A_1_6_U_Iushort 4NORGBA
              _?_G_L___R_G_B_A_3_2_U_I uint4NORGBA


              When a buffer object is attached to a buffer texture, the buffer
              object's data store is taken as the texture's texel array. The
              number of texels in the buffer texture's texel array is given by
              buffer_size components~A sizeof( base_type/)

              where _b_u_f_f_e_r___s_i_z_e is the size of the buffer object, in basic
              machine units and components and base type are the element count
              and base data type for elements, as specified in the table
              above. The number of texels in the texel array is then clamped
              to the implementation-dependent limit
              _?_G_L___M_A_X___T_E_X_T_U_R_E___B_U_F_F_E_R___S_I_Z_E. When a buffer texture is accessed
              in a shader, the results of a texel fetch are undefined if the
              specified texel coordinate is negative, or greater than or equal
              to the clamped number of texels in the texel array.

              See external documentation.

       pprriimmiittiivveeRReessttaarrttIInnddeexx((IInnddeexx)) -->> ookk

              Types:

                 Index = integer()

              Specify the primitive restart index

              _g_l_:_p_r_i_m_i_t_i_v_e_R_e_s_t_a_r_t_I_n_d_e_x specifies a vertex array element that
              is treated specially when primitive restarting is enabled. This
              is known as the primitive restart index.

              When one of the _D_r_a_w_* commands transfers a set of generic
              attribute array elements to the GL, if the index within the
              vertex arrays corresponding to that set is equal to the
              primitive restart index, then the GL does not process those
              elements as a vertex. Instead, it is as if the drawing command
              ended with the immediately preceding transfer, and another
              drawing command is immediately started with the same parameters,
              but only transferring the immediately following element through
              the end of the originally specified elements.

              When either ggll::ddrraawwEElleemmeennttssBBaasseeVVeerrtteexx//55 ,
              ggll::ddrraawwEElleemmeennttssIInnssttaanncceeddBBaasseeVVeerrtteexx//66 or see
              _g_l_M_u_l_t_i_D_r_a_w_E_l_e_m_e_n_t_s_B_a_s_e_V_e_r_t_e_x is used, the primitive restart
              comparison occurs before the basevertex offset is added to the
              array index.

              See external documentation.

       ggeettIInntteeggeerr6644ii__vv((TTaarrggeett,, IInnddeexx)) -->> [[iinntteeggeerr(())]]

              Types:

                 Target = enum()
                 Index = integer()

              See ggeettBBoooolleeaannvv//11

       ggeettBBuuffffeerrPPaarraammeetteerrii6644vv((TTaarrggeett,, PPnnaammee)) -->> [[iinntteeggeerr(())]]

              Types:

                 Target = enum()
                 Pname = enum()

              glGetBufferParameteri64v

              See external documentation.

       ffrraammeebbuuffffeerrTTeexxttuurree((TTaarrggeett,, AAttttaacchhmmeenntt,, TTeexxttuurree,, LLeevveell)) -->> ookk

              Types:

                 Target = enum()
                 Attachment = enum()
                 Texture = integer()
                 Level = integer()

              Attach a level of a texture object as a logical buffer to the
              currently bound framebuffer object

              _g_l_:_f_r_a_m_e_b_u_f_f_e_r_T_e_x_t_u_r_e, _g_l_:_f_r_a_m_e_b_u_f_f_e_r_T_e_x_t_u_r_e_1_D,
              _g_l_:_f_r_a_m_e_b_u_f_f_e_r_T_e_x_t_u_r_e_2_D, and _g_l_:_f_r_a_m_e_b_u_f_f_e_r_T_e_x_t_u_r_e attach a
              selected mipmap level or image of a texture object as one of the
              logical buffers of the framebuffer object currently bound to
              _T_a_r_g_e_t . _T_a_r_g_e_t must be _?_G_L___D_R_A_W___F_R_A_M_E_B_U_F_F_E_R,
              _?_G_L___R_E_A_D___F_R_A_M_E_B_U_F_F_E_R, or _?_G_L___F_R_A_M_E_B_U_F_F_E_R . _?_G_L___F_R_A_M_E_B_U_F_F_E_R is
              equivalent to _?_G_L___D_R_A_W___F_R_A_M_E_B_U_F_F_E_R.

              _A_t_t_a_c_h_m_e_n_t specifies the logical attachment of the framebuffer
              and must be _?_G_L___C_O_L_O_R___A_T_T_A_C_H_M_E_N_T _i, _?_G_L___D_E_P_T_H___A_T_T_A_C_H_M_E_N_T,
              _?_G_L___S_T_E_N_C_I_L___A_T_T_A_C_H_M_E_N_T or _?_G_L___D_E_P_T_H___S_T_E_N_C_I_L___A_T_T_A_C_H_M_M_E_N_T . _i in
              _?_G_L___C_O_L_O_R___A_T_T_A_C_H_M_E_N_T_i may range from zero to the value of
              _?_G_L___M_A_X___C_O_L_O_R___A_T_T_A_C_H_M_E_N_T_S - 1. Attaching a level of a texture to
              _?_G_L___D_E_P_T_H___S_T_E_N_C_I_L___A_T_T_A_C_H_M_E_N_T is equivalent to attaching that
              level to both the _?_G_L___D_E_P_T_H___A_T_T_A_C_H_M_E_N_T_a_n_d the
              _?_G_L___S_T_E_N_C_I_L___A_T_T_A_C_H_M_E_N_T attachment points simultaneously.

              _T_e_x_t_a_r_g_e_t specifies what type of texture is named by _T_e_x_t_u_r_e ,
              and for cube map textures, specifies the face that is to be
              attached. If _T_e_x_t_u_r_e is not zero, it must be the name of an
              existing texture with type _T_e_x_t_a_r_g_e_t , unless it is a cube map
              texture, in which case _T_e_x_t_a_r_g_e_t must be
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___P_O_S_I_T_I_V_E___X _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___N_E_G_A_T_I_V_E___X,
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___P_O_S_I_T_I_V_E___Y, _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___N_E_G_A_T_I_V_E___Y
              , _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___P_O_S_I_T_I_V_E___Z, or
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___N_E_G_A_T_I_V_E___Z.

              If _T_e_x_t_u_r_e is non-zero, the specified _L_e_v_e_l of the texture
              object named _T_e_x_t_u_r_e is attached to the framebfufer attachment
              point named by _A_t_t_a_c_h_m_e_n_t . For _g_l_:_f_r_a_m_e_b_u_f_f_e_r_T_e_x_t_u_r_e_1_D ,
              _g_l_:_f_r_a_m_e_b_u_f_f_e_r_T_e_x_t_u_r_e_2_D, and _g_l_:_f_r_a_m_e_b_u_f_f_e_r_T_e_x_t_u_r_e_3_D, _T_e_x_t_u_r_e
              must be zero or the name of an existing texture with a target of
              _T_e_x_t_a_r_g_e_t , or _T_e_x_t_u_r_e must be the name of an existing cube-map
              texture and _T_e_x_t_a_r_g_e_t must be one of
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___P_O_S_I_T_I_V_E___X ,
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___P_O_S_I_T_I_V_E___Y,
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___P_O_S_I_T_I_V_E___Z, _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___N_E_G_A_T_I_V_E___X
              , _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___N_E_G_A_T_I_V_E___Y, or
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___N_E_G_A_T_I_V_E___Z.

              If _T_e_x_t_a_r_g_e_t is _?_G_L___T_E_X_T_U_R_E___R_E_C_T_A_N_G_L_E,
              _?_G_L___T_E_X_T_U_R_E___2_D___M_U_L_T_I_S_A_M_P_L_E, or _?_G_L___T_E_X_T_U_R_E___2_D___M_U_L_T_I_S_A_M_P_L_E___A_R_R_A_Y,
              then _L_e_v_e_l must be zero. If _T_e_x_t_a_r_g_e_t is _?_G_L___T_E_X_T_U_R_E___3_D, then
              level must be greater than or equal to zero and less than or
              equal to log2 of the value of _?_G_L___M_A_X___3_D___T_E_X_T_U_R_E___S_I_Z_E. If
              _T_e_x_t_a_r_g_e_t is one of _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___P_O_S_I_T_I_V_E___X,
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___P_O_S_I_T_I_V_E___Y, _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___P_O_S_I_T_I_V_E___Z
              , _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___N_E_G_A_T_I_V_E___X,
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___N_E_G_A_T_I_V_E___Y, or
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___N_E_G_A_T_I_V_E___Z , then _L_e_v_e_l must be greater
              than or equal to zero and less than or equal to log2 of the
              value of _?_G_L___M_A_X___C_U_B_E___M_A_P___T_E_X_T_U_R_E___S_I_Z_E. For all other values of
              _T_e_x_t_a_r_g_e_t , _L_e_v_e_l must be greater than or equal to zero and no
              larger than log2 of the value of _?_G_L___M_A_X___T_E_X_T_U_R_E___S_I_Z_E.

              _L_a_y_e_r specifies the layer of a 2-dimensional image within a
              3-dimensional texture.

              For _g_l_:_f_r_a_m_e_b_u_f_f_e_r_T_e_x_t_u_r_e_1_D, if _T_e_x_t_u_r_e is not zero, then
              _T_e_x_t_a_r_g_e_t must be _?_G_L___T_E_X_T_U_R_E___1_D. For _g_l_:_f_r_a_m_e_b_u_f_f_e_r_T_e_x_t_u_r_e_2_D,
              if _T_e_x_t_u_r_e is not zero, _T_e_x_t_a_r_g_e_t must be one of _?_G_L___T_E_X_T_U_R_E___2_D,
              _?_G_L___T_E_X_T_U_R_E___R_E_C_T_A_N_G_L_E , _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___P_O_S_I_T_I_V_E___X,
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___P_O_S_I_T_I_V_E___Y, _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___P_O_S_I_T_I_V_E___Z
              , _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___N_E_G_A_T_I_V_E___X,
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___N_E_G_A_T_I_V_E___Y, _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___N_E_G_A_T_I_V_E___Z
              , or _?_G_L___T_E_X_T_U_R_E___2_D___M_U_L_T_I_S_A_M_P_L_E. For _g_l_:_f_r_a_m_e_b_u_f_f_e_r_T_e_x_t_u_r_e_3_D, if
              _T_e_x_t_u_r_e is not zero, then _T_e_x_t_a_r_g_e_t must be _?_G_L___T_E_X_T_U_R_E___3_D.

              See external documentation.

       vveerrtteexxAAttttrriibbDDiivviissoorr((IInnddeexx,, DDiivviissoorr)) -->> ookk

              Types:

                 Index = integer()
                 Divisor = integer()

              Modify the rate at which generic vertex attributes advance
              during instanced rendering

              _g_l_:_v_e_r_t_e_x_A_t_t_r_i_b_D_i_v_i_s_o_r modifies the rate at which generic vertex
              attributes advance when rendering multiple instances of
              primitives in a single draw call. If _D_i_v_i_s_o_r is zero, the
              attribute at slot _I_n_d_e_x advances once per vertex. If _D_i_v_i_s_o_r is
              non-zero, the attribute advances once per _D_i_v_i_s_o_r instances of
              the set(s) of vertices being rendered. An attribute is referred
              to as instanced if its _?_G_L___V_E_R_T_E_X___A_T_T_R_I_B___A_R_R_A_Y___D_I_V_I_S_O_R value is
              non-zero.

              _I_n_d_e_x must be less than the value of _?_G_L___M_A_X___V_E_R_T_E_X___A_T_T_R_I_B_U_T_E_S.

              See external documentation.

       mmiinnSSaammpplleeSShhaaddiinngg((VVaalluuee)) -->> ookk

              Types:

                 Value = clamp()

              Specifies minimum rate at which sample shaing takes place

              _g_l_:_m_i_n_S_a_m_p_l_e_S_h_a_d_i_n_g specifies the rate at which samples are
              shaded within a covered pixel. Sample-rate shading is enabled by
              calling ggll::eennaabbllee//11 with the parameter _?_G_L___S_A_M_P_L_E___S_H_A_D_I_N_G . If
              _?_G_L___M_U_L_T_I_S_A_M_P_L_E or _?_G_L___S_A_M_P_L_E___S_H_A_D_I_N_G is disabled, sample
              shading has no effect. Otherwise, an implementation must provide
              at least as many unique color values for each covered fragment
              as specified by _V_a_l_u_e times _S_a_m_p_l_e_s where _S_a_m_p_l_e_s is the value
              of _?_G_L___S_A_M_P_L_E_S for the current framebuffer. At least 1 sample
              for each covered fragment is generated.

              A _V_a_l_u_e of 1.0 indicates that each sample in the framebuffer
              should be indpendently shaded. A _V_a_l_u_e of 0.0 effectively allows
              the GL to ignore sample rate shading. Any value between 0.0 and
              1.0 allows the GL to shade only a subset of the total samples
              within each covered fragment. Which samples are shaded and the
              algorithm used to select that subset of the fragment's samples
              is implementation dependent.

              See external documentation.

       bblleennddEEqquuaattiioonnii((BBuuff,, MMooddee)) -->> ookk

              Types:

                 Buf = integer()
                 Mode = enum()

              See bblleennddEEqquuaattiioonn//11

       bblleennddEEqquuaattiioonnSSeeppaarraatteeii((BBuuff,, MMooddeeRRGGBB,, MMooddeeAAllpphhaa)) -->> ookk

              Types:

                 Buf = integer()
                 ModeRGB = enum()
                 ModeAlpha = enum()

              See bblleennddEEqquuaattiioonnSSeeppaarraattee//22

       bblleennddFFuunnccii((BBuuff,, SSrrcc,, DDsstt)) -->> ookk

              Types:

                 Buf = integer()
                 Src = enum()
                 Dst = enum()

              glBlendFunci

              See external documentation.

       bblleennddFFuunnccSSeeppaarraatteeii((BBuuff,, SSrrccRRGGBB,, DDssttRRGGBB,, SSrrccAAllpphhaa,, DDssttAAllpphhaa)) -->> ookk

              Types:

                 Buf = integer()
                 SrcRGB = enum()
                 DstRGB = enum()
                 SrcAlpha = enum()
                 DstAlpha = enum()

              See bblleennddFFuunnccSSeeppaarraattee//44

       llooaaddTTrraannssppoosseeMMaattrriixxffAARRBB((MM)) -->> ookk

              Types:

                 M = matrix()

              glLoadTransposeMatrixARB

              See external documentation.

       llooaaddTTrraannssppoosseeMMaattrriixxddAARRBB((MM)) -->> ookk

              Types:

                 M = matrix()

              glLoadTransposeMatrixARB

              See external documentation.

       mmuullttTTrraannssppoosseeMMaattrriixxffAARRBB((MM)) -->> ookk

              Types:

                 M = matrix()

              glMultTransposeMatrixARB

              See external documentation.

       mmuullttTTrraannssppoosseeMMaattrriixxddAARRBB((MM)) -->> ookk

              Types:

                 M = matrix()

              glMultTransposeMatrixARB

              See external documentation.

       wweeiigghhttbbvvAARRBB((WWeeiigghhttss)) -->> ookk

              Types:

                 Weights = [integer()]

              glWeightARB

              See external documentation.

       wweeiigghhttssvvAARRBB((WWeeiigghhttss)) -->> ookk

              Types:

                 Weights = [integer()]

              glWeightARB

              See external documentation.

       wweeiigghhttiivvAARRBB((WWeeiigghhttss)) -->> ookk

              Types:

                 Weights = [integer()]

              glWeightARB

              See external documentation.

       wweeiigghhttffvvAARRBB((WWeeiigghhttss)) -->> ookk

              Types:

                 Weights = [float()]

              glWeightARB

              See external documentation.

       wweeiigghhttddvvAARRBB((WWeeiigghhttss)) -->> ookk

              Types:

                 Weights = [float()]

              glWeightARB

              See external documentation.

       wweeiigghhttuubbvvAARRBB((WWeeiigghhttss)) -->> ookk

              Types:

                 Weights = [integer()]

              glWeightARB

              See external documentation.

       wweeiigghhttuussvvAARRBB((WWeeiigghhttss)) -->> ookk

              Types:

                 Weights = [integer()]

              glWeightARB

              See external documentation.

       wweeiigghhttuuiivvAARRBB((WWeeiigghhttss)) -->> ookk

              Types:

                 Weights = [integer()]

              glWeightARB

              See external documentation.

       vveerrtteexxBBlleennddAARRBB((CCoouunntt)) -->> ookk

              Types:

                 Count = integer()

              glVertexBlenARB

              See external documentation.

       ccuurrrreennttPPaalleetttteeMMaattrriixxAARRBB((IInnddeexx)) -->> ookk

              Types:

                 Index = integer()

              glCurrentPaletteMatrixARB

              See external documentation.

       mmaattrriixxIInnddeexxuubbvvAARRBB((IInnddiicceess)) -->> ookk

              Types:

                 Indices = [integer()]

              glMatrixIndexARB

              See external documentation.

       mmaattrriixxIInnddeexxuussvvAARRBB((IInnddiicceess)) -->> ookk

              Types:

                 Indices = [integer()]

              glMatrixIndexARB

              See external documentation.

       mmaattrriixxIInnddeexxuuiivvAARRBB((IInnddiicceess)) -->> ookk

              Types:

                 Indices = [integer()]

              glMatrixIndexARB

              See external documentation.

       pprrooggrraammSSttrriinnggAARRBB((TTaarrggeett,, FFoorrmmaatt,, SSttrriinngg)) -->> ookk

              Types:

                 Target = enum()
                 Format = enum()
                 String = string()

              glProgramStringARB

              See external documentation.

       bbiinnddPPrrooggrraammAARRBB((TTaarrggeett,, PPrrooggrraamm)) -->> ookk

              Types:

                 Target = enum()
                 Program = integer()

              glBindProgramARB

              See external documentation.

       ddeelleetteePPrrooggrraammssAARRBB((PPrrooggrraammss)) -->> ookk

              Types:

                 Programs = [integer()]

              glDeleteProgramsARB

              See external documentation.

       ggeennPPrrooggrraammssAARRBB((NN)) -->> [[iinntteeggeerr(())]]

              Types:

                 N = integer()

              glGenProgramsARB

              See external documentation.

       pprrooggrraammEEnnvvPPaarraammeetteerr44ddAARRBB((TTaarrggeett,, IInnddeexx,, XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 Target = enum()
                 Index = integer()
                 X = float()
                 Y = float()
                 Z = float()
                 W = float()

              glProgramEnvParameterARB

              See external documentation.

       pprrooggrraammEEnnvvPPaarraammeetteerr44ddvvAARRBB((TTaarrggeett,, IInnddeexx,, PPaarraammss)) -->> ookk

              Types:

                 Target = enum()
                 Index = integer()
                 Params = {float(), float(), float(), float()}

              glProgramEnvParameterARB

              See external documentation.

       pprrooggrraammEEnnvvPPaarraammeetteerr44ffAARRBB((TTaarrggeett,, IInnddeexx,, XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 Target = enum()
                 Index = integer()
                 X = float()
                 Y = float()
                 Z = float()
                 W = float()

              glProgramEnvParameterARB

              See external documentation.

       pprrooggrraammEEnnvvPPaarraammeetteerr44ffvvAARRBB((TTaarrggeett,, IInnddeexx,, PPaarraammss)) -->> ookk

              Types:

                 Target = enum()
                 Index = integer()
                 Params = {float(), float(), float(), float()}

              glProgramEnvParameterARB

              See external documentation.

       pprrooggrraammLLooccaallPPaarraammeetteerr44ddAARRBB((TTaarrggeett,, IInnddeexx,, XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 Target = enum()
                 Index = integer()
                 X = float()
                 Y = float()
                 Z = float()
                 W = float()

              glProgramLocalParameterARB

              See external documentation.

       pprrooggrraammLLooccaallPPaarraammeetteerr44ddvvAARRBB((TTaarrggeett,, IInnddeexx,, PPaarraammss)) -->> ookk

              Types:

                 Target = enum()
                 Index = integer()
                 Params = {float(), float(), float(), float()}

              glProgramLocalParameterARB

              See external documentation.

       pprrooggrraammLLooccaallPPaarraammeetteerr44ffAARRBB((TTaarrggeett,, IInnddeexx,, XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 Target = enum()
                 Index = integer()
                 X = float()
                 Y = float()
                 Z = float()
                 W = float()

              glProgramLocalParameterARB

              See external documentation.

       pprrooggrraammLLooccaallPPaarraammeetteerr44ffvvAARRBB((TTaarrggeett,, IInnddeexx,, PPaarraammss)) -->> ookk

              Types:

                 Target = enum()
                 Index = integer()
                 Params = {float(), float(), float(), float()}

              glProgramLocalParameterARB

              See external documentation.

       ggeettPPrrooggrraammEEnnvvPPaarraammeetteerrddvvAARRBB((TTaarrggeett,, IInnddeexx)) -->> {{ffllooaatt(()),, ffllooaatt(()),,
       ffllooaatt(()),, ffllooaatt(())}}

              Types:

                 Target = enum()
                 Index = integer()

              glGetProgramEnvParameterARB

              See external documentation.

       ggeettPPrrooggrraammEEnnvvPPaarraammeetteerrffvvAARRBB((TTaarrggeett,, IInnddeexx)) -->> {{ffllooaatt(()),, ffllooaatt(()),,
       ffllooaatt(()),, ffllooaatt(())}}

              Types:

                 Target = enum()
                 Index = integer()

              glGetProgramEnvParameterARB

              See external documentation.

       ggeettPPrrooggrraammLLooccaallPPaarraammeetteerrddvvAARRBB((TTaarrggeett,, IInnddeexx)) -->> {{ffllooaatt(()),, ffllooaatt(()),,
       ffllooaatt(()),, ffllooaatt(())}}

              Types:

                 Target = enum()
                 Index = integer()

              glGetProgramLocalParameterARB

              See external documentation.

       ggeettPPrrooggrraammLLooccaallPPaarraammeetteerrffvvAARRBB((TTaarrggeett,, IInnddeexx)) -->> {{ffllooaatt(()),, ffllooaatt(()),,
       ffllooaatt(()),, ffllooaatt(())}}

              Types:

                 Target = enum()
                 Index = integer()

              glGetProgramLocalParameterARB

              See external documentation.

       ggeettPPrrooggrraammSSttrriinnggAARRBB((TTaarrggeett,, PPnnaammee,, SSttrriinngg)) -->> ookk

              Types:

                 Target = enum()
                 Pname = enum()
                 String = mem()

              glGetProgramStringARB

              See external documentation.

       ggeettBBuuffffeerrPPaarraammeetteerriivvAARRBB((TTaarrggeett,, PPnnaammee)) -->> [[iinntteeggeerr(())]]

              Types:

                 Target = enum()
                 Pname = enum()

              glGetBufferParameterARB

              See external documentation.

       ddeelleetteeOObbjjeeccttAARRBB((OObbjj)) -->> ookk

              Types:

                 Obj = integer()

              glDeleteObjectARB

              See external documentation.

       ggeettHHaannddlleeAARRBB((PPnnaammee)) -->> iinntteeggeerr(())

              Types:

                 Pname = enum()

              glGetHandleARB

              See external documentation.

       ddeettaacchhOObbjjeeccttAARRBB((CCoonnttaaiinneerrOObbjj,, AAttttaacchheeddOObbjj)) -->> ookk

              Types:

                 ContainerObj = integer()
                 AttachedObj = integer()

              glDetachObjectARB

              See external documentation.

       ccrreeaatteeSShhaaddeerrOObbjjeeccttAARRBB((SShhaaddeerrTTyyppee)) -->> iinntteeggeerr(())

              Types:

                 ShaderType = enum()

              glCreateShaderObjectARB

              See external documentation.

       sshhaaddeerrSSoouurrcceeAARRBB((SShhaaddeerrOObbjj,, SSttrriinngg)) -->> ookk

              Types:

                 ShaderObj = integer()
                 String = [string()]

              glShaderSourceARB

              See external documentation.

       ccoommppiilleeSShhaaddeerrAARRBB((SShhaaddeerrOObbjj)) -->> ookk

              Types:

                 ShaderObj = integer()

              glCompileShaderARB

              See external documentation.

       ccrreeaatteePPrrooggrraammOObbjjeeccttAARRBB(()) -->> iinntteeggeerr(())

              glCreateProgramObjectARB

              See external documentation.

       aattttaacchhOObbjjeeccttAARRBB((CCoonnttaaiinneerrOObbjj,, OObbjj)) -->> ookk

              Types:

                 ContainerObj = integer()
                 Obj = integer()

              glAttachObjectARB

              See external documentation.

       lliinnkkPPrrooggrraammAARRBB((PPrrooggrraammOObbjj)) -->> ookk

              Types:

                 ProgramObj = integer()

              glLinkProgramARB

              See external documentation.

       uusseePPrrooggrraammOObbjjeeccttAARRBB((PPrrooggrraammOObbjj)) -->> ookk

              Types:

                 ProgramObj = integer()

              glUseProgramObjectARB

              See external documentation.

       vvaalliiddaatteePPrrooggrraammAARRBB((PPrrooggrraammOObbjj)) -->> ookk

              Types:

                 ProgramObj = integer()

              glValidateProgramARB

              See external documentation.

       ggeettOObbjjeeccttPPaarraammeetteerrffvvAARRBB((OObbjj,, PPnnaammee)) -->> ffllooaatt(())

              Types:

                 Obj = integer()
                 Pname = enum()

              glGetObjectParameterARB

              See external documentation.

       ggeettOObbjjeeccttPPaarraammeetteerriivvAARRBB((OObbjj,, PPnnaammee)) -->> iinntteeggeerr(())

              Types:

                 Obj = integer()
                 Pname = enum()

              glGetObjectParameterARB

              See external documentation.

       ggeettIInnffooLLooggAARRBB((OObbjj,, MMaaxxLLeennggtthh)) -->> ssttrriinngg(())

              Types:

                 Obj = integer()
                 MaxLength = integer()

              glGetInfoLogARB

              See external documentation.

       ggeettAAttttaacchheeddOObbjjeeccttssAARRBB((CCoonnttaaiinneerrOObbjj,, MMaaxxCCoouunntt)) -->> [[iinntteeggeerr(())]]

              Types:

                 ContainerObj = integer()
                 MaxCount = integer()

              glGetAttachedObjectsARB

              See external documentation.

       ggeettUUnniiffoorrmmLLooccaattiioonnAARRBB((PPrrooggrraammOObbjj,, NNaammee)) -->> iinntteeggeerr(())

              Types:

                 ProgramObj = integer()
                 Name = string()

              glGetUniformLocationARB

              See external documentation.

       ggeettAAccttiivveeUUnniiffoorrmmAARRBB((PPrrooggrraammOObbjj,, IInnddeexx,, MMaaxxLLeennggtthh)) -->> {{SSiizzee::::iinntteeggeerr(()),,
       TTyyppee::::eennuumm(()),, NNaammee::::ssttrriinngg(())}}

              Types:

                 ProgramObj = integer()
                 Index = integer()
                 MaxLength = integer()

              glGetActiveUniformARB

              See external documentation.

       ggeettUUnniiffoorrmmffvvAARRBB((PPrrooggrraammOObbjj,, LLooccaattiioonn)) -->> mmaattrriixx(())

              Types:

                 ProgramObj = integer()
                 Location = integer()

              glGetUniformARB

              See external documentation.

       ggeettUUnniiffoorrmmiivvAARRBB((PPrrooggrraammOObbjj,, LLooccaattiioonn)) -->> {{iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(()),, iinntteeggeerr(())}}

              Types:

                 ProgramObj = integer()
                 Location = integer()

              glGetUniformARB

              See external documentation.

       ggeettSShhaaddeerrSSoouurrcceeAARRBB((OObbjj,, MMaaxxLLeennggtthh)) -->> ssttrriinngg(())

              Types:

                 Obj = integer()
                 MaxLength = integer()

              glGetShaderSourceARB

              See external documentation.

       bbiinnddAAttttrriibbLLooccaattiioonnAARRBB((PPrrooggrraammOObbjj,, IInnddeexx,, NNaammee)) -->> ookk

              Types:

                 ProgramObj = integer()
                 Index = integer()
                 Name = string()

              glBindAttribLocationARB

              See external documentation.

       ggeettAAccttiivveeAAttttrriibbAARRBB((PPrrooggrraammOObbjj,, IInnddeexx,, MMaaxxLLeennggtthh)) -->> {{SSiizzee::::iinntteeggeerr(()),,
       TTyyppee::::eennuumm(()),, NNaammee::::ssttrriinngg(())}}

              Types:

                 ProgramObj = integer()
                 Index = integer()
                 MaxLength = integer()

              glGetActiveAttribARB

              See external documentation.

       ggeettAAttttrriibbLLooccaattiioonnAARRBB((PPrrooggrraammOObbjj,, NNaammee)) -->> iinntteeggeerr(())

              Types:

                 ProgramObj = integer()
                 Name = string()

              glGetAttribLocationARB

              See external documentation.

       iissRReennddeerrbbuuffffeerr((RReennddeerrbbuuffffeerr)) -->> 00 || 11

              Types:

                 Renderbuffer = integer()

              Determine if a name corresponds to a renderbuffer object

              _g_l_:_i_s_R_e_n_d_e_r_b_u_f_f_e_r returns _?_G_L___T_R_U_E if _R_e_n_d_e_r_b_u_f_f_e_r is currently
              the name of a renderbuffer object. If _R_e_n_d_e_r_b_u_f_f_e_r is zero, or
              if _R_e_n_d_e_r_b_u_f_f_e_r is not the name of a renderbuffer object, or if
              an error occurs, _g_l_:_i_s_R_e_n_d_e_r_b_u_f_f_e_r returns _?_G_L___F_A_L_S_E. If
              _R_e_n_d_e_r_b_u_f_f_e_r is a name returned by ggll::ggeennRReennddeerrbbuuffffeerrss//11 , by
              that has not yet been bound through a call to
              ggll::bbiinnddRReennddeerrbbuuffffeerr//22 or ggll::ffrraammeebbuuffffeerrRReennddeerrbbuuffffeerr//44 , then the
              name is not a renderbuffer object and _g_l_:_i_s_R_e_n_d_e_r_b_u_f_f_e_r returns
              _?_G_L___F_A_L_S_E .

              See external documentation.

       bbiinnddRReennddeerrbbuuffffeerr((TTaarrggeett,, RReennddeerrbbuuffffeerr)) -->> ookk

              Types:

                 Target = enum()
                 Renderbuffer = integer()

              Bind a renderbuffer to a renderbuffer target

              _g_l_:_b_i_n_d_R_e_n_d_e_r_b_u_f_f_e_r binds the renderbuffer object with name
              _R_e_n_d_e_r_b_u_f_f_e_r to the renderbuffer target specified by _T_a_r_g_e_t .
              _T_a_r_g_e_t must be _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R . _R_e_n_d_e_r_b_u_f_f_e_r is the name of a
              renderbuffer object previously returned from a call to
              ggll::ggeennRReennddeerrbbuuffffeerrss//11 , or zero to break the existing binding of
              a renderbuffer object to _T_a_r_g_e_t .

              See external documentation.

       ddeelleetteeRReennddeerrbbuuffffeerrss((RReennddeerrbbuuffffeerrss)) -->> ookk

              Types:

                 Renderbuffers = [integer()]

              Delete renderbuffer objects

              _g_l_:_d_e_l_e_t_e_R_e_n_d_e_r_b_u_f_f_e_r_s deletes the _N renderbuffer objects whose
              names are stored in the array addressed by _R_e_n_d_e_r_b_u_f_f_e_r_s . The
              name zero is reserved by the GL and is silently ignored, should
              it occur in _R_e_n_d_e_r_b_u_f_f_e_r_s , as are other unused names. Once a
              renderbuffer object is deleted, its name is again unused and it
              has no contents. If a renderbuffer that is currently bound to
              the target _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R is deleted, it is as though
              ggll::bbiinnddRReennddeerrbbuuffffeerr//22 had been executed with a _T_a_r_g_e_t of
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R and a _N_a_m_e of zero.

              If a renderbuffer object is attached to one or more attachment
              points in the currently bound framebuffer, then it as if
              ggll::ffrraammeebbuuffffeerrRReennddeerrbbuuffffeerr//44 had been called, with a
              _R_e_n_d_e_r_b_u_f_f_e_r of zero for each attachment point to which this
              image was attached in the currently bound framebuffer. In other
              words, this renderbuffer object is first detached from all
              attachment ponits in the currently bound framebuffer. Note that
              the renderbuffer image is specifically _n_o_t detached from any
              non-bound framebuffers.

              See external documentation.

       ggeennRReennddeerrbbuuffffeerrss((NN)) -->> [[iinntteeggeerr(())]]

              Types:

                 N = integer()

              Generate renderbuffer object names

              _g_l_:_g_e_n_R_e_n_d_e_r_b_u_f_f_e_r_s returns _N renderbuffer object names in
              _R_e_n_d_e_r_b_u_f_f_e_r_s . There is no guarantee that the names form a
              contiguous set of integers; however, it is guaranteed that none
              of the returned names was in use immediately before the call to
              _g_l_:_g_e_n_R_e_n_d_e_r_b_u_f_f_e_r_s .

              Renderbuffer object names returned by a call to
              _g_l_:_g_e_n_R_e_n_d_e_r_b_u_f_f_e_r_s are not returned by subsequent calls, unless
              they are first deleted with ggll::ddeelleetteeRReennddeerrbbuuffffeerrss//11 .

              The names returned in _R_e_n_d_e_r_b_u_f_f_e_r_s are marked as used, for the
              purposes of _g_l_:_g_e_n_R_e_n_d_e_r_b_u_f_f_e_r_s only, but they acquire state and
              type only when they are first bound.

              See external documentation.

       rreennddeerrbbuuffffeerrSSttoorraaggee((TTaarrggeett,, IInntteerrnnaallffoorrmmaatt,, WWiiddtthh,, HHeeiigghhtt)) -->> ookk

              Types:

                 Target = enum()
                 Internalformat = enum()
                 Width = integer()
                 Height = integer()

              Establish data storage, format and dimensions of a renderbuffer
              object's image

              _g_l_:_r_e_n_d_e_r_b_u_f_f_e_r_S_t_o_r_a_g_e is equivalent to calling
              ggll::rreennddeerrbbuuffffeerrSSttoorraaggeeMMuullttiissaammppllee//55 with the _S_a_m_p_l_e_s set to
              zero.

              The target of the operation, specified by _T_a_r_g_e_t must be
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R. _I_n_t_e_r_n_a_l_f_o_r_m_a_t specifies the internal format
              to be used for the renderbuffer object's storage and must be a
              color-renderable, depth-renderable, or stencil-renderable
              format. _W_i_d_t_h and _H_e_i_g_h_t are the dimensions, in pixels, of the
              renderbuffer. Both _W_i_d_t_h and _H_e_i_g_h_t must be less than or equal
              to the value of _?_G_L___M_A_X___R_E_N_D_E_R_B_U_F_F_E_R___S_I_Z_E .

              Upon success, _g_l_:_r_e_n_d_e_r_b_u_f_f_e_r_S_t_o_r_a_g_e deletes any existing data
              store for the renderbuffer image and the contents of the data
              store after calling _g_l_:_r_e_n_d_e_r_b_u_f_f_e_r_S_t_o_r_a_g_e are undefined.

              See external documentation.

       ggeettRReennddeerrbbuuffffeerrPPaarraammeetteerriivv((TTaarrggeett,, PPnnaammee)) -->> iinntteeggeerr(())

              Types:

                 Target = enum()
                 Pname = enum()

              Retrieve information about a bound renderbuffer object

              _g_l_:_g_e_t_R_e_n_d_e_r_b_u_f_f_e_r_P_a_r_a_m_e_t_e_r_i_v retrieves information about a
              bound renderbuffer object. _T_a_r_g_e_t specifies the target of the
              query operation and must be _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R . _P_n_a_m_e specifies
              the parameter whose value to query and must be one of
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___W_I_D_T_H , _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___H_E_I_G_H_T,
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___I_N_T_E_R_N_A_L___F_O_R_M_A_T, _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___R_E_D___S_I_Z_E ,
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___G_R_E_E_N___S_I_Z_E, _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___B_L_U_E___S_I_Z_E,
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___A_L_P_H_A___S_I_Z_E , _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___D_E_P_T_H___S_I_Z_E,
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___D_E_P_T_H___S_I_Z_E, _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___S_T_E_N_C_I_L___S_I_Z_E , or
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___S_A_M_P_L_E_S.

              Upon a successful return from _g_l_:_g_e_t_R_e_n_d_e_r_b_u_f_f_e_r_P_a_r_a_m_e_t_e_r_i_v, if
              _P_n_a_m_e is _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___W_I_D_T_H , _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___H_E_I_G_H_T,
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___I_N_T_E_R_N_A_L___F_O_R_M_A_T, or _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___S_A_M_P_L_E_S ,
              then _P_a_r_a_m_s will contain the width in pixels, the height in
              pixels, the internal format, or the number of samples,
              respectively, of the image of the renderbuffer currently bound
              to _T_a_r_g_e_t .

              If _P_n_a_m_e is _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___R_E_D___S_I_Z_E,
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___G_R_E_E_N___S_I_Z_E, _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___B_L_U_E___S_I_Z_E,
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___A_L_P_H_A___S_I_Z_E, _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___D_E_P_T_H___S_I_Z_E , or
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___S_T_E_N_C_I_L___S_I_Z_E, then _P_a_r_a_m_s will contain the
              actual resolutions (not the resolutions specified when the image
              array was defined) for the red, green, blue, alpha depth, or
              stencil components, respectively, of the image of the
              renderbuffer currently bound to _T_a_r_g_e_t .

              See external documentation.

       iissFFrraammeebbuuffffeerr((FFrraammeebbuuffffeerr)) -->> 00 || 11

              Types:

                 Framebuffer = integer()

              Determine if a name corresponds to a framebuffer object

              _g_l_:_i_s_F_r_a_m_e_b_u_f_f_e_r returns _?_G_L___T_R_U_E if _F_r_a_m_e_b_u_f_f_e_r is currently
              the name of a framebuffer object. If _F_r_a_m_e_b_u_f_f_e_r is zero, or if
              _?_f_r_a_m_e_b_u_f_f_e_r is not the name of a framebuffer object, or if an
              error occurs, _g_l_:_i_s_F_r_a_m_e_b_u_f_f_e_r returns _?_G_L___F_A_L_S_E. If _F_r_a_m_e_b_u_f_f_e_r
              is a name returned by ggll::ggeennFFrraammeebbuuffffeerrss//11 , by that has not yet
              been bound through a call to ggll::bbiinnddFFrraammeebbuuffffeerr//22 , then the
              name is not a framebuffer object and _g_l_:_i_s_F_r_a_m_e_b_u_f_f_e_r returns
              _?_G_L___F_A_L_S_E.

              See external documentation.

       bbiinnddFFrraammeebbuuffffeerr((TTaarrggeett,, FFrraammeebbuuffffeerr)) -->> ookk

              Types:

                 Target = enum()
                 Framebuffer = integer()

              Bind a framebuffer to a framebuffer target

              _g_l_:_b_i_n_d_F_r_a_m_e_b_u_f_f_e_r binds the framebuffer object with name
              _F_r_a_m_e_b_u_f_f_e_r to the framebuffer target specified by _T_a_r_g_e_t .
              _T_a_r_g_e_t must be either _?_G_L___D_R_A_W___F_R_A_M_E_B_U_F_F_E_R ,
              _?_G_L___R_E_A_D___F_R_A_M_E_B_U_F_F_E_R or _?_G_L___F_R_A_M_E_B_U_F_F_E_R. If a framebuffer object
              is bound to _?_G_L___D_R_A_W___F_R_A_M_E_B_U_F_F_E_R or _?_G_L___R_E_A_D___F_R_A_M_E_B_U_F_F_E_R, it
              becomes the target for rendering or readback operations,
              respectively, until it is deleted or another framebuffer is
              bound to the corresponding bind point. Calling
              _g_l_:_b_i_n_d_F_r_a_m_e_b_u_f_f_e_r with _T_a_r_g_e_t set to _?_G_L___F_R_A_M_E_B_U_F_F_E_R binds
              _F_r_a_m_e_b_u_f_f_e_r to both the read and draw framebuffer targets.
              _F_r_a_m_e_b_u_f_f_e_r is the name of a framebuffer object previously
              returned from a call to ggll::ggeennFFrraammeebbuuffffeerrss//11 , or zero to break
              the existing binding of a framebuffer object to _T_a_r_g_e_t .

              See external documentation.

       ddeelleetteeFFrraammeebbuuffffeerrss((FFrraammeebbuuffffeerrss)) -->> ookk

              Types:

                 Framebuffers = [integer()]

              Delete framebuffer objects

              _g_l_:_d_e_l_e_t_e_F_r_a_m_e_b_u_f_f_e_r_s deletes the _N framebuffer objects whose
              names are stored in the array addressed by _F_r_a_m_e_b_u_f_f_e_r_s . The
              name zero is reserved by the GL and is silently ignored, should
              it occur in _F_r_a_m_e_b_u_f_f_e_r_s , as are other unused names. Once a
              framebuffer object is deleted, its name is again unused and it
              has no attachments. If a framebuffer that is currently bound to
              one or more of the targets _?_G_L___D_R_A_W___F_R_A_M_E_B_U_F_F_E_R or
              _?_G_L___R_E_A_D___F_R_A_M_E_B_U_F_F_E_R is deleted, it is as though
              ggll::bbiinnddFFrraammeebbuuffffeerr//22 had been executed with the corresponding
              _T_a_r_g_e_t and _F_r_a_m_e_b_u_f_f_e_r zero.

              See external documentation.

       ggeennFFrraammeebbuuffffeerrss((NN)) -->> [[iinntteeggeerr(())]]

              Types:

                 N = integer()

              Generate framebuffer object names

              _g_l_:_g_e_n_F_r_a_m_e_b_u_f_f_e_r_s returns _N framebuffer object names in _I_d_s .
              There is no guarantee that the names form a contiguous set of
              integers; however, it is guaranteed that none of the returned
              names was in use immediately before the call to
              _g_l_:_g_e_n_F_r_a_m_e_b_u_f_f_e_r_s .

              Framebuffer object names returned by a call to
              _g_l_:_g_e_n_F_r_a_m_e_b_u_f_f_e_r_s are not returned by subsequent calls, unless
              they are first deleted with ggll::ddeelleetteeFFrraammeebbuuffffeerrss//11 .

              The names returned in _I_d_s are marked as used, for the purposes
              of _g_l_:_g_e_n_F_r_a_m_e_b_u_f_f_e_r_s only, but they acquire state and type only
              when they are first bound.

              See external documentation.

       cchheecckkFFrraammeebbuuffffeerrSSttaattuuss((TTaarrggeett)) -->> eennuumm(())

              Types:

                 Target = enum()

              Check the completeness status of a framebuffer

              _g_l_:_c_h_e_c_k_F_r_a_m_e_b_u_f_f_e_r_S_t_a_t_u_s queries the completeness status of the
              framebuffer object currently bound to _T_a_r_g_e_t . _T_a_r_g_e_t must be
              _?_G_L___D_R_A_W___F_R_A_M_E_B_U_F_F_E_R, _?_G_L___R_E_A_D___F_R_A_M_E_B_U_F_F_E_R or _?_G_L___F_R_A_M_E_B_U_F_F_E_R.
              _?_G_L___F_R_A_M_E_B_U_F_F_E_R is equivalent to _?_G_L___D_R_A_W___F_R_A_M_E_B_U_F_F_E_R .

              The return value is _?_G_L___F_R_A_M_E_B_U_F_F_E_R___C_O_M_P_L_E_T_E if the framebuffer
              bound to _T_a_r_g_e_t is complete. Otherwise, the return value is
              determined as follows:

              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___U_N_D_E_F_I_N_E_D is returned if _T_a_r_g_e_t is the default
              framebuffer, but the default framebuffer does not exist.

              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___I_N_C_O_M_P_L_E_T_E___A_T_T_A_C_H_M_E_N_T is returned if any of the
              framebuffer attachment points are framebuffer incomplete.

              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___I_N_C_O_M_P_L_E_T_E___M_I_S_S_I_N_G___A_T_T_A_C_H_M_E_N_T is returned if the
              framebuffer does not have at least one image attached to it.

              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___I_N_C_O_M_P_L_E_T_E___D_R_A_W___B_U_F_F_E_R is returned if the value
              of _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___O_B_J_E_C_T___T_Y_P_E is _?_G_L___N_O_N_E for any
              color attachment point(s) named by _?_G_L___D_R_A_W_B_U_F_F_E_R_i.

              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___I_N_C_O_M_P_L_E_T_E___R_E_A_D___B_U_F_F_E_R is returned if
              _?_G_L___R_E_A_D___B_U_F_F_E_R is not _?_G_L___N_O_N_E and the value of
              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___O_B_J_E_C_T___T_Y_P_E is _?_G_L___N_O_N_E for the color
              attachment point named by _?_G_L___R_E_A_D___B_U_F_F_E_R.

              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___U_N_S_U_P_P_O_R_T_E_D is returned if the combination of
              internal formats of the attached images violates an
              implementation-dependent set of restrictions.

              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___I_N_C_O_M_P_L_E_T_E___M_U_L_T_I_S_A_M_P_L_E is returned if the value
              of _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___S_A_M_P_L_E_S is not the same for all attached
              renderbuffers; if the value of _?_G_L___T_E_X_T_U_R_E___S_A_M_P_L_E_S is the not
              same for all attached textures; or, if the attached images are a
              mix of renderbuffers and textures, the value of
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R___S_A_M_P_L_E_S does not match the value of
              _?_G_L___T_E_X_T_U_R_E___S_A_M_P_L_E_S .

              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___I_N_C_O_M_P_L_E_T_E___M_U_L_T_I_S_A_M_P_L_E is also returned if the
              value of _?_G_L___T_E_X_T_U_R_E___F_I_X_E_D___S_A_M_P_L_E___L_O_C_A_T_I_O_N_S is not the same for
              all attached textures; or, if the attached images are a mix of
              renderbuffers and textures, the value of
              _?_G_L___T_E_X_T_U_R_E___F_I_X_E_D___S_A_M_P_L_E___L_O_C_A_T_I_O_N_S is not _?_G_L___T_R_U_E for all
              attached textures.

              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___I_N_C_O_M_P_L_E_T_E___L_A_Y_E_R___T_A_R_G_E_T_S is returned if any
              framebuffer attachment is layered, and any populated attachment
              is not layered, or if all populated color attachments are not
              from textures of the same target.

              Additionally, if an error occurs, zero is returned.

              See external documentation.

       ffrraammeebbuuffffeerrTTeexxttuurree11DD((TTaarrggeett,, AAttttaacchhmmeenntt,, TTeexxttaarrggeett,, TTeexxttuurree,, LLeevveell)) -->>
       ookk

              Types:

                 Target = enum()
                 Attachment = enum()
                 Textarget = enum()
                 Texture = integer()
                 Level = integer()

              See ffrraammeebbuuffffeerrTTeexxttuurree//44

       ffrraammeebbuuffffeerrTTeexxttuurree22DD((TTaarrggeett,, AAttttaacchhmmeenntt,, TTeexxttaarrggeett,, TTeexxttuurree,, LLeevveell)) -->>
       ookk

              Types:

                 Target = enum()
                 Attachment = enum()
                 Textarget = enum()
                 Texture = integer()
                 Level = integer()

              See ffrraammeebbuuffffeerrTTeexxttuurree//44

       ffrraammeebbuuffffeerrTTeexxttuurree33DD((TTaarrggeett,, AAttttaacchhmmeenntt,, TTeexxttaarrggeett,, TTeexxttuurree,, LLeevveell,,
       ZZooffffsseett)) -->> ookk

              Types:

                 Target = enum()
                 Attachment = enum()
                 Textarget = enum()
                 Texture = integer()
                 Level = integer()
                 Zoffset = integer()

              See ffrraammeebbuuffffeerrTTeexxttuurree//44

       ffrraammeebbuuffffeerrRReennddeerrbbuuffffeerr((TTaarrggeett,, AAttttaacchhmmeenntt,, RReennddeerrbbuuffffeerrttaarrggeett,,
       RReennddeerrbbuuffffeerr)) -->> ookk

              Types:

                 Target = enum()
                 Attachment = enum()
                 Renderbuffertarget = enum()
                 Renderbuffer = integer()

              Attach a renderbuffer as a logical buffer to the currently bound
              framebuffer object

              _g_l_:_f_r_a_m_e_b_u_f_f_e_r_R_e_n_d_e_r_b_u_f_f_e_r attaches a renderbuffer as one of the
              logical buffers of the currently bound framebuffer object.
              _R_e_n_d_e_r_b_u_f_f_e_r is the name of the renderbuffer object to attach
              and must be either zero, or the name of an existing renderbuffer
              object of type _R_e_n_d_e_r_b_u_f_f_e_r_t_a_r_g_e_t . If _R_e_n_d_e_r_b_u_f_f_e_r is not zero
              and if _g_l_:_f_r_a_m_e_b_u_f_f_e_r_R_e_n_d_e_r_b_u_f_f_e_r is successful, then the
              renderbuffer name _R_e_n_d_e_r_b_u_f_f_e_r will be used as the logical
              buffer identified by _A_t_t_a_c_h_m_e_n_t of the framebuffer currently
              bound to _T_a_r_g_e_t .

              The value of _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___O_B_J_E_C_T___T_Y_P_E for the
              specified attachment point is set to _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R and the
              value of _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___O_B_J_E_C_T___N_A_M_E is set to
              _R_e_n_d_e_r_b_u_f_f_e_r . All other state values of the attachment point
              specified by _A_t_t_a_c_h_m_e_n_t are set to their default values. No
              change is made to the state of the renderbuuffer object and any
              previous attachment to the _A_t_t_a_c_h_m_e_n_t logical buffer of the
              framebuffer _T_a_r_g_e_t is broken.

              Calling _g_l_:_f_r_a_m_e_b_u_f_f_e_r_R_e_n_d_e_r_b_u_f_f_e_r with the renderbuffer name
              zero will detach the image, if any, identified by _A_t_t_a_c_h_m_e_n_t ,
              in the framebuffer currently bound to _T_a_r_g_e_t . All state values
              of the attachment point specified by attachment in the object
              bound to target are set to their default values.

              Setting _A_t_t_a_c_h_m_e_n_t to the value _?_G_L___D_E_P_T_H___S_T_E_N_C_I_L___A_T_T_A_C_H_M_E_N_T is
              a special case causing both the depth and stencil attachments of
              the framebuffer object to be set to _R_e_n_d_e_r_b_u_f_f_e_r , which should
              have the base internal format _?_G_L___D_E_P_T_H___S_T_E_N_C_I_L .

              See external documentation.

       ggeettFFrraammeebbuuffffeerrAAttttaacchhmmeennttPPaarraammeetteerriivv((TTaarrggeett,, AAttttaacchhmmeenntt,, PPnnaammee)) -->>
       iinntteeggeerr(())

              Types:

                 Target = enum()
                 Attachment = enum()
                 Pname = enum()

              Retrieve information about attachments of a bound framebuffer
              object

              _g_l_:_g_e_t_F_r_a_m_e_b_u_f_f_e_r_A_t_t_a_c_h_m_e_n_t_P_a_r_a_m_e_t_e_r returns information about
              attachments of a bound framebuffer object. _T_a_r_g_e_t specifies the
              framebuffer binding point and must be _?_G_L___D_R_A_W___F_R_A_M_E_B_U_F_F_E_R,
              _?_G_L___R_E_A_D___F_R_A_M_E_B_U_F_F_E_R or _?_G_L___F_R_A_M_E_B_U_F_F_E_R. _?_G_L___F_R_A_M_E_B_U_F_F_E_R is
              equivalent to _?_G_L___D_R_A_W___F_R_A_M_E_B_U_F_F_E_R.

              If the default framebuffer is bound to _T_a_r_g_e_t then _A_t_t_a_c_h_m_e_n_t
              must be one of _?_G_L___F_R_O_N_T___L_E_F_T, _?_G_L___F_R_O_N_T___R_I_G_H_T, _?_G_L___B_A_C_K___L_E_F_T,
              or _?_G_L___B_A_C_K___R_I_G_H_T , identifying a color buffer, _?_G_L___D_E_P_T_H,
              identifying the depth buffer, or _?_G_L___S_T_E_N_C_I_L , identifying the
              stencil buffer.

              If a framebuffer object is bound, then _A_t_t_a_c_h_m_e_n_t must be one of
              _?_G_L___C_O_L_O_R___A_T_T_A_C_H_M_E_N_T _i, _?_G_L___D_E_P_T_H___A_T_T_A_C_H_M_E_N_T,
              _?_G_L___S_T_E_N_C_I_L___A_T_T_A_C_H_M_E_N_T, or _?_G_L___D_E_P_T_H___S_T_E_N_C_I_L___A_T_T_A_C_H_M_E_N_T . _i in
              _?_G_L___C_O_L_O_R___A_T_T_A_C_H_M_E_N_T_i must be in the range zero to the value of
              _?_G_L___M_A_X___C_O_L_O_R___A_T_T_A_C_H_M_E_N_T_S - 1.

              If _A_t_t_a_c_h_m_e_n_t is _?_G_L___D_E_P_T_H___S_T_E_N_C_I_L___A_T_T_A_C_H_M_E_N_T and different
              objects are bound to the depth and stencil attachment points of
              _T_a_r_g_e_t the query will fail. If the same object is bound to both
              attachment points, information about that object will be
              returned.

              Upon successful return from
              _g_l_:_g_e_t_F_r_a_m_e_b_u_f_f_e_r_A_t_t_a_c_h_m_e_n_t_P_a_r_a_m_e_t_e_r_i_v, if _P_n_a_m_e is
              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___O_B_J_E_C_T___T_Y_P_E, then _P_a_r_a_m_s will contain
              one of _?_G_L___N_O_N_E , _?_G_L___F_R_A_M_E_B_U_F_F_E_R___D_E_F_A_U_L_T, _?_G_L___T_E_X_T_U_R_E, or
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R, identifying the type of object which contains
              the attached image. Other values accepted for _P_n_a_m_e depend on
              the type of object, as described below.

              If the value of _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___O_B_J_E_C_T___T_Y_P_E is
              _?_G_L___N_O_N_E, no framebuffer is bound to _T_a_r_g_e_t . In this case
              querying _P_n_a_m_e _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___O_B_J_E_C_T___N_A_M_E will
              return zero, and all other queries will generate an error.

              If the value of _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___O_B_J_E_C_T___T_Y_P_E is not
              _?_G_L___N_O_N_E, these queries apply to all other framebuffer types:

              If _P_n_a_m_e is _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___R_E_D___S_I_Z_E,
              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___G_R_E_E_N___S_I_Z_E ,
              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___B_L_U_E___S_I_Z_E,
              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___A_L_P_H_A___S_I_Z_E ,
              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___D_E_P_T_H___S_I_Z_E, or
              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___S_T_E_N_C_I_L___S_I_Z_E , then _P_a_r_a_m_s will
              contain the number of bits in the corresponding red, green,
              blue, alpha, depth, or stencil component of the specified
              attachment. Zero is returned if the requested component is not
              present in _A_t_t_a_c_h_m_e_n_t .

              If _P_n_a_m_e is _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___C_O_M_P_O_N_E_N_T___T_Y_P_E, _P_a_r_a_m_s
              will contain the format of components of the specified
              attachment, one of _?_G_L___F_L_O_A_T, _G_L___I_N_T , _G_L___U_N_S_I_G_N_E_D___I_N_T ,
              _G_L___S_I_G_N_E_D___N_O_R_M_A_L_I_Z_E_D , or _G_L___U_N_S_I_G_N_E_D___N_O_R_M_A_L_I_Z_E_D for floating-
              point, signed integer, unsigned integer, signed normalized
              fixed-point, or unsigned normalized fixed-point components
              respectively. Only color buffers may have integer components.

              If _P_n_a_m_e is _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___C_O_L_O_R___E_N_C_O_D_I_N_G, _P_a_r_a_m
              will contain the encoding of components of the specified
              attachment, one of _?_G_L___L_I_N_E_A_R or _?_G_L___S_R_G_B for linear or sRGB-
              encoded components, respectively. Only color buffer components
              may be sRGB-encoded; such components are treated as described in
              sections 4.1.7 and 4.1.8. For the default framebuffer, color
              encoding is determined by the implementation. For framebuffer
              objects, components are sRGB-encoded if the internal format of a
              color attachment is one of the color-renderable SRGB formats.

              If the value of _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___O_B_J_E_C_T___T_Y_P_E is
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R, then:

              If _P_n_a_m_e is _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___O_B_J_E_C_T___N_A_M_E, _P_a_r_a_m_s will
              contain the name of the renderbuffer object which contains the
              attached image.

              If the value of _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___O_B_J_E_C_T___T_Y_P_E is
              _?_G_L___T_E_X_T_U_R_E, then:

              If _P_n_a_m_e is _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___O_B_J_E_C_T___N_A_M_E, then _P_a_r_a_m_s
              will contain the name of the texture object which contains the
              attached image.

              If _P_n_a_m_e is _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___T_E_X_T_U_R_E___L_E_V_E_L, then
              _P_a_r_a_m_s will contain the mipmap level of the texture object which
              contains the attached image.

              If _P_n_a_m_e is _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___T_E_X_T_U_R_E___C_U_B_E___M_A_P___F_A_C_E and
              the texture object named _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___O_B_J_E_C_T___N_A_M_E
              is a cube map texture, then _P_a_r_a_m_s will contain the cube map
              face of the cubemap texture object which contains the attached
              image. Otherwise _P_a_r_a_m_s will contain the value zero.

              If _P_n_a_m_e is _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___T_E_X_T_U_R_E___L_A_Y_E_R and the
              texture object named _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___O_B_J_E_C_T___N_A_M_E is a
              layer of a three-dimensional texture or a one-or two-dimensional
              array texture, then _P_a_r_a_m_s will contain the number of the
              texture layer which contains the attached image. Otherwise
              _P_a_r_a_m_s will contain the value zero.

              If _P_n_a_m_e is _?_G_L___F_R_A_M_E_B_U_F_F_E_R___A_T_T_A_C_H_M_E_N_T___L_A_Y_E_R_E_D, then _P_a_r_a_m_s will
              contain _?_G_L___T_R_U_E if an entire level of a three-dimesional
              texture, cube map texture, or one-or two-dimensional array
              texture is attached. Otherwise, _P_a_r_a_m_s will contain _?_G_L___F_A_L_S_E.

              Any combinations of framebuffer type and _P_n_a_m_e not described
              above will generate an error.

              See external documentation.

       ggeenneerraatteeMMiippmmaapp((TTaarrggeett)) -->> ookk

              Types:

                 Target = enum()

              Generate mipmaps for a specified texture target

              _g_l_:_g_e_n_e_r_a_t_e_M_i_p_m_a_p generates mipmaps for the texture attached to
              _T_a_r_g_e_t of the active texture unit. For cube map textures, a
              _?_G_L___I_N_V_A_L_I_D___O_P_E_R_A_T_I_O_N error is generated if the texture attached
              to _T_a_r_g_e_t is not cube complete.

              Mipmap generation replaces texel array levels level base+1
              through q with arrays derived from the level base array,
              regardless of their previous contents. All other mimap arrays,
              including the level base array, are left unchanged by this
              computation.

              The internal formats of the derived mipmap arrays all match
              those of the level base array. The contents of the derived
              arrays are computed by repeated, filtered reduction of the level
              base array. For one- and two-dimensional texture arrays, each
              layer is filtered independently.

              See external documentation.

       bblliittFFrraammeebbuuffffeerr((SSrrccXX00,, SSrrccYY00,, SSrrccXX11,, SSrrccYY11,, DDssttXX00,, DDssttYY00,, DDssttXX11,, DDssttYY11,,
       MMaasskk,, FFiilltteerr)) -->> ookk

              Types:

                 SrcX0 = integer()
                 SrcY0 = integer()
                 SrcX1 = integer()
                 SrcY1 = integer()
                 DstX0 = integer()
                 DstY0 = integer()
                 DstX1 = integer()
                 DstY1 = integer()
                 Mask = integer()
                 Filter = enum()

              Copy a block of pixels from the read framebuffer to the draw
              framebuffer

              _g_l_:_b_l_i_t_F_r_a_m_e_b_u_f_f_e_r transfers a rectangle of pixel values from
              one region of the read framebuffer to another region in the draw
              framebuffer. _M_a_s_k is the bitwise OR of a number of values
              indicating which buffers are to be copied. The values are
              _?_G_L___C_O_L_O_R___B_U_F_F_E_R___B_I_T , _?_G_L___D_E_P_T_H___B_U_F_F_E_R___B_I_T, and
              _?_G_L___S_T_E_N_C_I_L___B_U_F_F_E_R___B_I_T. The pixels corresponding to these
              buffers are copied from the source rectangle bounded by the
              locations ( _S_r_c_X_0 ; _S_r_c_Y_0 ) and ( _S_r_c_X_1 ; _S_r_c_Y_1 ) to the
              destination rectangle bounded by the locations ( _D_s_t_X_0 ; _D_s_t_Y_0 )
              and ( _D_s_t_X_1 ; _D_s_t_Y_1 ). The lower bounds of the rectangle are
              inclusive, while the upper bounds are exclusive.

              The actual region taken from the read framebuffer is limited to
              the intersection of the source buffers being transferred, which
              may include the color buffer selected by the read buffer, the
              depth buffer, and/or the stencil buffer depending on mask. The
              actual region written to the draw framebuffer is limited to the
              intersection of the destination buffers being written, which may
              include multiple draw buffers, the depth buffer, and/or the
              stencil buffer depending on mask. Whether or not the source or
              destination regions are altered due to these limits, the scaling
              and offset applied to pixels being transferred is performed as
              though no such limits were present.

              If the sizes of the source and destination rectangles are not
              equal, _F_i_l_t_e_r specifies the interpolation method that will be
              applied to resize the source image , and must be _?_G_L___N_E_A_R_E_S_T or
              _?_G_L___L_I_N_E_A_R. _?_G_L___L_I_N_E_A_R is only a valid interpolation method for
              the color buffer. If _F_i_l_t_e_r is not _?_G_L___N_E_A_R_E_S_T and _M_a_s_k includes
              _?_G_L___D_E_P_T_H___B_U_F_F_E_R___B_I_T or _?_G_L___S_T_E_N_C_I_L___B_U_F_F_E_R___B_I_T, no data is
              transferred and a _?_G_L___I_N_V_A_L_I_D___O_P_E_R_A_T_I_O_N error is generated.

              If _F_i_l_t_e_r is _?_G_L___L_I_N_E_A_R and the source rectangle would require
              sampling outside the bounds of the source framebuffer, values
              are read as if the _?_G_L___C_L_A_M_P___T_O___E_D_G_E texture wrapping mode were
              applied.

              When the color buffer is transferred, values are taken from the
              read buffer of the read framebuffer and written to each of the
              draw buffers of the draw framebuffer.

              If the source and destination rectangles overlap or are the
              same, and the read and draw buffers are the same, the result of
              the operation is undefined.

              See external documentation.

       rreennddeerrbbuuffffeerrSSttoorraaggeeMMuullttiissaammppllee((TTaarrggeett,, SSaammpplleess,, IInntteerrnnaallffoorrmmaatt,, WWiiddtthh,,
       HHeeiigghhtt)) -->> ookk

              Types:

                 Target = enum()
                 Samples = integer()
                 Internalformat = enum()
                 Width = integer()
                 Height = integer()

              Establish data storage, format, dimensions and sample count of a
              renderbuffer object's image

              _g_l_:_r_e_n_d_e_r_b_u_f_f_e_r_S_t_o_r_a_g_e_M_u_l_t_i_s_a_m_p_l_e establishes the data storage,
              format, dimensions and number of samples of a renderbuffer
              object's image.

              The target of the operation, specified by _T_a_r_g_e_t must be
              _?_G_L___R_E_N_D_E_R_B_U_F_F_E_R. _I_n_t_e_r_n_a_l_f_o_r_m_a_t specifies the internal format
              to be used for the renderbuffer object's storage and must be a
              color-renderable, depth-renderable, or stencil-renderable
              format. _W_i_d_t_h and _H_e_i_g_h_t are the dimensions, in pixels, of the
              renderbuffer. Both _W_i_d_t_h and _H_e_i_g_h_t must be less than or equal
              to the value of _?_G_L___M_A_X___R_E_N_D_E_R_B_U_F_F_E_R___S_I_Z_E . _S_a_m_p_l_e_s specifies
              the number of samples to be used for the renderbuffer object's
              image, and must be less than or equal to the value of
              _?_G_L___M_A_X___S_A_M_P_L_E_S. If _I_n_t_e_r_n_a_l_f_o_r_m_a_t is a signed or unsigned
              integer format then _S_a_m_p_l_e_s must be less than or equal to the
              value of _?_G_L___M_A_X___I_N_T_E_G_E_R___S_A_M_P_L_E_S.

              Upon success, _g_l_:_r_e_n_d_e_r_b_u_f_f_e_r_S_t_o_r_a_g_e_M_u_l_t_i_s_a_m_p_l_e deletes any
              existing data store for the renderbuffer image and the contents
              of the data store after calling
              _g_l_:_r_e_n_d_e_r_b_u_f_f_e_r_S_t_o_r_a_g_e_M_u_l_t_i_s_a_m_p_l_e are undefined.

              See external documentation.

       ffrraammeebbuuffffeerrTTeexxttuurreeLLaayyeerr((TTaarrggeett,, AAttttaacchhmmeenntt,, TTeexxttuurree,, LLeevveell,, LLaayyeerr)) -->>
       ookk

              Types:

                 Target = enum()
                 Attachment = enum()
                 Texture = integer()
                 Level = integer()
                 Layer = integer()

              See ffrraammeebbuuffffeerrTTeexxttuurree//44

       ffrraammeebbuuffffeerrTTeexxttuurreeFFaacceeAARRBB((TTaarrggeett,, AAttttaacchhmmeenntt,, TTeexxttuurree,, LLeevveell,, FFaaccee)) -->>
       ookk

              Types:

                 Target = enum()
                 Attachment = enum()
                 Texture = integer()
                 Level = integer()
                 Face = enum()

              See ffrraammeebbuuffffeerrTTeexxttuurree//44

       fflluusshhMMaappppeeddBBuuffffeerrRRaannggee((TTaarrggeett,, OOffffsseett,, LLeennggtthh)) -->> ookk

              Types:

                 Target = enum()
                 Offset = integer()
                 Length = integer()

              Indicate modifications to a range of a mapped buffer

              _g_l_:_f_l_u_s_h_M_a_p_p_e_d_B_u_f_f_e_r_R_a_n_g_e indicates that modifications have been
              made to a range of a mapped buffer. The buffer must previously
              have been mapped with the _?_G_L___M_A_P___F_L_U_S_H___E_X_P_L_I_C_I_T flag. _O_f_f_s_e_t
              and _L_e_n_g_t_h indicate the modified subrange of the mapping, in
              basic units. The specified subrange to flush is relative to the
              start of the currently mapped range of the buffer.
              _g_l_:_f_l_u_s_h_M_a_p_p_e_d_B_u_f_f_e_r_R_a_n_g_e may be called multiple times to
              indicate distinct subranges of the mapping which require
              flushing.

              See external documentation.

       bbiinnddVVeerrtteexxAArrrraayy((AArrrraayy)) -->> ookk

              Types:

                 Array = integer()

              Bind a vertex array object

              _g_l_:_b_i_n_d_V_e_r_t_e_x_A_r_r_a_y binds the vertex array object with name _A_r_r_a_y
              . _A_r_r_a_y is the name of a vertex array object previously returned
              from a call to ggll::ggeennVVeerrtteexxAArrrraayyss//11 , or zero to break the
              existing vertex array object binding.

              If no vertex array object with name _A_r_r_a_y exists, one is created
              when _A_r_r_a_y is first bound. If the bind is successful no change
              is made to the state of the vertex array object, and any
              previous vertex array object binding is broken.

              See external documentation.

       ddeelleetteeVVeerrtteexxAArrrraayyss((AArrrraayyss)) -->> ookk

              Types:

                 Arrays = [integer()]

              Delete vertex array objects

              _g_l_:_d_e_l_e_t_e_V_e_r_t_e_x_A_r_r_a_y_s deletes _N vertex array objects whose names
              are stored in the array addressed by _A_r_r_a_y_s . Once a vertex
              array object is deleted it has no contents and its name is again
              unused. If a vertex array object that is currently bound is
              deleted, the binding for that object reverts to zero and the
              default vertex array becomes current. Unused names in _A_r_r_a_y_s are
              silently ignored, as is the value zero.

              See external documentation.

       ggeennVVeerrtteexxAArrrraayyss((NN)) -->> [[iinntteeggeerr(())]]

              Types:

                 N = integer()

              Generate vertex array object names

              _g_l_:_g_e_n_V_e_r_t_e_x_A_r_r_a_y_s returns _N vertex array object names in _A_r_r_a_y_s
              . There is no guarantee that the names form a contiguous set of
              integers; however, it is guaranteed that none of the returned
              names was in use immediately before the call to
              _g_l_:_g_e_n_V_e_r_t_e_x_A_r_r_a_y_s .

              Vertex array object names returned by a call to
              _g_l_:_g_e_n_V_e_r_t_e_x_A_r_r_a_y_s are not returned by subsequent calls, unless
              they are first deleted with ggll::ddeelleetteeVVeerrtteexxAArrrraayyss//11 .

              The names returned in _A_r_r_a_y_s are marked as used, for the
              purposes of _g_l_:_g_e_n_V_e_r_t_e_x_A_r_r_a_y_s only, but they acquire state and
              type only when they are first bound.

              See external documentation.

       iissVVeerrtteexxAArrrraayy((AArrrraayy)) -->> 00 || 11

              Types:

                 Array = integer()

              Determine if a name corresponds to a vertex array object

              _g_l_:_i_s_V_e_r_t_e_x_A_r_r_a_y returns _?_G_L___T_R_U_E if _A_r_r_a_y is currently the name
              of a renderbuffer object. If _R_e_n_d_e_r_b_u_f_f_e_r is zero, or if _A_r_r_a_y
              is not the name of a renderbuffer object, or if an error occurs,
              _g_l_:_i_s_V_e_r_t_e_x_A_r_r_a_y returns _?_G_L___F_A_L_S_E . If _A_r_r_a_y is a name returned
              by ggll::ggeennVVeerrtteexxAArrrraayyss//11 , by that has not yet been bound through
              a call to ggll::bbiinnddVVeerrtteexxAArrrraayy//11 , then the name is not a vertex
              array object and _g_l_:_i_s_V_e_r_t_e_x_A_r_r_a_y returns _?_G_L___F_A_L_S_E.

              See external documentation.

       ggeettUUnniiffoorrmmIInnddiicceess((PPrrooggrraamm,, UUnniiffoorrmmNNaammeess)) -->> [[iinntteeggeerr(())]]

              Types:

                 Program = integer()
                 UniformNames = [string()]

              Retrieve the index of a named uniform block

              _g_l_:_g_e_t_U_n_i_f_o_r_m_I_n_d_i_c_e_s retrieves the indices of a number of
              uniforms within _P_r_o_g_r_a_m .

              _P_r_o_g_r_a_m must be the name of a program object for which the
              command ggll::lliinnkkPPrrooggrraamm//11 must have been called in the past,
              although it is not required that ggll::lliinnkkPPrrooggrraamm//11 must have
              succeeded. The link could have failed because the number of
              active uniforms exceeded the limit.

              _U_n_i_f_o_r_m_C_o_u_n_t indicates both the number of elements in the array
              of names _U_n_i_f_o_r_m_N_a_m_e_s and the number of indices that may be
              written to _U_n_i_f_o_r_m_I_n_d_i_c_e_s .

              _U_n_i_f_o_r_m_N_a_m_e_s contains a list of _U_n_i_f_o_r_m_C_o_u_n_t name strings
              identifying the uniform names to be queried for indices. For
              each name string in _U_n_i_f_o_r_m_N_a_m_e_s , the index assigned to the
              active uniform of that name will be written to the corresponding
              element of _U_n_i_f_o_r_m_I_n_d_i_c_e_s . If a string in _U_n_i_f_o_r_m_N_a_m_e_s is not
              the name of an active uniform, the special value
              _?_G_L___I_N_V_A_L_I_D___I_N_D_E_X will be written to the corresponding element
              of _U_n_i_f_o_r_m_I_n_d_i_c_e_s .

              If an error occurs, nothing is written to _U_n_i_f_o_r_m_I_n_d_i_c_e_s .

              See external documentation.

       ggeettAAccttiivveeUUnniiffoorrmmssiivv((PPrrooggrraamm,, UUnniiffoorrmmIInnddiicceess,, PPnnaammee)) -->> [[iinntteeggeerr(())]]

              Types:

                 Program = integer()
                 UniformIndices = [integer()]
                 Pname = enum()

              glGetActiveUniforms

              See external documentation.

       ggeettAAccttiivveeUUnniiffoorrmmNNaammee((PPrrooggrraamm,, UUnniiffoorrmmIInnddeexx,, BBuuffSSiizzee)) -->> ssttrriinngg(())

              Types:

                 Program = integer()
                 UniformIndex = integer()
                 BufSize = integer()

              Query the name of an active uniform

              _g_l_:_g_e_t_A_c_t_i_v_e_U_n_i_f_o_r_m_N_a_m_e returns the name of the active uniform
              at _U_n_i_f_o_r_m_I_n_d_e_x within _P_r_o_g_r_a_m . If _U_n_i_f_o_r_m_N_a_m_e is not NULL, up
              to _B_u_f_S_i_z_e characters (including a nul-terminator) will be
              written into the array whose address is specified by _U_n_i_f_o_r_m_N_a_m_e
              . If _L_e_n_g_t_h is not NULL, the number of characters that were (or
              would have been) written into _U_n_i_f_o_r_m_N_a_m_e (not including the
              nul-terminator) will be placed in the variable whose address is
              specified in _L_e_n_g_t_h . If _L_e_n_g_t_h is NULL, no length is returned.
              The length of the longest uniform name in _P_r_o_g_r_a_m is given by
              the value of _?_G_L___A_C_T_I_V_E___U_N_I_F_O_R_M___M_A_X___L_E_N_G_T_H, which can be queried
              with ggll::ggeettPPrrooggrraammiivv//22 .

              If _g_l_:_g_e_t_A_c_t_i_v_e_U_n_i_f_o_r_m_N_a_m_e is not successful, nothing is written
              to _L_e_n_g_t_h or _U_n_i_f_o_r_m_N_a_m_e .

              _P_r_o_g_r_a_m must be the name of a program for which the command
              ggll::lliinnkkPPrrooggrraamm//11 has been issued in the past. It is not
              necessary for _P_r_o_g_r_a_m to have been linked successfully. The link
              could have failed because the number of active uniforms exceeded
              the limit.

              _U_n_i_f_o_r_m_I_n_d_e_x must be an active uniform index of the program
              _P_r_o_g_r_a_m , in the range zero to _?_G_L___A_C_T_I_V_E___U_N_I_F_O_R_M_S - 1. The
              value of _?_G_L___A_C_T_I_V_E___U_N_I_F_O_R_M_S can be queried with
              ggll::ggeettPPrrooggrraammiivv//22 .

              See external documentation.

       ggeettUUnniiffoorrmmBBlloocckkIInnddeexx((PPrrooggrraamm,, UUnniiffoorrmmBBlloocckkNNaammee)) -->> iinntteeggeerr(())

              Types:

                 Program = integer()
                 UniformBlockName = string()

              Retrieve the index of a named uniform block

              _g_l_:_g_e_t_U_n_i_f_o_r_m_B_l_o_c_k_I_n_d_e_x retrieves the index of a uniform block
              within _P_r_o_g_r_a_m .

              _P_r_o_g_r_a_m must be the name of a program object for which the
              command ggll::lliinnkkPPrrooggrraamm//11 must have been called in the past,
              although it is not required that ggll::lliinnkkPPrrooggrraamm//11 must have
              succeeded. The link could have failed because the number of
              active uniforms exceeded the limit.

              _U_n_i_f_o_r_m_B_l_o_c_k_N_a_m_e must contain a nul-terminated string specifying
              the name of the uniform block.

              _g_l_:_g_e_t_U_n_i_f_o_r_m_B_l_o_c_k_I_n_d_e_x returns the uniform block index for the
              uniform block named _U_n_i_f_o_r_m_B_l_o_c_k_N_a_m_e of _P_r_o_g_r_a_m . If
              _U_n_i_f_o_r_m_B_l_o_c_k_N_a_m_e does not identify an active uniform block of
              _P_r_o_g_r_a_m , _g_l_:_g_e_t_U_n_i_f_o_r_m_B_l_o_c_k_I_n_d_e_x returns the special
              identifier, _?_G_L___I_N_V_A_L_I_D___I_N_D_E_X. Indices of the active uniform
              blocks of a program are assigned in consecutive order, beginning
              with zero.

              See external documentation.

       ggeettAAccttiivveeUUnniiffoorrmmBBlloocckkiivv((PPrrooggrraamm,, UUnniiffoorrmmBBlloocckkIInnddeexx,, PPnnaammee,, PPaarraammss)) -->>
       ookk

              Types:

                 Program = integer()
                 UniformBlockIndex = integer()
                 Pname = enum()
                 Params = mem()

              Query information about an active uniform block

              _g_l_:_g_e_t_A_c_t_i_v_e_U_n_i_f_o_r_m_B_l_o_c_k_i_v retrieves information about an active
              uniform block within _P_r_o_g_r_a_m .

              _P_r_o_g_r_a_m must be the name of a program object for which the
              command ggll::lliinnkkPPrrooggrraamm//11 must have been called in the past,
              although it is not required that ggll::lliinnkkPPrrooggrraamm//11 must have
              succeeded. The link could have failed because the number of
              active uniforms exceeded the limit.

              _U_n_i_f_o_r_m_B_l_o_c_k_I_n_d_e_x is an active uniform block index of _P_r_o_g_r_a_m ,
              and must be less than the value of _?_G_L___A_C_T_I_V_E___U_N_I_F_O_R_M___B_L_O_C_K_S.

              Upon success, the uniform block parameter(s) specified by _P_n_a_m_e
              are returned in _P_a_r_a_m_s . If an error occurs, nothing will be
              written to _P_a_r_a_m_s .

              If _P_n_a_m_e is _?_G_L___U_N_I_F_O_R_M___B_L_O_C_K___B_I_N_D_I_N_G, then the index of the
              uniform buffer binding point last selected by the uniform block
              specified by _U_n_i_f_o_r_m_B_l_o_c_k_I_n_d_e_x for _P_r_o_g_r_a_m is returned. If no
              uniform block has been previously specified, zero is returned.

              If _P_n_a_m_e is _?_G_L___U_N_I_F_O_R_M___B_L_O_C_K___D_A_T_A___S_I_Z_E, then the
              implementation-dependent minimum total buffer object size, in
              basic machine units, required to hold all active uniforms in the
              uniform block identified by _U_n_i_f_o_r_m_B_l_o_c_k_I_n_d_e_x is returned. It is
              neither guaranteed nor expected that a given implementation will
              arrange uniform values as tightly packed in a buffer object. The
              exception to this is the _s_t_d_1_4_0 _u_n_i_f_o_r_m _b_l_o_c_k _l_a_y_o_u_t , which
              guarantees specific packing behavior and does not require the
              application to query for offsets and strides. In this case the
              minimum size may still be queried, even though it is determined
              in advance based only on the uniform block declaration.

              If _P_n_a_m_e is _?_G_L___U_N_I_F_O_R_M___B_L_O_C_K___N_A_M_E___L_E_N_G_T_H, then the total length
              (including the nul terminator) of the name of the uniform block
              identified by _U_n_i_f_o_r_m_B_l_o_c_k_I_n_d_e_x is returned.

              If _P_n_a_m_e is _?_G_L___U_N_I_F_O_R_M___B_L_O_C_K___A_C_T_I_V_E___U_N_I_F_O_R_M_S, then the number
              of active uniforms in the uniform block identified by
              _U_n_i_f_o_r_m_B_l_o_c_k_I_n_d_e_x is returned.

              If _P_n_a_m_e is _?_G_L___U_N_I_F_O_R_M___B_L_O_C_K___A_C_T_I_V_E___U_N_I_F_O_R_M___I_N_D_I_C_E_S, then a
              list of the active uniform indices for the uniform block
              identified by _U_n_i_f_o_r_m_B_l_o_c_k_I_n_d_e_x is returned. The number of
              elements that will be written to _P_a_r_a_m_s is the value of
              _?_G_L___U_N_I_F_O_R_M___B_L_O_C_K___A_C_T_I_V_E___U_N_I_F_O_R_M_S for _U_n_i_f_o_r_m_B_l_o_c_k_I_n_d_e_x .

              If _P_n_a_m_e is _?_G_L___U_N_I_F_O_R_M___B_L_O_C_K___R_E_F_E_R_E_N_C_E_D___B_Y___V_E_R_T_E_X___S_H_A_D_E_R,
              _?_G_L___U_N_I_F_O_R_M___B_L_O_C_K___R_E_F_E_R_E_N_C_E_D___B_Y___G_E_O_M_E_T_R_Y___S_H_A_D_E_R , or
              _?_G_L___U_N_I_F_O_R_M___B_L_O_C_K___R_E_F_E_R_E_N_C_E_D___B_Y___F_R_A_G_M_E_N_T___S_H_A_D_E_R, then a boolean
              value indicating whether the uniform block identified by
              _U_n_i_f_o_r_m_B_l_o_c_k_I_n_d_e_x is referenced by the vertex, geometry, or
              fragment programming stages of program, respectively, is
              returned.

              See external documentation.

       ggeettAAccttiivveeUUnniiffoorrmmBBlloocckkNNaammee((PPrrooggrraamm,, UUnniiffoorrmmBBlloocckkIInnddeexx,, BBuuffSSiizzee)) -->>
       ssttrriinngg(())

              Types:

                 Program = integer()
                 UniformBlockIndex = integer()
                 BufSize = integer()

              Retrieve the name of an active uniform block

              _g_l_:_g_e_t_A_c_t_i_v_e_U_n_i_f_o_r_m_B_l_o_c_k_N_a_m_e retrieves the name of the active
              uniform block at _U_n_i_f_o_r_m_B_l_o_c_k_I_n_d_e_x within _P_r_o_g_r_a_m .

              _P_r_o_g_r_a_m must be the name of a program object for which the
              command ggll::lliinnkkPPrrooggrraamm//11 must have been called in the past,
              although it is not required that ggll::lliinnkkPPrrooggrraamm//11 must have
              succeeded. The link could have failed because the number of
              active uniforms exceeded the limit.

              _U_n_i_f_o_r_m_B_l_o_c_k_I_n_d_e_x is an active uniform block index of _P_r_o_g_r_a_m ,
              and must be less than the value of _?_G_L___A_C_T_I_V_E___U_N_I_F_O_R_M___B_L_O_C_K_S.

              Upon success, the name of the uniform block identified by
              _U_n_i_f_o_m_B_l_o_c_k_I_n_d_e_x is returned into _U_n_i_f_o_r_m_B_l_o_c_k_N_a_m_e . The name is
              nul-terminated. The actual number of characters written into
              _U_n_i_f_o_r_m_B_l_o_c_k_N_a_m_e , excluding the nul terminator, is returned in
              _L_e_n_g_t_h . If _L_e_n_g_t_h is NULL, no length is returned.

              _B_u_f_S_i_z_e contains the maximum number of characters (including the
              nul terminator) that will be written into _U_n_i_f_o_r_m_B_l_o_c_k_N_a_m_e .

              If an error occurs, nothing will be written to _U_n_i_f_o_r_m_B_l_o_c_k_N_a_m_e
              or _L_e_n_g_t_h .

              See external documentation.

       uunniiffoorrmmBBlloocckkBBiinnddiinngg((PPrrooggrraamm,, UUnniiffoorrmmBBlloocckkIInnddeexx,, UUnniiffoorrmmBBlloocckkBBiinnddiinngg)) -->>
       ookk

              Types:

                 Program = integer()
                 UniformBlockIndex = integer()
                 UniformBlockBinding = integer()

              Assign a binding point to an active uniform block

              Binding points for active uniform blocks are assigned using
              _g_l_:_u_n_i_f_o_r_m_B_l_o_c_k_B_i_n_d_i_n_g. Each of a program's active uniform
              blocks has a corresponding uniform buffer binding point. _P_r_o_g_r_a_m
              is the name of a program object for which the command
              ggll::lliinnkkPPrrooggrraamm//11 has been issued in the past.

              If successful, _g_l_:_u_n_i_f_o_r_m_B_l_o_c_k_B_i_n_d_i_n_g specifies that _P_r_o_g_r_a_m
              will use the data store of the buffer object bound to the
              binding point _U_n_i_f_o_r_m_B_l_o_c_k_B_i_n_d_i_n_g to extract the values of the
              uniforms in the uniform block identified by _U_n_i_f_o_r_m_B_l_o_c_k_I_n_d_e_x .

              When a program object is linked or re-linked, the uniform buffer
              object binding point assigned to each of its active uniform
              blocks is reset to zero.

              See external documentation.

       ccooppyyBBuuffffeerrSSuubbDDaattaa((RReeaaddTTaarrggeett,, WWrriitteeTTaarrggeett,, RReeaaddOOffffsseett,, WWrriitteeOOffffsseett,,
       SSiizzee)) -->> ookk

              Types:

                 ReadTarget = enum()
                 WriteTarget = enum()
                 ReadOffset = integer()
                 WriteOffset = integer()
                 Size = integer()

              Copy part of the data store of a buffer object to the data store
              of another buffer object

              _g_l_:_c_o_p_y_B_u_f_f_e_r_S_u_b_D_a_t_a copies part of the data store attached to
              _R_e_a_d_t_a_r_g_e_t to the data store attached to _W_r_i_t_e_t_a_r_g_e_t . The
              number of basic machine units indicated by _S_i_z_e is copied from
              the source, at offset _R_e_a_d_o_f_f_s_e_t to the destination at
              _W_r_i_t_e_o_f_f_s_e_t , also in basic machine units.

              _R_e_a_d_t_a_r_g_e_t and _W_r_i_t_e_t_a_r_g_e_t must be _?_G_L___A_R_R_A_Y___B_U_F_F_E_R,
              _?_G_L___C_O_P_Y___R_E_A_D___B_U_F_F_E_R , _?_G_L___C_O_P_Y___W_R_I_T_E___B_U_F_F_E_R,
              _?_G_L___E_L_E_M_E_N_T___A_R_R_A_Y___B_U_F_F_E_R, _?_G_L___P_I_X_E_L___P_A_C_K___B_U_F_F_E_R ,
              _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R, _?_G_L___T_E_X_T_U_R_E___B_U_F_F_E_R,
              _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___B_U_F_F_E_R or _?_G_L___U_N_I_F_O_R_M___B_U_F_F_E_R. Any of
              these targets may be used, although the targets
              _?_G_L___C_O_P_Y___R_E_A_D___B_U_F_F_E_R and _?_G_L___C_O_P_Y___W_R_I_T_E___B_U_F_F_E_R are provided
              specifically to allow copies between buffers without disturbing
              other GL state.

              _R_e_a_d_o_f_f_s_e_t , _W_r_i_t_e_o_f_f_s_e_t and _S_i_z_e must all be greater than or
              equal to zero. Furthermore, _R_e_a_d_o_f_f_s_e_t + _S_i_z_e must not exceeed
              the size of the buffer object bound to _R_e_a_d_t_a_r_g_e_t , and
              _R_e_a_d_o_f_f_s_e_t + _S_i_z_e must not exceeed the size of the buffer bound
              to _W_r_i_t_e_t_a_r_g_e_t . If the same buffer object is bound to both
              _R_e_a_d_t_a_r_g_e_t and _W_r_i_t_e_t_a_r_g_e_t , then the ranges specified by
              _R_e_a_d_o_f_f_s_e_t , _W_r_i_t_e_o_f_f_s_e_t and _S_i_z_e must not overlap.

              See external documentation.

       ddrraawwEElleemmeennttssBBaasseeVVeerrtteexx((MMooddee,, CCoouunntt,, TTyyppee,, IInnddiicceess,, BBaasseevveerrtteexx)) -->> ookk

              Types:

                 Mode = enum()
                 Count = integer()
                 Type = enum()
                 Indices = offset() | mem()
                 Basevertex = integer()

              Render primitives from array data with a per-element offset

              _g_l_:_d_r_a_w_E_l_e_m_e_n_t_s_B_a_s_e_V_e_r_t_e_x behaves identically to
              ggll::ddrraawwEElleemmeennttss//44 except that the _ith element transferred by the
              corresponding draw call will be taken from element _I_n_d_i_c_e_s [i] +
              _B_a_s_e_v_e_r_t_e_x of each enabled array. If the resulting value is
              larger than the maximum value representable by _T_y_p_e , it is as
              if the calculation were upconverted to 32-bit unsigned integers
              (with wrapping on overflow conditions). The operation is
              undefined if the sum would be negative.

              See external documentation.

       ddrraawwRRaannggeeEElleemmeennttssBBaasseeVVeerrtteexx((MMooddee,, SSttaarrtt,, EEnndd,, CCoouunntt,, TTyyppee,, IInnddiicceess,,
       BBaasseevveerrtteexx)) -->> ookk

              Types:

                 Mode = enum()
                 Start = integer()
                 End = integer()
                 Count = integer()
                 Type = enum()
                 Indices = offset() | mem()
                 Basevertex = integer()

              Render primitives from array data with a per-element offset

              _g_l_:_d_r_a_w_R_a_n_g_e_E_l_e_m_e_n_t_s_B_a_s_e_V_e_r_t_e_x is a restricted form of
              ggll::ddrraawwEElleemmeennttssBBaasseeVVeerrtteexx//55 . _M_o_d_e , _S_t_a_r_t , _E_n_d , _C_o_u_n_t and
              _B_a_s_e_v_e_r_t_e_x match the corresponding arguments to
              ggll::ddrraawwEElleemmeennttssBBaasseeVVeerrtteexx//55 , with the additional constraint
              that all values in the array _I_n_d_i_c_e_s must lie between _S_t_a_r_t and
              _E_n_d , inclusive, prior to adding _B_a_s_e_v_e_r_t_e_x . Index values lying
              outside the range [ _S_t_a_r_t , _E_n_d ] are treated in the same way as
              ggll::ddrraawwEElleemmeennttssBBaasseeVVeerrtteexx//55 . The _i th element transferred by
              the corresponding draw call will be taken from element _I_n_d_i_c_e_s
              [i] + _B_a_s_e_v_e_r_t_e_x of each enabled array. If the resulting value
              is larger than the maximum value representable by _T_y_p_e , it is
              as if the calculation were upconverted to 32-bit unsigned
              integers (with wrapping on overflow conditions). The operation
              is undefined if the sum would be negative.

              See external documentation.

       ddrraawwEElleemmeennttssIInnssttaanncceeddBBaasseeVVeerrtteexx((MMooddee,, CCoouunntt,, TTyyppee,, IInnddiicceess,, PPrriimmccoouunntt,,
       BBaasseevveerrtteexx)) -->> ookk

              Types:

                 Mode = enum()
                 Count = integer()
                 Type = enum()
                 Indices = offset() | mem()
                 Primcount = integer()
                 Basevertex = integer()

              Render multiple instances of a set of primitives from array data
              with a per-element offset

              _g_l_:_d_r_a_w_E_l_e_m_e_n_t_s_I_n_s_t_a_n_c_e_d_B_a_s_e_V_e_r_t_e_x behaves identically to
              ggll::ddrraawwEElleemmeennttssIInnssttaanncceedd//55 except that the _ith element
              transferred by the corresponding draw call will be taken from
              element _I_n_d_i_c_e_s [i] + _B_a_s_e_v_e_r_t_e_x of each enabled array. If the
              resulting value is larger than the maximum value representable
              by _T_y_p_e , it is as if the calculation were upconverted to 32-bit
              unsigned integers (with wrapping on overflow conditions). The
              operation is undefined if the sum would be negative.

              See external documentation.

       pprroovvookkiinnggVVeerrtteexx((MMooddee)) -->> ookk

              Types:

                 Mode = enum()

              Specifiy the vertex to be used as the source of data for flat
              shaded varyings

              _F_l_a_t_s_h_a_d_i_n_g a vertex shader varying output means to assign all
              vetices of the primitive the same value for that output. The
              vertex from which these values is derived is known as the
              _p_r_o_v_o_k_i_n_g _v_e_r_t_e_x and _g_l_:_p_r_o_v_o_k_i_n_g_V_e_r_t_e_x specifies which vertex
              is to be used as the source of data for flat shaded varyings.

              _P_r_o_v_o_k_e_M_o_d_e must be either _?_G_L___F_I_R_S_T___V_E_R_T_E_X___C_O_N_V_E_N_T_I_O_N or
              _?_G_L___L_A_S_T___V_E_R_T_E_X___C_O_N_V_E_N_T_I_O_N , and controls the selection of the
              vertex whose values are assigned to flatshaded varying outputs.
              The interpretation of these values for the supported primitive
              types is:_P_r_i_m_i_t_i_v_e _T_y_p_e _o_f _P_o_l_y_g_o_n_i_F_i_r_s_t _V_e_r_t_e_x _C_o_n_v_e_n_t_i_o_n_L_a_s_t
              _V_e_r_t_e_x _C_o_n_v_e_n_t_i_o_n
               point _i_i
               independent line 2_i - 1 2_i
               line loop _i

              _i + 1, if _i < _n 1, if _i = _n
               line strip _i_i + 1
               independent triangle 3_i - 2 3_i
               triangle strip _i_i + 2
               triangle fan _i + 1 _i + 2
               line adjacency 4_i - 2 4_i - 1
               line strip adjacency _i + 1 _i + 2
               triangle adjacency 6_i - 5 6_i - 1
               triangle strip adjacency 2_i - 1 2_i + 3


              If a vertex or geometry shader is active, user-defined varying
              outputs may be flatshaded by using the flat qualifier when
              declaring the output.

              See external documentation.

       ffeenncceeSSyynncc((CCoonnddiittiioonn,, FFllaaggss)) -->> iinntteeggeerr(())

              Types:

                 Condition = enum()
                 Flags = integer()

              Create a new sync object and insert it into the GL command
              stream

              _g_l_:_f_e_n_c_e_S_y_n_c creates a new fence sync object, inserts a fence
              command into the GL command stream and associates it with that
              sync object, and returns a non-zero name corresponding to the
              sync object.

              When the specified _C_o_n_d_i_t_i_o_n of the sync object is satisfied by
              the fence command, the sync object is signaled by the GL,
              causing any ggll::wwaaiittSSyynncc//33 , ggll::cclliieennttWWaaiittSSyynncc//33 commands
              blocking in _S_y_n_c to _u_n_b_l_o_c_k. No other state is affected by
              _g_l_:_f_e_n_c_e_S_y_n_c or by the execution of the associated fence
              command.

              _C_o_n_d_i_t_i_o_n must be _?_G_L___S_Y_N_C___G_P_U___C_O_M_M_A_N_D_S___C_O_M_P_L_E_T_E. This condition
              is satisfied by completion of the fence command corresponding to
              the sync object and all preceding commands in the same command
              stream. The sync object will not be signaled until all effects
              from these commands on GL client and server state and the
              framebuffer are fully realized. Note that completion of the
              fence command occurs once the state of the corresponding sync
              object has been changed, but commands waiting on that sync
              object may not be unblocked until after the fence command
              completes.

              See external documentation.

       iissSSyynncc((SSyynncc)) -->> 00 || 11

              Types:

                 Sync = integer()

              Determine if a name corresponds to a sync object

              _g_l_:_i_s_S_y_n_c returns _?_G_L___T_R_U_E if _S_y_n_c is currently the name of a
              sync object. If _S_y_n_c is not the name of a sync object, or if an
              error occurs, _g_l_:_i_s_S_y_n_c returns _?_G_L___F_A_L_S_E. Note that zero is not
              the name of a sync object.

              See external documentation.

       ddeelleetteeSSyynncc((SSyynncc)) -->> ookk

              Types:

                 Sync = integer()

              Delete a sync object

              _g_l_:_d_e_l_e_t_e_S_y_n_c deletes the sync object specified by _S_y_n_c . If the
              fence command corresponding to the specified sync object has
              completed, or if no ggll::wwaaiittSSyynncc//33 or ggll::cclliieennttWWaaiittSSyynncc//33
              commands are blocking on _S_y_n_c , the object is deleted
              immediately. Otherwise, _S_y_n_c is flagged for deletion and will be
              deleted when it is no longer associated with any fence command
              and is no longer blocking any ggll::wwaaiittSSyynncc//33 or
              ggll::cclliieennttWWaaiittSSyynncc//33 command. In either case, after _g_l_:_d_e_l_e_t_e_S_y_n_c
              returns, the name _S_y_n_c is invalid and can no longer be used to
              refer to the sync object.

              _g_l_:_d_e_l_e_t_e_S_y_n_c will silently ignore a _S_y_n_c value of zero.

              See external documentation.

       cclliieennttWWaaiittSSyynncc((SSyynncc,, FFllaaggss,, TTiimmeeoouutt)) -->> eennuumm(())

              Types:

                 Sync = integer()
                 Flags = integer()
                 Timeout = integer()

              Block and wait for a sync object to become signaled

              _g_l_:_c_l_i_e_n_t_W_a_i_t_S_y_n_c causes the client to block and wait for the
              sync object specified by _S_y_n_c to become signaled. If _S_y_n_c is
              signaled when _g_l_:_c_l_i_e_n_t_W_a_i_t_S_y_n_c is called, _g_l_:_c_l_i_e_n_t_W_a_i_t_S_y_n_c
              returns immediately, otherwise it will block and wait for up to
              _T_i_m_e_o_u_t nanoseconds for _S_y_n_c to become signaled.

              The return value is one of four status values:

              _?_G_L___A_L_R_E_A_D_Y___S_I_G_N_A_L_E_D indicates that _S_y_n_c was signaled at the
              time that _g_l_:_c_l_i_e_n_t_W_a_i_t_S_y_n_c was called.

              _?_G_L___T_I_M_E_O_U_T___E_X_P_I_R_E_D indicates that at least _T_i_m_e_o_u_t nanoseconds
              passed and _S_y_n_c did not become signaled.

              _?_G_L___C_O_N_D_I_T_I_O_N___S_A_T_I_S_F_I_E_D indicates that _S_y_n_c was signaled before
              the timeout expired.

              _?_G_L___W_A_I_T___F_A_I_L_E_D indicates that an error occurred. Additionally,
              an OpenGL error will be generated.

              See external documentation.

       wwaaiittSSyynncc((SSyynncc,, FFllaaggss,, TTiimmeeoouutt)) -->> ookk

              Types:

                 Sync = integer()
                 Flags = integer()
                 Timeout = integer()

              Instruct the GL server to block until the specified sync object
              becomes signaled

              _g_l_:_w_a_i_t_S_y_n_c causes the GL server to block and wait until _S_y_n_c
              becomes signaled. _S_y_n_c is the name of an existing sync object
              upon which to wait. _F_l_a_g_s and _T_i_m_e_o_u_t are currently not used and
              must be set to zero and the special value _?_G_L___T_I_M_E_O_U_T___I_G_N_O_R_E_D ,
              respectively

              _F_l_a_g_s and _T_i_m_e_o_u_t are placeholders for anticipated future
              extensions of sync object capabilities. They must have these
              reserved values in order that existing code calling _g_l_:_w_a_i_t_S_y_n_c
              operate properly in the presence of such extensions..
              _g_l_:_w_a_i_t_S_y_n_c will always wait no longer than an implementation-
              dependent timeout. The duration of this timeout in nanoseconds
              may be queried by calling ggll::ggeettBBoooolleeaannvv//11 with the parameter
              _?_G_L___M_A_X___S_E_R_V_E_R___W_A_I_T___T_I_M_E_O_U_T . There is currently no way to
              determine whether _g_l_:_w_a_i_t_S_y_n_c unblocked because the timeout
              expired or because the sync object being waited on was signaled.

              If an error occurs, _g_l_:_w_a_i_t_S_y_n_c does not cause the GL server to
              block.

              See external documentation.

       ggeettIInntteeggeerr6644vv((PPnnaammee)) -->> [[iinntteeggeerr(())]]

              Types:

                 Pname = enum()

              See ggeettBBoooolleeaannvv//11

       ggeettSSyynncciivv((SSyynncc,, PPnnaammee,, BBuuffSSiizzee)) -->> [[iinntteeggeerr(())]]

              Types:

                 Sync = integer()
                 Pname = enum()
                 BufSize = integer()

              Query the properties of a sync object

              _g_l_:_g_e_t_S_y_n_c_i_v retrieves properties of a sync object. _S_y_n_c
              specifies the name of the sync object whose properties to
              retrieve.

              On success, _g_l_:_g_e_t_S_y_n_c_i_v replaces up to _B_u_f_S_i_z_e integers in
              _V_a_l_u_e_s with the corresponding property values of the object
              being queried. The actual number of integers replaced is
              returned in the variable whose address is specified in _L_e_n_g_t_h .
              If _L_e_n_g_t_h is NULL, no length is returned.

              If _P_n_a_m_e is _?_G_L___O_B_J_E_C_T___T_Y_P_E, a single value representing the
              specific type of the sync object is placed in _V_a_l_u_e_s . The only
              type supported is _?_G_L___S_Y_N_C___F_E_N_C_E .

              If _P_n_a_m_e is _?_G_L___S_Y_N_C___S_T_A_T_U_S, a single value representing the
              status of the sync object (_?_G_L___S_I_G_N_A_L_E_D or _?_G_L___U_N_S_I_G_N_A_L_E_D) is
              placed in _V_a_l_u_e_s .

              If _P_n_a_m_e is _?_G_L___S_Y_N_C___C_O_N_D_I_T_I_O_N, a single value representing the
              condition of the sync object is placed in _V_a_l_u_e_s . The only
              condition supported is _?_G_L___S_Y_N_C___G_P_U___C_O_M_M_A_N_D_S___C_O_M_P_L_E_T_E .

              If _P_n_a_m_e is _?_G_L___S_Y_N_C___F_L_A_G_S, a single value representing the
              flags with which the sync object was created is placed in _V_a_l_u_e_s
              . No flags are currently supported

              _F_l_a_g_s is expected to be used in future extensions to the sync
              objects..

              If an error occurs, nothing will be written to _V_a_l_u_e_s or _L_e_n_g_t_h
              .

              See external documentation.

       tteexxIImmaaggee22DDMMuullttiissaammppllee((TTaarrggeett,, SSaammpplleess,, IInntteerrnnaallffoorrmmaatt,, WWiiddtthh,, HHeeiigghhtt,,
       FFiixxeeddssaammpplleellooccaattiioonnss)) -->> ookk

              Types:

                 Target = enum()
                 Samples = integer()
                 Internalformat = integer()
                 Width = integer()
                 Height = integer()
                 Fixedsamplelocations = 0 | 1

              Establish the data storage, format, dimensions, and number of
              samples of a multisample texture's image

              _g_l_:_t_e_x_I_m_a_g_e_2_D_M_u_l_t_i_s_a_m_p_l_e establishes the data storage, format,
              dimensions and number of samples of a multisample texture's
              image.

              _T_a_r_g_e_t must be _?_G_L___T_E_X_T_U_R_E___2_D___M_U_L_T_I_S_A_M_P_L_E or
              _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___2_D___M_U_L_T_I_S_A_M_P_L_E . _W_i_d_t_h and _H_e_i_g_h_t are the
              dimensions in texels of the texture, and must be in the range
              zero to _?_G_L___M_A_X___T_E_X_T_U_R_E___S_I_Z_E - 1. _S_a_m_p_l_e_s specifies the number
              of samples in the image and must be in the range zero to
              _?_G_L___M_A_X___S_A_M_P_L_E_S - 1.

              _I_n_t_e_r_n_a_l_f_o_r_m_a_t must be a color-renderable, depth-renderable, or
              stencil-renderable format.

              If _F_i_x_e_d_s_a_m_p_l_e_l_o_c_a_t_i_o_n_s is _?_G_L___T_R_U_E, the image will use
              identical sample locations and the same number of samples for
              all texels in the image, and the sample locations will not
              depend on the internal format or size of the image.

              When a multisample texture is accessed in a shader, the access
              takes one vector of integers describing which texel to fetch and
              an integer corresponding to the sample numbers describing which
              sample within the texel to fetch. No standard sampling
              instructions are allowed on the multisample texture targets.

              See external documentation.

       tteexxIImmaaggee33DDMMuullttiissaammppllee((TTaarrggeett,, SSaammpplleess,, IInntteerrnnaallffoorrmmaatt,, WWiiddtthh,, HHeeiigghhtt,,
       DDeepptthh,, FFiixxeeddssaammpplleellooccaattiioonnss)) -->> ookk

              Types:

                 Target = enum()
                 Samples = integer()
                 Internalformat = integer()
                 Width = integer()
                 Height = integer()
                 Depth = integer()
                 Fixedsamplelocations = 0 | 1

              Establish the data storage, format, dimensions, and number of
              samples of a multisample texture's image

              _g_l_:_t_e_x_I_m_a_g_e_3_D_M_u_l_t_i_s_a_m_p_l_e establishes the data storage, format,
              dimensions and number of samples of a multisample texture's
              image.

              _T_a_r_g_e_t must be _?_G_L___T_E_X_T_U_R_E___2_D___M_U_L_T_I_S_A_M_P_L_E___A_R_R_A_Y or
              _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___2_D___M_U_L_T_I_S_A_M_P_L_E___A_R_R_A_Y . _W_i_d_t_h and _H_e_i_g_h_t are
              the dimensions in texels of the texture, and must be in the
              range zero to _?_G_L___M_A_X___T_E_X_T_U_R_E___S_I_Z_E - 1. _D_e_p_t_h is the number of
              array slices in the array texture's image. _S_a_m_p_l_e_s specifies the
              number of samples in the image and must be in the range zero to
              _?_G_L___M_A_X___S_A_M_P_L_E_S - 1.

              _I_n_t_e_r_n_a_l_f_o_r_m_a_t must be a color-renderable, depth-renderable, or
              stencil-renderable format.

              If _F_i_x_e_d_s_a_m_p_l_e_l_o_c_a_t_i_o_n_s is _?_G_L___T_R_U_E, the image will use
              identical sample locations and the same number of samples for
              all texels in the image, and the sample locations will not
              depend on the internal format or size of the image.

              When a multisample texture is accessed in a shader, the access
              takes one vector of integers describing which texel to fetch and
              an integer corresponding to the sample numbers describing which
              sample within the texel to fetch. No standard sampling
              instructions are allowed on the multisample texture targets.

              See external documentation.

       ggeettMMuullttiissaammpplleeffvv((PPnnaammee,, IInnddeexx)) -->> {{ffllooaatt(()),, ffllooaatt(())}}

              Types:

                 Pname = enum()
                 Index = integer()

              Retrieve the location of a sample

              _g_l_:_g_e_t_M_u_l_t_i_s_a_m_p_l_e_f_v queries the location of a given sample.
              _P_n_a_m_e specifies the sample parameter to retrieve and must be
              _?_G_L___S_A_M_P_L_E___P_O_S_I_T_I_O_N. _I_n_d_e_x corresponds to the sample for which
              the location should be returned. The sample location is returned
              as two floating-point values in _V_a_l_[_0_] and _V_a_l_[_1_] , each between
              0 and 1, corresponding to the _X and _Y locations respectively in
              the GL pixel space of that sample. (0.5, 0.5) this corresponds
              to the pixel center. _I_n_d_e_x must be between zero and the value of
              _?_G_L___S_A_M_P_L_E_S - 1.

              If the multisample mode does not have fixed sample locations,
              the returned values may only reflect the locations of samples
              within some pixels.

              See external documentation.

       ssaammpplleeMMaasskkii((IInnddeexx,, MMaasskk)) -->> ookk

              Types:

                 Index = integer()
                 Mask = integer()

              Set the value of a sub-word of the sample mask

              _g_l_:_s_a_m_p_l_e_M_a_s_k_i sets one 32-bit sub-word of the multi-word sample
              mask, _?_G_L___S_A_M_P_L_E___M_A_S_K___V_A_L_U_E .

              _M_a_s_k_I_n_d_e_x specifies which 32-bit sub-word of the sample mask to
              update, and _M_a_s_k specifies the new value to use for that sub-
              word. _M_a_s_k_I_n_d_e_x must be less than the value of
              _?_G_L___M_A_X___S_A_M_P_L_E___M_A_S_K___W_O_R_D_S. Bit _B of mask word _M corresponds to
              sample 32 x _M + _B.

              See external documentation.

       nnaammeeddSSttrriinnggAARRBB((TTyyppee,, NNaammee,, SSttrriinngg)) -->> ookk

              Types:

                 Type = enum()
                 Name = string()
                 String = string()

              glNamedStringARB

              See external documentation.

       ddeelleetteeNNaammeeddSSttrriinnggAARRBB((NNaammee)) -->> ookk

              Types:

                 Name = string()

              glDeleteNamedStringARB

              See external documentation.

       ccoommppiilleeSShhaaddeerrIInncclluuddeeAARRBB((SShhaaddeerr,, PPaatthh)) -->> ookk

              Types:

                 Shader = integer()
                 Path = [string()]

              glCompileShaderIncludeARB

              See external documentation.

       iissNNaammeeddSSttrriinnggAARRBB((NNaammee)) -->> 00 || 11

              Types:

                 Name = string()

              glIsNamedStringARB

              See external documentation.

       ggeettNNaammeeddSSttrriinnggAARRBB((NNaammee,, BBuuffSSiizzee)) -->> ssttrriinngg(())

              Types:

                 Name = string()
                 BufSize = integer()

              glGetNamedStringARB

              See external documentation.

       ggeettNNaammeeddSSttrriinnggiivvAARRBB((NNaammee,, PPnnaammee)) -->> iinntteeggeerr(())

              Types:

                 Name = string()
                 Pname = enum()

              glGetNamedStringARB

              See external documentation.

       bbiinnddFFrraaggDDaattaaLLooccaattiioonnIInnddeexxeedd((PPrrooggrraamm,, CCoolloorrNNuummbbeerr,, IInnddeexx,, NNaammee)) -->> ookk

              Types:

                 Program = integer()
                 ColorNumber = integer()
                 Index = integer()
                 Name = string()

              glBindFragDataLocationIndexe

              See external documentation.

       ggeettFFrraaggDDaattaaIInnddeexx((PPrrooggrraamm,, NNaammee)) -->> iinntteeggeerr(())

              Types:

                 Program = integer()
                 Name = string()

              Query the bindings of color indices to user-defined varying out
              variables

              _g_l_:_g_e_t_F_r_a_g_D_a_t_a_I_n_d_e_x returns the index of the fragment color to
              which the variable _N_a_m_e was bound when the program object
              _P_r_o_g_r_a_m was last linked. If _N_a_m_e is not a varying out variable
              of _P_r_o_g_r_a_m , or if an error occurs, -1 will be returned.

              See external documentation.

       ggeennSSaammpplleerrss((CCoouunntt)) -->> [[iinntteeggeerr(())]]

              Types:

                 Count = integer()

              Generate sampler object names

              _g_l_:_g_e_n_S_a_m_p_l_e_r_s returns _N sampler object names in _S_a_m_p_l_e_r_s .
              There is no guarantee that the names form a contiguous set of
              integers; however, it is guaranteed that none of the returned
              names was in use immediately before the call to _g_l_:_g_e_n_S_a_m_p_l_e_r_s .

              Sampler object names returned by a call to _g_l_:_g_e_n_S_a_m_p_l_e_r_s are
              not returned by subsequent calls, unless they are first deleted
              with ggll::ddeelleetteeSSaammpplleerrss//11 .

              The names returned in _S_a_m_p_l_e_r_s are marked as used, for the
              purposes of _g_l_:_g_e_n_S_a_m_p_l_e_r_s only, but they acquire state and type
              only when they are first bound.

              See external documentation.

       ddeelleetteeSSaammpplleerrss((SSaammpplleerrss)) -->> ookk

              Types:

                 Samplers = [integer()]

              Delete named sampler objects

              _g_l_:_d_e_l_e_t_e_S_a_m_p_l_e_r_s deletes _N sampler objects named by the
              elements of the array _I_d_s . After a sampler object is deleted,
              its name is again unused. If a sampler object that is currently
              bound to a sampler unit is deleted, it is as though
              ggll::bbiinnddSSaammpplleerr//22 is called with unit set to the unit the sampler
              is bound to and sampler zero. Unused names in samplers are
              silently ignored, as is the reserved name zero.

              See external documentation.

       iissSSaammpplleerr((SSaammpplleerr)) -->> 00 || 11

              Types:

                 Sampler = integer()

              Determine if a name corresponds to a sampler object

              _g_l_:_i_s_S_a_m_p_l_e_r returns _?_G_L___T_R_U_E if _I_d is currently the name of a
              sampler object. If _I_d is zero, or is a non-zero value that is
              not currently the name of a sampler object, or if an error
              occurs, _g_l_:_i_s_S_a_m_p_l_e_r returns _?_G_L___F_A_L_S_E.

              A name returned by ggll::ggeennSSaammpplleerrss//11 , is the name of a sampler
              object.

              See external documentation.

       bbiinnddSSaammpplleerr((UUnniitt,, SSaammpplleerr)) -->> ookk

              Types:

                 Unit = integer()
                 Sampler = integer()

              Bind a named sampler to a texturing target

              _g_l_:_b_i_n_d_S_a_m_p_l_e_r binds _S_a_m_p_l_e_r to the texture unit at index _U_n_i_t .
              _S_a_m_p_l_e_r must be zero or the name of a sampler object previously
              returned from a call to ggll::ggeennSSaammpplleerrss//11 . _U_n_i_t must be less
              than the value of _?_G_L___M_A_X___C_O_M_B_I_N_E_D___T_E_X_T_U_R_E___I_M_A_G_E___U_N_I_T_S.

              When a sampler object is bound to a texture unit, its state
              supersedes that of the texture object bound to that texture
              unit. If the sampler name zero is bound to a texture unit, the
              currently bound texture's sampler state becomes active. A single
              sampler object may be bound to multiple texture units
              simultaneously.

              See external documentation.

       ssaammpplleerrPPaarraammeetteerrii((SSaammpplleerr,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Sampler = integer()
                 Pname = enum()
                 Param = integer()

              Set sampler parameters

              _g_l_:_s_a_m_p_l_e_r_P_a_r_a_m_e_t_e_r assigns the value or values in _P_a_r_a_m_s to the
              sampler parameter specified as _P_n_a_m_e . _S_a_m_p_l_e_r specifies the
              sampler object to be modified, and must be the name of a sampler
              object previously returned from a call to ggll::ggeennSSaammpplleerrss//11 . The
              following symbols are accepted in _P_n_a_m_e :

              _?_G_L___T_E_X_T_U_R_E___M_I_N___F_I_L_T_E_R: The texture minifying function is used
              whenever the pixel being textured maps to an area greater than
              one texture element. There are six defined minifying functions.
              Two of them use the nearest one or nearest four texture elements
              to compute the texture value. The other four use mipmaps.

              A mipmap is an ordered set of arrays representing the same image
              at progressively lower resolutions. If the texture has
              dimensions 2 n*2 m, there are max(n m)+1 mipmaps. The first
              mipmap is the original texture, with dimensions 2 n*2 m. Each
              subsequent mipmap has dimensions 2(k-1)*2(l-1), where 2 k*2 l
              are the dimensions of the previous mipmap, until either k= 0 or
              l= 0. At that point, subsequent mipmaps have dimension 1*2(l-1)
              or 2(k-1)*1 until the final mipmap, which has dimension 1*1. To
              define the mipmaps, call ggll::tteexxIImmaaggee11DD//88 , ggll::tteexxIImmaaggee22DD//99 ,
              ggll::tteexxIImmaaggee33DD//1100 , ggll::ccooppyyTTeexxIImmaaggee11DD//77 , or ggll::ccooppyyTTeexxIImmaaggee22DD//88
              with the _l_e_v_e_l argument indicating the order of the mipmaps.
              Level 0 is the original texture; level max(n m) is the final 1*1
              mipmap.

              _P_a_r_a_m_s supplies a function for minifying the texture as one of
              the following:

              _?_G_L___N_E_A_R_E_S_T: Returns the value of the texture element that is
              nearest (in Manhattan distance) to the center of the pixel being
              textured.

              _?_G_L___L_I_N_E_A_R: Returns the weighted average of the four texture
              elements that are closest to the center of the pixel being
              textured. These can include border texture elements, depending
              on the values of _?_G_L___T_E_X_T_U_R_E___W_R_A_P___S and _?_G_L___T_E_X_T_U_R_E___W_R_A_P___T, and
              on the exact mapping.

              _?_G_L___N_E_A_R_E_S_T___M_I_P_M_A_P___N_E_A_R_E_S_T: Chooses the mipmap that most closely
              matches the size of the pixel being textured and uses the
              _?_G_L___N_E_A_R_E_S_T criterion (the texture element nearest to the center
              of the pixel) to produce a texture value.

              _?_G_L___L_I_N_E_A_R___M_I_P_M_A_P___N_E_A_R_E_S_T: Chooses the mipmap that most closely
              matches the size of the pixel being textured and uses the
              _?_G_L___L_I_N_E_A_R criterion (a weighted average of the four texture
              elements that are closest to the center of the pixel) to produce
              a texture value.

              _?_G_L___N_E_A_R_E_S_T___M_I_P_M_A_P___L_I_N_E_A_R: Chooses the two mipmaps that most
              closely match the size of the pixel being textured and uses the
              _?_G_L___N_E_A_R_E_S_T criterion (the texture element nearest to the center
              of the pixel) to produce a texture value from each mipmap. The
              final texture value is a weighted average of those two values.

              _?_G_L___L_I_N_E_A_R___M_I_P_M_A_P___L_I_N_E_A_R: Chooses the two mipmaps that most
              closely match the size of the pixel being textured and uses the
              _?_G_L___L_I_N_E_A_R criterion (a weighted average of the four texture
              elements that are closest to the center of the pixel) to produce
              a texture value from each mipmap. The final texture value is a
              weighted average of those two values.

              As more texture elements are sampled in the minification
              process, fewer aliasing artifacts will be apparent. While the
              _?_G_L___N_E_A_R_E_S_T and _?_G_L___L_I_N_E_A_R minification functions can be faster
              than the other four, they sample only one or four texture
              elements to determine the texture value of the pixel being
              rendered and can produce moire patterns or ragged transitions.
              The initial value of _?_G_L___T_E_X_T_U_R_E___M_I_N___F_I_L_T_E_R is
              _?_G_L___N_E_A_R_E_S_T___M_I_P_M_A_P___L_I_N_E_A_R .

              _?_G_L___T_E_X_T_U_R_E___M_A_G___F_I_L_T_E_R: The texture magnification function is
              used when the pixel being textured maps to an area less than or
              equal to one texture element. It sets the texture magnification
              function to either _?_G_L___N_E_A_R_E_S_T or _?_G_L___L_I_N_E_A_R (see below).
              _?_G_L___N_E_A_R_E_S_T is generally faster than _?_G_L___L_I_N_E_A_R, but it can
              produce textured images with sharper edges because the
              transition between texture elements is not as smooth. The
              initial value of _?_G_L___T_E_X_T_U_R_E___M_A_G___F_I_L_T_E_R is _?_G_L___L_I_N_E_A_R.

              _?_G_L___N_E_A_R_E_S_T: Returns the value of the texture element that is
              nearest (in Manhattan distance) to the center of the pixel being
              textured.

              _?_G_L___L_I_N_E_A_R: Returns the weighted average of the four texture
              elements that are closest to the center of the pixel being
              textured. These can include border texture elements, depending
              on the values of _?_G_L___T_E_X_T_U_R_E___W_R_A_P___S and _?_G_L___T_E_X_T_U_R_E___W_R_A_P___T, and
              on the exact mapping.

              _?_G_L___T_E_X_T_U_R_E___M_I_N___L_O_D: Sets the minimum level-of-detail parameter.
              This floating-point value limits the selection of highest
              resolution mipmap (lowest mipmap level). The initial value is
              -1000.

              _?_G_L___T_E_X_T_U_R_E___M_A_X___L_O_D: Sets the maximum level-of-detail parameter.
              This floating-point value limits the selection of the lowest
              resolution mipmap (highest mipmap level). The initial value is
              1000.

              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___S: Sets the wrap parameter for texture
              coordinate s to either _?_G_L___C_L_A_M_P___T_O___E_D_G_E , _?_G_L___M_I_R_R_O_R_E_D___R_E_P_E_A_T,
              or _?_G_L___R_E_P_E_A_T. _?_G_L___C_L_A_M_P___T_O___B_O_R_D_E_R causes the s coordinate to be
              clamped to the range [(-1 2/N) 1+(1 2/N)], where N is the size
              of the texture in the direction of clamping._?_G_L___C_L_A_M_P___T_O___E_D_G_E
              causes s coordinates to be clamped to the range [(1 2/N) 1-(1
              2/N)], where N is the size of the texture in the direction of
              clamping. _?_G_L___R_E_P_E_A_T causes the integer part of the s coordinate
              to be ignored; the GL uses only the fractional part, thereby
              creating a repeating pattern. _?_G_L___M_I_R_R_O_R_E_D___R_E_P_E_A_T causes the s
              coordinate to be set to the fractional part of the texture
              coordinate if the integer part of s is even; if the integer part
              of s is odd, then the s texture coordinate is set to 1-frac(s),
              where frac(s) represents the fractional part of s. Initially,
              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___S is set to _?_G_L___R_E_P_E_A_T.

              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___T: Sets the wrap parameter for texture
              coordinate t to either _?_G_L___C_L_A_M_P___T_O___E_D_G_E , _?_G_L___M_I_R_R_O_R_E_D___R_E_P_E_A_T,
              or _?_G_L___R_E_P_E_A_T. See the discussion under _?_G_L___T_E_X_T_U_R_E___W_R_A_P___S .
              Initially, _?_G_L___T_E_X_T_U_R_E___W_R_A_P___T is set to _?_G_L___R_E_P_E_A_T.

              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___R: Sets the wrap parameter for texture
              coordinate r to either _?_G_L___C_L_A_M_P___T_O___E_D_G_E , _?_G_L___M_I_R_R_O_R_E_D___R_E_P_E_A_T,
              or _?_G_L___R_E_P_E_A_T. See the discussion under _?_G_L___T_E_X_T_U_R_E___W_R_A_P___S .
              Initially, _?_G_L___T_E_X_T_U_R_E___W_R_A_P___R is set to _?_G_L___R_E_P_E_A_T.

              _?_G_L___T_E_X_T_U_R_E___B_O_R_D_E_R___C_O_L_O_R: The data in _P_a_r_a_m_s specifies four
              values that define the border values that should be used for
              border texels. If a texel is sampled from the border of the
              texture, the values of _?_G_L___T_E_X_T_U_R_E___B_O_R_D_E_R___C_O_L_O_R are interpreted
              as an RGBA color to match the texture's internal format and
              substituted for the non-existent texel data. If the texture
              contains depth components, the first component of
              _?_G_L___T_E_X_T_U_R_E___B_O_R_D_E_R___C_O_L_O_R is interpreted as a depth value. The
              initial value is (0.0, 0.0, 0.0, 0.0).

              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_A_R_E___M_O_D_E: Specifies the texture comparison mode
              for currently bound textures. That is, a texture whose internal
              format is _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T___*; see ggll::tteexxIImmaaggee22DD//99 )
              Permissible values are:

              _?_G_L___C_O_M_P_A_R_E___R_E_F___T_O___T_E_X_T_U_R_E: Specifies that the interpolated and
              clamped r texture coordinate should be compared to the value in
              the currently bound texture. See the discussion of
              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_A_R_E___F_U_N_C for details of how the comparison is
              evaluated. The result of the comparison is assigned to the red
              channel.

              _?_G_L___N_O_N_E: Specifies that the red channel should be assigned the
              appropriate value from the currently bound texture.

              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_A_R_E___F_U_N_C: Specifies the comparison operator used
              when _?_G_L___T_E_X_T_U_R_E___C_O_M_P_A_R_E___M_O_D_E is set to
              _?_G_L___C_O_M_P_A_R_E___R_E_F___T_O___T_E_X_T_U_R_E. Permissible values are:_T_e_x_t_u_r_e
              _C_o_m_p_a_r_i_s_o_n _F_u_n_c_t_i_o_n_C_o_m_p_u_t_e_d _r_e_s_u_l_t
              _?_G_L___L_E_Q_U_A_L result={1.0 0.0 &nbsp;&nbsp; r<=(D t) r>(D t))
              _?_G_L___G_E_Q_U_A_L result={1.0 0.0 &nbsp;&nbsp; r>=(D t) r<(D t))
              _?_G_L___L_E_S_S result={1.0 0.0 &nbsp;&nbsp; r< (D t) r>=(D t))
              _?_G_L___G_R_E_A_T_E_R result={1.0 0.0 &nbsp;&nbsp; r>(D t) r<=(D t))
              _?_G_L___E_Q_U_A_L result={1.0 0.0 &nbsp;&nbsp; r=(D t) r&ne;(D t))
              _?_G_L___N_O_T_E_Q_U_A_L result={1.0 0.0 &nbsp;&nbsp; r&ne;(D t) r=(D t))
              _?_G_L___A_L_W_A_Y_S result= 1.0
              _?_G_L___N_E_V_E_R result= 0.0


              where r is the current interpolated texture coordinate, and D t
              is the texture value sampled from the currently bound texture.
              result is assigned to R t.

              See external documentation.

       ssaammpplleerrPPaarraammeetteerriivv((SSaammpplleerr,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Sampler = integer()
                 Pname = enum()
                 Param = [integer()]

              See ssaammpplleerrPPaarraammeetteerrii//33

       ssaammpplleerrPPaarraammeetteerrff((SSaammpplleerr,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Sampler = integer()
                 Pname = enum()
                 Param = float()

              See ssaammpplleerrPPaarraammeetteerrii//33

       ssaammpplleerrPPaarraammeetteerrffvv((SSaammpplleerr,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Sampler = integer()
                 Pname = enum()
                 Param = [float()]

              See ssaammpplleerrPPaarraammeetteerrii//33

       ssaammpplleerrPPaarraammeetteerrIIiivv((SSaammpplleerr,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Sampler = integer()
                 Pname = enum()
                 Param = [integer()]

              See ssaammpplleerrPPaarraammeetteerrii//33

       ssaammpplleerrPPaarraammeetteerrIIuuiivv((SSaammpplleerr,, PPnnaammee,, PPaarraamm)) -->> ookk

              Types:

                 Sampler = integer()
                 Pname = enum()
                 Param = [integer()]

              glSamplerParameterI

              See external documentation.

       ggeettSSaammpplleerrPPaarraammeetteerriivv((SSaammpplleerr,, PPnnaammee)) -->> [[iinntteeggeerr(())]]

              Types:

                 Sampler = integer()
                 Pname = enum()

              Return sampler parameter values

              _g_l_:_g_e_t_S_a_m_p_l_e_r_P_a_r_a_m_e_t_e_r returns in _P_a_r_a_m_s the value or values of
              the sampler parameter specified as _P_n_a_m_e . _S_a_m_p_l_e_r defines the
              target sampler, and must be the name of an existing sampler
              object, returned from a previous call to ggll::ggeennSSaammpplleerrss//11 .
              _P_n_a_m_e accepts the same symbols as ggll::ssaammpplleerrPPaarraammeetteerrii//33 , with
              the same interpretations:

              _?_G_L___T_E_X_T_U_R_E___M_A_G___F_I_L_T_E_R: Returns the single-valued texture
              magnification filter, a symbolic constant. The initial value is
              _?_G_L___L_I_N_E_A_R.

              _?_G_L___T_E_X_T_U_R_E___M_I_N___F_I_L_T_E_R: Returns the single-valued texture
              minification filter, a symbolic constant. The initial value is
              _?_G_L___N_E_A_R_E_S_T___M_I_P_M_A_P___L_I_N_E_A_R.

              _?_G_L___T_E_X_T_U_R_E___M_I_N___L_O_D: Returns the single-valued texture minimum
              level-of-detail value. The initial value is -1000.

              _?_G_L___T_E_X_T_U_R_E___M_A_X___L_O_D: Returns the single-valued texture maximum
              level-of-detail value. The initial value is 1000.

              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___S: Returns the single-valued wrapping function
              for texture coordinate s, a symbolic constant. The initial value
              is _?_G_L___R_E_P_E_A_T.

              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___T: Returns the single-valued wrapping function
              for texture coordinate t, a symbolic constant. The initial value
              is _?_G_L___R_E_P_E_A_T.

              _?_G_L___T_E_X_T_U_R_E___W_R_A_P___R: Returns the single-valued wrapping function
              for texture coordinate r, a symbolic constant. The initial value
              is _?_G_L___R_E_P_E_A_T.

              _?_G_L___T_E_X_T_U_R_E___B_O_R_D_E_R___C_O_L_O_R: Returns four integer or floating-point
              numbers that comprise the RGBA color of the texture border.
              Floating-point values are returned in the range [0 1]. Integer
              values are returned as a linear mapping of the internal
              floating-point representation such that 1.0 maps to the most
              positive representable integer and -1.0 maps to the most
              negative representable integer. The initial value is (0, 0, 0,
              0).

              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_A_R_E___M_O_D_E: Returns a single-valued texture
              comparison mode, a symbolic constant. The initial value is
              _?_G_L___N_O_N_E. See ggll::ssaammpplleerrPPaarraammeetteerrii//33 .

              _?_G_L___T_E_X_T_U_R_E___C_O_M_P_A_R_E___F_U_N_C: Returns a single-valued texture
              comparison function, a symbolic constant. The initial value is
              _?_G_L___L_E_Q_U_A_L. See ggll::ssaammpplleerrPPaarraammeetteerrii//33 .

              See external documentation.

       ggeettSSaammpplleerrPPaarraammeetteerrIIiivv((SSaammpplleerr,, PPnnaammee)) -->> [[iinntteeggeerr(())]]

              Types:

                 Sampler = integer()
                 Pname = enum()

              See ggeettSSaammpplleerrPPaarraammeetteerriivv//22

       ggeettSSaammpplleerrPPaarraammeetteerrffvv((SSaammpplleerr,, PPnnaammee)) -->> [[ffllooaatt(())]]

              Types:

                 Sampler = integer()
                 Pname = enum()

              See ggeettSSaammpplleerrPPaarraammeetteerriivv//22

       ggeettSSaammpplleerrPPaarraammeetteerrIIuuiivv((SSaammpplleerr,, PPnnaammee)) -->> [[iinntteeggeerr(())]]

              Types:

                 Sampler = integer()
                 Pname = enum()

              glGetSamplerParameterI

              See external documentation.

       qquueerryyCCoouunntteerr((IIdd,, TTaarrggeett)) -->> ookk

              Types:

                 Id = integer()
                 Target = enum()

              Record the GL time into a query object after all previous
              commands have reached the GL server but have not yet necessarily
              executed.

              _g_l_:_q_u_e_r_y_C_o_u_n_t_e_r causes the GL to record the current time into
              the query object named _I_d . _T_a_r_g_e_t must be _?_G_L___T_I_M_E_S_T_A_M_P. The
              time is recorded after all previous commands on the GL client
              and server state and the framebuffer have been fully realized.
              When the time is recorded, the query result for that object is
              marked available. _g_l_:_q_u_e_r_y_C_o_u_n_t_e_r timer queries can be used
              within a ggll::bbeeggiinnQQuueerryy//22 / ggll::bbeeggiinnQQuueerryy//22 block where the
              target is _?_G_L___T_I_M_E___E_L_A_P_S_E_D and it does not affect the result of
              that query object.

              See external documentation.

       ggeettQQuueerryyOObbjjeeccttii6644vv((IIdd,, PPnnaammee)) -->> iinntteeggeerr(())

              Types:

                 Id = integer()
                 Pname = enum()

              glGetQueryObjecti64v

              See external documentation.

       ggeettQQuueerryyOObbjjeeccttuuii6644vv((IIdd,, PPnnaammee)) -->> iinntteeggeerr(())

              Types:

                 Id = integer()
                 Pname = enum()

              glGetQueryObjectui64v

              See external documentation.

       ddrraawwAArrrraayyssIInnddiirreecctt((MMooddee,, IInnddiirreecctt)) -->> ookk

              Types:

                 Mode = enum()
                 Indirect = offset() | mem()

              Render primitives from array data, taking parameters from memory

              _g_l_:_d_r_a_w_A_r_r_a_y_s_I_n_d_i_r_e_c_t specifies multiple geometric primitives
              with very few subroutine calls. _g_l_:_d_r_a_w_A_r_r_a_y_s_I_n_d_i_r_e_c_t behaves
              similarly to ggll::ddrraawwAArrrraayyssIInnssttaanncceeddBBaasseeIInnssttaannccee//55 , execept that
              the parameters to ggll::ddrraawwAArrrraayyssIInnssttaanncceeddBBaasseeIInnssttaannccee//55 are
              stored in memory at the address given by _I_n_d_i_r_e_c_t .

              The parameters addressed by _I_n_d_i_r_e_c_t are packed into a structure
              that takes the form (in C): typedef struct { uint count; uint
              primCount; uint first; uint baseInstance; }
              DrawArraysIndirectCommand; const DrawArraysIndirectCommand *cmd
              = (const DrawArraysIndirectCommand *)indirect;
              glDrawArraysInstancedBaseInstance(mode, cmd->first, cmd->count,
              cmd->primCount, cmd->baseInstance);

              If a buffer is bound to the _?_G_L___D_R_A_W___I_N_D_I_R_E_C_T___B_U_F_F_E_R binding at
              the time of a call to _g_l_:_d_r_a_w_A_r_r_a_y_s_I_n_d_i_r_e_c_t, _I_n_d_i_r_e_c_t is
              interpreted as an offset, in basic machine units, into that
              buffer and the parameter data is read from the buffer rather
              than from client memory.

              In contrast to ggll::ddrraawwAArrrraayyssIInnssttaanncceeddBBaasseeIInnssttaannccee//55 , the first
              member of the parameter structure is unsigned, and out-of-range
              indices do not generate an error.

              Vertex attributes that are modified by _g_l_:_d_r_a_w_A_r_r_a_y_s_I_n_d_i_r_e_c_t
              have an unspecified value after _g_l_:_d_r_a_w_A_r_r_a_y_s_I_n_d_i_r_e_c_t returns.
              Attributes that aren't modified remain well defined.

              See external documentation.

       ddrraawwEElleemmeennttssIInnddiirreecctt((MMooddee,, TTyyppee,, IInnddiirreecctt)) -->> ookk

              Types:

                 Mode = enum()
                 Type = enum()
                 Indirect = offset() | mem()

              Render indexed primitives from array data, taking parameters
              from memory

              _g_l_:_d_r_a_w_E_l_e_m_e_n_t_s_I_n_d_i_r_e_c_t specifies multiple indexed geometric
              primitives with very few subroutine calls.
              _g_l_:_d_r_a_w_E_l_e_m_e_n_t_s_I_n_d_i_r_e_c_t behaves similarly to
              ggll::ddrraawwEElleemmeennttssIInnssttaanncceeddBBaasseeVVeerrtteexxBBaasseeIInnssttaannccee//77 , execpt that
              the parameters to
              ggll::ddrraawwEElleemmeennttssIInnssttaanncceeddBBaasseeVVeerrtteexxBBaasseeIInnssttaannccee//77 are stored in
              memory at the address given by _I_n_d_i_r_e_c_t .

              The parameters addressed by _I_n_d_i_r_e_c_t are packed into a structure
              that takes the form (in C): typedef struct { uint count; uint
              primCount; uint firstIndex; uint baseVertex; uint baseInstance;
              } DrawElementsIndirectCommand;

              _g_l_:_d_r_a_w_E_l_e_m_e_n_t_s_I_n_d_i_r_e_c_t is equivalent to: void
              glDrawElementsIndirect(GLenum mode, GLenum type, const void *
              indirect) { const DrawElementsIndirectCommand *cmd = (const
              DrawElementsIndirectCommand *)indirect;
              glDrawElementsInstancedBaseVertexBaseInstance(mode, cmd->count,
              type, cmd->firstIndex + size-of-type, cmd->primCount,
              cmd->baseVertex, cmd->baseInstance); }

              If a buffer is bound to the _?_G_L___D_R_A_W___I_N_D_I_R_E_C_T___B_U_F_F_E_R binding at
              the time of a call to _g_l_:_d_r_a_w_E_l_e_m_e_n_t_s_I_n_d_i_r_e_c_t, _I_n_d_i_r_e_c_t is
              interpreted as an offset, in basic machine units, into that
              buffer and the parameter data is read from the buffer rather
              than from client memory.

              Note that indices stored in client memory are not supported. If
              no buffer is bound to the _?_G_L___E_L_E_M_E_N_T___A_R_R_A_Y___B_U_F_F_E_R binding, an
              error will be generated.

              The results of the operation are undefined if the
              reservedMustBeZero member of the parameter structure is non-
              zero. However, no error is generated in this case.

              Vertex attributes that are modified by _g_l_:_d_r_a_w_E_l_e_m_e_n_t_s_I_n_d_i_r_e_c_t
              have an unspecified value after _g_l_:_d_r_a_w_E_l_e_m_e_n_t_s_I_n_d_i_r_e_c_t returns.
              Attributes that aren't modified remain well defined.

              See external documentation.

       uunniiffoorrmm11dd((LLooccaattiioonn,, XX)) -->> ookk

              Types:

                 Location = integer()
                 X = float()

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm22dd((LLooccaattiioonn,, XX,, YY)) -->> ookk

              Types:

                 Location = integer()
                 X = float()
                 Y = float()

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm33dd((LLooccaattiioonn,, XX,, YY,, ZZ)) -->> ookk

              Types:

                 Location = integer()
                 X = float()
                 Y = float()
                 Z = float()

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm44dd((LLooccaattiioonn,, XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 Location = integer()
                 X = float()
                 Y = float()
                 Z = float()
                 W = float()

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm11ddvv((LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Value = [float()]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm22ddvv((LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Value = [{float(), float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm33ddvv((LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Value = [{float(), float(), float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmm44ddvv((LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Value = [{float(), float(), float(), float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx22ddvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx33ddvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float(), float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx44ddvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float(), float(), float(), float(),
                 float(), float(), float(), float(), float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx22xx33ddvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx22xx44ddvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx33xx22ddvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx33xx44ddvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float(), float(), float(), float(),
                 float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx44xx22ddvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float()}]

              See uunniiffoorrmm11ff//22

       uunniiffoorrmmMMaattrriixx44xx33ddvv((LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float(), float(), float(), float(),
                 float()}]

              See uunniiffoorrmm11ff//22

       ggeettUUnniiffoorrmmddvv((PPrrooggrraamm,, LLooccaattiioonn)) -->> mmaattrriixx(())

              Types:

                 Program = integer()
                 Location = integer()

              See ggeettUUnniiffoorrmmffvv//22

       ggeettSSuubbrroouuttiinneeUUnniiffoorrmmLLooccaattiioonn((PPrrooggrraamm,, SShhaaddeerrttyyppee,, NNaammee)) -->> iinntteeggeerr(())

              Types:

                 Program = integer()
                 Shadertype = enum()
                 Name = string()

              Retrieve the location of a subroutine uniform of a given shader
              stage within a program

              _g_l_:_g_e_t_S_u_b_r_o_u_t_i_n_e_U_n_i_f_o_r_m_L_o_c_a_t_i_o_n returns the location of the
              subroutine uniform variable _N_a_m_e in the shader stage of type
              _S_h_a_d_e_r_t_y_p_e attached to _P_r_o_g_r_a_m , with behavior otherwise
              identical to ggll::ggeettUUnniiffoorrmmLLooccaattiioonn//22 .

              If _N_a_m_e is not the name of a subroutine uniform in the shader
              stage, -1 is returned, but no error is generated. If _N_a_m_e is the
              name of a subroutine uniform in the shader stage, a value
              between zero and the value of _?_G_L___A_C_T_I_V_E___S_U_B_R_O_U_T_I_N_E___L_O_C_A_T_I_O_N_S
              minus one will be returned. Subroutine locations are assigned
              using consecutive integers in the range from zero to the value
              of _?_G_L___A_C_T_I_V_E___S_U_B_R_O_U_T_I_N_E___L_O_C_A_T_I_O_N_S minus one for the shader
              stage. For active subroutine uniforms declared as arrays, the
              declared array elements are assigned consecutive locations.

              See external documentation.

       ggeettSSuubbrroouuttiinneeIInnddeexx((PPrrooggrraamm,, SShhaaddeerrttyyppee,, NNaammee)) -->> iinntteeggeerr(())

              Types:

                 Program = integer()
                 Shadertype = enum()
                 Name = string()

              Retrieve the index of a subroutine uniform of a given shader
              stage within a program

              _g_l_:_g_e_t_S_u_b_r_o_u_t_i_n_e_I_n_d_e_x returns the index of a subroutine uniform
              within a shader stage attached to a program object. _P_r_o_g_r_a_m
              contains the name of the program to which the shader is
              attached. _S_h_a_d_e_r_t_y_p_e specifies the stage from which to query
              shader subroutine index. _N_a_m_e contains the null-terminated name
              of the subroutine uniform whose name to query.

              If _N_a_m_e is not the name of a subroutine uniform in the shader
              stage, _?_G_L___I_N_V_A_L_I_D___I_N_D_E_X is returned, but no error is generated.
              If _N_a_m_e is the name of a subroutine uniform in the shader stage,
              a value between zero and the value of _?_G_L___A_C_T_I_V_E___S_U_B_R_O_U_T_I_N_E_S
              minus one will be returned. Subroutine indices are assigned
              using consecutive integers in the range from zero to the value
              of _?_G_L___A_C_T_I_V_E___S_U_B_R_O_U_T_I_N_E_S minus one for the shader stage.

              See external documentation.

       ggeettAAccttiivveeSSuubbrroouuttiinneeUUnniiffoorrmmNNaammee((PPrrooggrraamm,, SShhaaddeerrttyyppee,, IInnddeexx,, BBuuffssiizzee)) -->>
       ssttrriinngg(())

              Types:

                 Program = integer()
                 Shadertype = enum()
                 Index = integer()
                 Bufsize = integer()

              Query the name of an active shader subroutine uniform

              _g_l_:_g_e_t_A_c_t_i_v_e_S_u_b_r_o_u_t_i_n_e_U_n_i_f_o_r_m_N_a_m_e retrieves the name of an
              active shader subroutine uniform. _P_r_o_g_r_a_m contains the name of
              the program containing the uniform. _S_h_a_d_e_r_t_y_p_e specifies the
              stage for which which the uniform location, given by _I_n_d_e_x , is
              valid. _I_n_d_e_x must be between zero and the value of
              _?_G_L___A_C_T_I_V_E___S_U_B_R_O_U_T_I_N_E___U_N_I_F_O_R_M_S minus one for the shader stage.

              The uniform name is returned as a null-terminated string in _N_a_m_e
              . The actual number of characters written into _N_a_m_e , excluding
              the null terminator is returned in _L_e_n_g_t_h . If _L_e_n_g_t_h is _?_N_U_L_L,
              no length is returned. The maximum number of characters that may
              be written into _N_a_m_e , including the null terminator, is
              specified by _B_u_f_s_i_z_e . The length of the longest subroutine
              uniform name in _P_r_o_g_r_a_m and _S_h_a_d_e_r_t_y_p_e is given by the value of
              _?_G_L___A_C_T_I_V_E___S_U_B_R_O_U_T_I_N_E___U_N_I_F_O_R_M___M_A_X___L_E_N_G_T_H, which can be queried
              with ggll::ggeettPPrrooggrraammSSttaaggeeiivv//33 .

              See external documentation.

       ggeettAAccttiivveeSSuubbrroouuttiinneeNNaammee((PPrrooggrraamm,, SShhaaddeerrttyyppee,, IInnddeexx,, BBuuffssiizzee)) -->>
       ssttrriinngg(())

              Types:

                 Program = integer()
                 Shadertype = enum()
                 Index = integer()
                 Bufsize = integer()

              Query the name of an active shader subroutine

              _g_l_:_g_e_t_A_c_t_i_v_e_S_u_b_r_o_u_t_i_n_e_N_a_m_e queries the name of an active shader
              subroutine uniform from the program object given in _P_r_o_g_r_a_m .
              _I_n_d_e_x specifies the index of the shader subroutine uniform
              within the shader stage given by _S_t_a_g_e , and must between zero
              and the value of _?_G_L___A_C_T_I_V_E___S_U_B_R_O_U_T_I_N_E_S minus one for the shader
              stage.

              The name of the selected subroutine is returned as a null-
              terminated string in _N_a_m_e . The actual number of characters
              written into _N_a_m_e , not including the null-terminator, is is
              returned in _L_e_n_g_t_h . If _L_e_n_g_t_h is _?_N_U_L_L, no length is returned.
              The maximum number of characters that may be written into _N_a_m_e ,
              including the null-terminator, is given in _B_u_f_s_i_z_e .

              See external documentation.

       uunniiffoorrmmSSuubbrroouuttiinneessuuiivv((SShhaaddeerrttyyppee,, IInnddiicceess)) -->> ookk

              Types:

                 Shadertype = enum()
                 Indices = [integer()]

              Load active subroutine uniforms

              _g_l_:_u_n_i_f_o_r_m_S_u_b_r_o_u_t_i_n_e_s loads all active subroutine uniforms for
              shader stage _S_h_a_d_e_r_t_y_p_e of the current program with subroutine
              indices from _I_n_d_i_c_e_s , storing _I_n_d_i_c_e_s_[_i_] into the uniform at
              location _I . _C_o_u_n_t must be equal to the value of
              _?_G_L___A_C_T_I_V_E___S_U_B_R_O_U_T_I_N_E___U_N_I_F_O_R_M___L_O_C_A_T_I_O_N_S for the program
              currently in use at shader stage _S_h_a_d_e_r_t_y_p_e . Furthermore, all
              values in _I_n_d_i_c_e_s must be less than the value of
              _?_G_L___A_C_T_I_V_E___S_U_B_R_O_U_T_I_N_E_S for the shader stage.

              See external documentation.

       ggeettUUnniiffoorrmmSSuubbrroouuttiinneeuuiivv((SShhaaddeerrttyyppee,, LLooccaattiioonn)) -->> {{iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),, iinntteeggeerr(()),,
       iinntteeggeerr(()),, iinntteeggeerr(())}}

              Types:

                 Shadertype = enum()
                 Location = integer()

              Retrieve the value of a subroutine uniform of a given shader
              stage of the current program

              _g_l_:_g_e_t_U_n_i_f_o_r_m_S_u_b_r_o_u_t_i_n_e retrieves the value of the subroutine
              uniform at location _L_o_c_a_t_i_o_n for shader stage _S_h_a_d_e_r_t_y_p_e of the
              current program. _L_o_c_a_t_i_o_n must be less than the value of
              _?_G_L___A_C_T_I_V_E___S_U_B_R_O_U_T_I_N_E___U_N_I_F_O_R_M___L_O_C_A_T_I_O_N_S for the shader currently
              in use at shader stage _S_h_a_d_e_r_t_y_p_e . The value of the subroutine
              uniform is returned in _V_a_l_u_e_s .

              See external documentation.

       ggeettPPrrooggrraammSSttaaggeeiivv((PPrrooggrraamm,, SShhaaddeerrttyyppee,, PPnnaammee)) -->> iinntteeggeerr(())

              Types:

                 Program = integer()
                 Shadertype = enum()
                 Pname = enum()

              Retrieve properties of a program object corresponding to a
              specified shader stage

              _g_l_:_g_e_t_P_r_o_g_r_a_m_S_t_a_g_e queries a parameter of a shader stage
              attached to a program object. _P_r_o_g_r_a_m contains the name of the
              program to which the shader is attached. _S_h_a_d_e_r_t_y_p_e specifies
              the stage from which to query the parameter. _P_n_a_m_e specifies
              which parameter should be queried. The value or values of the
              parameter to be queried is returned in the variable whose
              address is given in _V_a_l_u_e_s .

              If _P_n_a_m_e is _?_G_L___A_C_T_I_V_E___S_U_B_R_O_U_T_I_N_E___U_N_I_F_O_R_M_S, the number of active
              subroutine variables in the stage is returned in _V_a_l_u_e_s .

              If _P_n_a_m_e is _?_G_L___A_C_T_I_V_E___S_U_B_R_O_U_T_I_N_E___U_N_I_F_O_R_M___L_O_C_A_T_I_O_N_S, the number
              of active subroutine variable locations in the stage is returned
              in _V_a_l_u_e_s .

              If _P_n_a_m_e is _?_G_L___A_C_T_I_V_E___S_U_B_R_O_U_T_I_N_E_S, the number of active
              subroutines in the stage is returned in _V_a_l_u_e_s .

              If _P_n_a_m_e is _?_G_L___A_C_T_I_V_E___S_U_B_R_O_U_T_I_N_E___U_N_I_F_O_R_M___M_A_X___L_E_N_G_T_H, the length
              of the longest subroutine uniform for the stage is returned in
              _V_a_l_u_e_s .

              If _P_n_a_m_e is _?_G_L___A_C_T_I_V_E___S_U_B_R_O_U_T_I_N_E___M_A_X___L_E_N_G_T_H, the length of the
              longest subroutine name for the stage is returned in _V_a_l_u_e_s .
              The returned name length includes space for the null-terminator.

              If there is no shader present of type _S_h_a_d_e_r_t_y_p_e , the returned
              value will be consistent with a shader containing no subroutines
              or subroutine uniforms.

              See external documentation.

       ppaattcchhPPaarraammeetteerrii((PPnnaammee,, VVaalluuee)) -->> ookk

              Types:

                 Pname = enum()
                 Value = integer()

              Specifies the parameters for patch primitives

              _g_l_:_p_a_t_c_h_P_a_r_a_m_e_t_e_r specifies the parameters that will be used for
              patch primitives. _P_n_a_m_e specifies the parameter to modify and
              must be either _?_G_L___P_A_T_C_H___V_E_R_T_I_C_E_S, _?_G_L___P_A_T_C_H___D_E_F_A_U_L_T___O_U_T_E_R___L_E_V_E_L
              or _?_G_L___P_A_T_C_H___D_E_F_A_U_L_T___I_N_N_E_R___L_E_V_E_L. For _g_l_:_p_a_t_c_h_P_a_r_a_m_e_t_e_r_i, _V_a_l_u_e
              specifies the new value for the parameter specified by _P_n_a_m_e .
              For _g_l_:_p_a_t_c_h_P_a_r_a_m_e_t_e_r_f_v, _V_a_l_u_e_s specifies the address of an
              array containing the new values for the parameter specified by
              _P_n_a_m_e .

              When _P_n_a_m_e is _?_G_L___P_A_T_C_H___V_E_R_T_I_C_E_S, _V_a_l_u_e specifies the number of
              vertices that will be used to make up a single patch primitive.
              Patch primitives are consumed by the tessellation control shader
              (if present) and subsequently used for tessellation. When
              primitives are specified using ggll::ddrraawwAArrrraayyss//33 or a similar
              function, each patch will be made from _P_a_r_a_m_e_t_e_r control points,
              each represented by a vertex taken from the enabeld vertex
              arrays. _P_a_r_a_m_e_t_e_r must be greater than zero, and less than or
              equal to the value of _?_G_L___M_A_X___P_A_T_C_H___V_E_R_T_I_C_E_S.

              When _P_n_a_m_e is _?_G_L___P_A_T_C_H___D_E_F_A_U_L_T___O_U_T_E_R___L_E_V_E_L or
              _?_G_L___P_A_T_C_H___D_E_F_A_U_L_T___I_N_N_E_R___L_E_V_E_L , _V_a_l_u_e_s contains the address of
              an array contiaining the default outer or inner tessellation
              levels, respectively, to be used when no tessellation control
              shader is present.

              See external documentation.

       ppaattcchhPPaarraammeetteerrffvv((PPnnaammee,, VVaalluueess)) -->> ookk

              Types:

                 Pname = enum()
                 Values = [float()]

              See ppaattcchhPPaarraammeetteerrii//22

       bbiinnddTTrraannssffoorrmmFFeeeeddbbaacckk((TTaarrggeett,, IIdd)) -->> ookk

              Types:

                 Target = enum()
                 Id = integer()

              Bind a transform feedback object

              _g_l_:_b_i_n_d_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k binds the transform feedback object
              with name _I_d to the current GL state. _I_d must be a name
              previously returned from a call to ggll::ggeennTTrraannssffoorrmmFFeeeeddbbaacckkss//11 .
              If _I_d has not previously been bound, a new transform feedback
              object with name _I_d and initialized with with the default
              transform state vector is created.

              In the initial state, a default transform feedback object is
              bound and treated as a transform feedback object with a name of
              zero. If the name zero is subsequently bound, the default
              transform feedback object is again bound to the GL state.

              While a transform feedback buffer object is bound, GL operations
              on the target to which it is bound affect the bound transform
              feedback object, and queries of the target to which a transform
              feedback object is bound return state from the bound object.
              When buffer objects are bound for transform feedback, they are
              attached to the currently bound transform feedback object.
              Buffer objects are used for trans- form feedback only if they
              are attached to the currently bound transform feedback object.

              See external documentation.

       ddeelleetteeTTrraannssffoorrmmFFeeeeddbbaacckkss((IIddss)) -->> ookk

              Types:

                 Ids = [integer()]

              Delete transform feedback objects

              _g_l_:_d_e_l_e_t_e_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k_s deletes the _N transform feedback
              objects whose names are stored in the array _I_d_s . Unused names
              in _I_d_s are ignored, as is the name zero. After a transform
              feedback object is deleted, its name is again unused and it has
              no contents. If an active transform feedback object is deleted,
              its name immediately becomes unused, but the underlying object
              is not deleted until it is no longer active.

              See external documentation.

       ggeennTTrraannssffoorrmmFFeeeeddbbaacckkss((NN)) -->> [[iinntteeggeerr(())]]

              Types:

                 N = integer()

              Reserve transform feedback object names

              _g_l_:_g_e_n_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k_s returns _N previously unused transform
              feedback object names in _I_d_s . These names are marked as used,
              for the purposes of _g_l_:_g_e_n_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k_s only, but they
              acquire transform feedback state only when they are first bound.

              See external documentation.

       iissTTrraannssffoorrmmFFeeeeddbbaacckk((IIdd)) -->> 00 || 11

              Types:

                 Id = integer()

              Determine if a name corresponds to a transform feedback object

              _g_l_:_i_s_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k returns _?_G_L___T_R_U_E if _I_d is currently the
              name of a transform feedback object. If _I_d is zero, or if _?_i_d is
              not the name of a transform feedback object, or if an error
              occurs, _g_l_:_i_s_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k returns _?_G_L___F_A_L_S_E. If _I_d is a
              name returned by ggll::ggeennTTrraannssffoorrmmFFeeeeddbbaacckkss//11 , but that has not
              yet been bound through a call to ggll::bbiinnddTTrraannssffoorrmmFFeeeeddbbaacckk//22 ,
              then the name is not a transform feedback object and
              _g_l_:_i_s_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k returns _?_G_L___F_A_L_S_E .

              See external documentation.

       ppaauusseeTTrraannssffoorrmmFFeeeeddbbaacckk(()) -->> ookk

              Pause transform feedback operations

              _g_l_:_p_a_u_s_e_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k pauses transform feedback operations
              on the currently active transform feedback object. When
              transform feedback operations are paused, transform feedback is
              still considered active and changing most transform feedback
              state related to the object results in an error. However, a new
              transform feedback object may be bound while transform feedback
              is paused.

              See external documentation.

       rreessuummeeTTrraannssffoorrmmFFeeeeddbbaacckk(()) -->> ookk

              Resume transform feedback operations

              _g_l_:_r_e_s_u_m_e_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k resumes transform feedback operations
              on the currently active transform feedback object. When
              transform feedback operations are paused, transform feedback is
              still considered active and changing most transform feedback
              state related to the object results in an error. However, a new
              transform feedback object may be bound while transform feedback
              is paused.

              See external documentation.

       ddrraawwTTrraannssffoorrmmFFeeeeddbbaacckk((MMooddee,, IIdd)) -->> ookk

              Types:

                 Mode = enum()
                 Id = integer()

              Render primitives using a count derived from a transform
              feedback object

              _g_l_:_d_r_a_w_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k draws primitives of a type specified by
              _M_o_d_e using a count retrieved from the transform feedback
              specified by _I_d . Calling _g_l_:_d_r_a_w_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k is equivalent
              to calling ggll::ddrraawwAArrrraayyss//33 with _M_o_d_e as specified, _F_i_r_s_t set to
              zero, and _C_o_u_n_t set to the number of vertices captured on vertex
              stream zero the last time transform feedback was active on the
              transform feedback object named by _I_d .

              See external documentation.

       ddrraawwTTrraannssffoorrmmFFeeeeddbbaacckkSSttrreeaamm((MMooddee,, IIdd,, SSttrreeaamm)) -->> ookk

              Types:

                 Mode = enum()
                 Id = integer()
                 Stream = integer()

              Render primitives using a count derived from a specifed stream
              of a transform feedback object

              _g_l_:_d_r_a_w_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k_S_t_r_e_a_m draws primitives of a type
              specified by _M_o_d_e using a count retrieved from the transform
              feedback stream specified by _S_t_r_e_a_m of the transform feedback
              object specified by _I_d . Calling _g_l_:_d_r_a_w_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k_S_t_r_e_a_m
              is equivalent to calling ggll::ddrraawwAArrrraayyss//33 with _M_o_d_e as specified,
              _F_i_r_s_t set to zero, and _C_o_u_n_t set to the number of vertices
              captured on vertex stream _S_t_r_e_a_m the last time transform
              feedback was active on the transform feedback object named by _I_d
              .

              Calling ggll::ddrraawwTTrraannssffoorrmmFFeeeeddbbaacckk//22 is equivalent to calling
              _g_l_:_d_r_a_w_T_r_a_n_s_f_o_r_m_F_e_e_d_b_a_c_k_S_t_r_e_a_m with _S_t_r_e_a_m set to zero.

              See external documentation.

       bbeeggiinnQQuueerryyIInnddeexxeedd((TTaarrggeett,, IInnddeexx,, IIdd)) -->> ookk

              Types:

                 Target = enum()
                 Index = integer()
                 Id = integer()

              glBeginQueryIndexe

              See external documentation.

       eennddQQuueerryyIInnddeexxeedd((TTaarrggeett,, IInnddeexx)) -->> ookk

              Types:

                 Target = enum()
                 Index = integer()

              Delimit the boundaries of a query object on an indexed target

              _g_l_:_b_e_g_i_n_Q_u_e_r_y_I_n_d_e_x_e_d and ggll::eennddQQuueerryyIInnddeexxeedd//22 delimit the
              boundaries of a query object. _Q_u_e_r_y must be a name previously
              returned from a call to ggll::ggeennQQuueerriieess//11 . If a query object with
              name _I_d does not yet exist it is created with the type
              determined by _T_a_r_g_e_t . _T_a_r_g_e_t must be one of _?_G_L___S_A_M_P_L_E_S___P_A_S_S_E_D,
              _?_G_L___A_N_Y___S_A_M_P_L_E_S___P_A_S_S_E_D , _?_G_L___P_R_I_M_I_T_I_V_E_S___G_E_N_E_R_A_T_E_D,
              _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___P_R_I_M_I_T_I_V_E_S___W_R_I_T_T_E_N, or _?_G_L___T_I_M_E___E_L_A_P_S_E_D .
              The behavior of the query object depends on its type and is as
              follows.

              _I_n_d_e_x specifies the index of the query target and must be
              between a _T_a_r_g_e_t -specific maximum.

              If _T_a_r_g_e_t is _?_G_L___S_A_M_P_L_E_S___P_A_S_S_E_D, _I_d must be an unused name, or
              the name of an existing occlusion query object. When
              _g_l_:_b_e_g_i_n_Q_u_e_r_y_I_n_d_e_x_e_d is executed, the query object's samples-
              passed counter is reset to 0. Subsequent rendering will
              increment the counter for every sample that passes the depth
              test. If the value of _?_G_L___S_A_M_P_L_E___B_U_F_F_E_R_S is 0, then the samples-
              passed count is incremented by 1 for each fragment. If the value
              of _?_G_L___S_A_M_P_L_E___B_U_F_F_E_R_S is 1, then the samples-passed count is
              incremented by the number of samples whose coverage bit is set.
              However, implementations, at their discression may instead
              increase the samples-passed count by the value of _?_G_L___S_A_M_P_L_E_S if
              any sample in the fragment is covered. When _g_l_:_e_n_d_Q_u_e_r_y_I_n_d_e_x_e_d
              is executed, the samples-passed counter is assigned to the query
              object's result value. This value can be queried by calling
              ggll::ggeettQQuueerryyOObbjjeeccttiivv//22 with _P_n_a_m_e _?_G_L___Q_U_E_R_Y___R_E_S_U_L_T. When _T_a_r_g_e_t
              is _?_G_L___S_A_M_P_L_E_S___P_A_S_S_E_D, _I_n_d_e_x must be zero.

              If _T_a_r_g_e_t is _?_G_L___A_N_Y___S_A_M_P_L_E_S___P_A_S_S_E_D, _I_d must be an unused name,
              or the name of an existing boolean occlusion query object. When
              _g_l_:_b_e_g_i_n_Q_u_e_r_y_I_n_d_e_x_e_d is executed, the query object's samples-
              passed flag is reset to _?_G_L___F_A_L_S_E. Subsequent rendering causes
              the flag to be set to _?_G_L___T_R_U_E if any sample passes the depth
              test. When _g_l_:_e_n_d_Q_u_e_r_y_I_n_d_e_x_e_d is executed, the samples-passed
              flag is assigned to the query object's result value. This value
              can be queried by calling ggll::ggeettQQuueerryyOObbjjeeccttiivv//22 with _P_n_a_m_e
              _?_G_L___Q_U_E_R_Y___R_E_S_U_L_T. When _T_a_r_g_e_t is _?_G_L___A_N_Y___S_A_M_P_L_E_S___P_A_S_S_E_D , _I_n_d_e_x
              must be zero.

              If _T_a_r_g_e_t is _?_G_L___P_R_I_M_I_T_I_V_E_S___G_E_N_E_R_A_T_E_D, _I_d must be an unused
              name, or the name of an existing primitive query object
              previously bound to the _?_G_L___P_R_I_M_I_T_I_V_E_S___G_E_N_E_R_A_T_E_D query binding.
              When _g_l_:_b_e_g_i_n_Q_u_e_r_y_I_n_d_e_x_e_d is executed, the query object's
              primitives-generated counter is reset to 0. Subsequent rendering
              will increment the counter once for every vertex that is emitted
              from the geometry shader to the stream given by _I_n_d_e_x , or from
              the vertex shader if _I_n_d_e_x is zero and no geometry shader is
              present. When _g_l_:_e_n_d_Q_u_e_r_y_I_n_d_e_x_e_d is executed, the primitives-
              generated counter for stream _I_n_d_e_x is assigned to the query
              object's result value. This value can be queried by calling
              ggll::ggeettQQuueerryyOObbjjeeccttiivv//22 with _P_n_a_m_e _?_G_L___Q_U_E_R_Y___R_E_S_U_L_T. When _T_a_r_g_e_t
              is _?_G_L___P_R_I_M_I_T_I_V_E_S___G_E_N_E_R_A_T_E_D , _I_n_d_e_x must be less than the value
              of _?_G_L___M_A_X___V_E_R_T_E_X___S_T_R_E_A_M_S.

              If _T_a_r_g_e_t is _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___P_R_I_M_I_T_I_V_E_S___W_R_I_T_T_E_N, _I_d must
              be an unused name, or the name of an existing primitive query
              object previously bound to the
              _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___P_R_I_M_I_T_I_V_E_S___W_R_I_T_T_E_N query binding. When
              _g_l_:_b_e_g_i_n_Q_u_e_r_y_I_n_d_e_x_e_d is executed, the query object's primitives-
              written counter for the stream specified by _I_n_d_e_x is reset to 0.
              Subsequent rendering will increment the counter once for every
              vertex that is written into the bound transform feedback
              buffer(s) for stream _I_n_d_e_x . If transform feedback mode is not
              activated between the call to _g_l_:_b_e_g_i_n_Q_u_e_r_y_I_n_d_e_x_e_d and
              _g_l_:_e_n_d_Q_u_e_r_y_I_n_d_e_x_e_d, the counter will not be incremented. When
              _g_l_:_e_n_d_Q_u_e_r_y_I_n_d_e_x_e_d is executed, the primitives-written counter
              for stream _I_n_d_e_x is assigned to the query object's result value.
              This value can be queried by calling ggll::ggeettQQuueerryyOObbjjeeccttiivv//22 with
              _P_n_a_m_e _?_G_L___Q_U_E_R_Y___R_E_S_U_L_T. When _T_a_r_g_e_t is
              _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___P_R_I_M_I_T_I_V_E_S___W_R_I_T_T_E_N , _I_n_d_e_x must be less
              than the value of _?_G_L___M_A_X___V_E_R_T_E_X___S_T_R_E_A_M_S.

              If _T_a_r_g_e_t is _?_G_L___T_I_M_E___E_L_A_P_S_E_D, _I_d must be an unused name, or the
              name of an existing timer query object previously bound to the
              _?_G_L___T_I_M_E___E_L_A_P_S_E_D query binding. When _g_l_:_b_e_g_i_n_Q_u_e_r_y_I_n_d_e_x_e_d is
              executed, the query object's time counter is reset to 0. When
              _g_l_:_e_n_d_Q_u_e_r_y_I_n_d_e_x_e_d is executed, the elapsed server time that has
              passed since the call to _g_l_:_b_e_g_i_n_Q_u_e_r_y_I_n_d_e_x_e_d is written into
              the query object's time counter. This value can be queried by
              calling ggll::ggeettQQuueerryyOObbjjeeccttiivv//22 with _P_n_a_m_e _?_G_L___Q_U_E_R_Y___R_E_S_U_L_T. When
              _T_a_r_g_e_t is _?_G_L___T_I_M_E___E_L_A_P_S_E_D, _I_n_d_e_x must be zero.

              Querying the _?_G_L___Q_U_E_R_Y___R_E_S_U_L_T implicitly flushes the GL pipeline
              until the rendering delimited by the query object has completed
              and the result is available. _?_G_L___Q_U_E_R_Y___R_E_S_U_L_T___A_V_A_I_L_A_B_L_E can be
              queried to determine if the result is immediately available or
              if the rendering is not yet complete.

              See external documentation.

       ggeettQQuueerryyIInnddeexxeeddiivv((TTaarrggeett,, IInnddeexx,, PPnnaammee)) -->> iinntteeggeerr(())

              Types:

                 Target = enum()
                 Index = integer()
                 Pname = enum()

              Return parameters of an indexed query object target

              _g_l_:_g_e_t_Q_u_e_r_y_I_n_d_e_x_e_d_i_v returns in _P_a_r_a_m_s a selected parameter of
              the indexed query object target specified by _T_a_r_g_e_t and _I_n_d_e_x .
              _I_n_d_e_x specifies the index of the query object target and must be
              between zero and a target-specific maxiumum.

              _P_n_a_m_e names a specific query object target parameter. When _P_n_a_m_e
              is _?_G_L___C_U_R_R_E_N_T___Q_U_E_R_Y , the name of the currently active query
              for the specified _I_n_d_e_x of _T_a_r_g_e_t , or zero if no query is
              active, will be placed in _P_a_r_a_m_s . If _P_n_a_m_e is
              _?_G_L___Q_U_E_R_Y___C_O_U_N_T_E_R___B_I_T_S , the implementation-dependent number of
              bits used to hold the result of queries for _T_a_r_g_e_t is returned
              in _P_a_r_a_m_s .

              See external documentation.

       rreelleeaasseeSShhaaddeerrCCoommppiilleerr(()) -->> ookk

              Release resources consumed by the implementation's shader
              compiler

              _g_l_:_r_e_l_e_a_s_e_S_h_a_d_e_r_C_o_m_p_i_l_e_r provides a hint to the implementation
              that it may free internal resources associated with its shader
              compiler. ggll::ccoommppiilleeSShhaaddeerr//11 may subsequently be called and the
              implementation may at that time reallocate resources previously
              freed by the call to _g_l_:_r_e_l_e_a_s_e_S_h_a_d_e_r_C_o_m_p_i_l_e_r.

              See external documentation.

       sshhaaddeerrBBiinnaarryy((SShhaaddeerrss,, BBiinnaarryyffoorrmmaatt,, BBiinnaarryy)) -->> ookk

              Types:

                 Shaders = [integer()]
                 Binaryformat = enum()
                 Binary = binary()

              Load pre-compiled shader binaries

              _g_l_:_s_h_a_d_e_r_B_i_n_a_r_y loads pre-compiled shader binary code into the
              _C_o_u_n_t shader objects whose handles are given in _S_h_a_d_e_r_s . _B_i_n_a_r_y
              points to _L_e_n_g_t_h bytes of binary shader code stored in client
              memory. _B_i_n_a_r_y_F_o_r_m_a_t specifies the format of the pre-compiled
              code.

              The binary image contained in _B_i_n_a_r_y will be decoded according
              to the extension specification defining the specified
              _B_i_n_a_r_y_F_o_r_m_a_t token. OpenGL does not define any specific binary
              formats, but it does provide a mechanism to obtain token vaues
              for such formats provided by such extensions.

              Depending on the types of the shader objects in _S_h_a_d_e_r_s ,
              _g_l_:_s_h_a_d_e_r_B_i_n_a_r_y will individually load binary vertex or fragment
              shaders, or load an executable binary that contains an optimized
              pair of vertex and fragment shaders stored in the same binary.

              See external documentation.

       ggeettSShhaaddeerrPPrreecciissiioonnFFoorrmmaatt((SShhaaddeerrttyyppee,, PPrreecciissiioonnttyyppee)) -->>
       {{RRaannggee::::{{iinntteeggeerr(()),, iinntteeggeerr(())}},, PPrreecciissiioonn::::iinntteeggeerr(())}}

              Types:

                 Shadertype = enum()
                 Precisiontype = enum()

              Retrieve the range and precision for numeric formats supported
              by the shader compiler

              _g_l_:_g_e_t_S_h_a_d_e_r_P_r_e_c_i_s_i_o_n_F_o_r_m_a_t retrieves the numeric range and
              precision for the implementation's representation of quantities
              in different numeric formats in specified shader type.
              _S_h_a_d_e_r_T_y_p_e specifies the type of shader for which the numeric
              precision and range is to be retrieved and must be one of
              _?_G_L___V_E_R_T_E_X___S_H_A_D_E_R or _?_G_L___F_R_A_G_M_E_N_T___S_H_A_D_E_R. _P_r_e_c_i_s_i_o_n_T_y_p_e
              specifies the numeric format to query and must be one of
              _?_G_L___L_O_W___F_L_O_A_T, _?_G_L___M_E_D_I_U_M___F_L_O_A_T _?_G_L___H_I_G_H___F_L_O_A_T, _?_G_L___L_O_W___I_N_T,
              _?_G_L___M_E_D_I_U_M___I_N_T, or _?_G_L___H_I_G_H___I_N_T.

              _R_a_n_g_e points to an array of two integers into which the format's
              numeric range will be returned. If min and max are the smallest
              values representable in the format, then the values returned are
              defined to be: _R_a_n_g_e [0] = floor(log2(|min|)) and _R_a_n_g_e [1] =
              floor(log2(|max|)).

              _P_r_e_c_i_s_i_o_n specifies the address of an integer into which will be
              written the log2 value of the number of bits of precision of the
              format. If the smallest representable value greater than 1 is 1
              + _e_p_s, then the integer addressed by _P_r_e_c_i_s_i_o_n will contain
              floor(-log2(eps)).

              See external documentation.

       ddeepptthhRRaannggeeff((NN,, FF)) -->> ookk

              Types:

                 N = clamp()
                 F = clamp()

              See ddeepptthhRRaannggee//22

       cclleeaarrDDeepptthhff((DD)) -->> ookk

              Types:

                 D = clamp()

              glClearDepthf

              See external documentation.

       ggeettPPrrooggrraammBBiinnaarryy((PPrrooggrraamm,, BBuuffSSiizzee)) -->> {{BBiinnaarryyFFoorrmmaatt::::eennuumm(()),,
       BBiinnaarryy::::bbiinnaarryy(())}}

              Types:

                 Program = integer()
                 BufSize = integer()

              Return a binary representation of a program object's compiled
              and linked executable source

              _g_l_:_g_e_t_P_r_o_g_r_a_m_B_i_n_a_r_y returns a binary representation of the
              compiled and linked executable for _P_r_o_g_r_a_m into the array of
              bytes whose address is specified in _B_i_n_a_r_y . The maximum number
              of bytes that may be written into _B_i_n_a_r_y is specified by _B_u_f_S_i_z_e
              . If the program binary is greater in size than _B_u_f_S_i_z_e bytes,
              then an error is generated, otherwise the actual number of bytes
              written into _B_i_n_a_r_y is returned in the variable whose address is
              given by _L_e_n_g_t_h . If _L_e_n_g_t_h is _?_N_U_L_L, then no length is
              returned.

              The format of the program binary written into _B_i_n_a_r_y is returned
              in the variable whose address is given by _B_i_n_a_r_y_F_o_r_m_a_t , and may
              be implementation dependent. The binary produced by the GL may
              subsequently be returned to the GL by calling ggll::pprrooggrraammBBiinnaarryy//33
              , with _B_i_n_a_r_y_F_o_r_m_a_t and _L_e_n_g_t_h set to the values returned by
              _g_l_:_g_e_t_P_r_o_g_r_a_m_B_i_n_a_r_y , and passing the returned binary data in
              the _B_i_n_a_r_y parameter.

              See external documentation.

       pprrooggrraammBBiinnaarryy((PPrrooggrraamm,, BBiinnaarryyFFoorrmmaatt,, BBiinnaarryy)) -->> ookk

              Types:

                 Program = integer()
                 BinaryFormat = enum()
                 Binary = binary()

              Load a program object with a program binary

              _g_l_:_p_r_o_g_r_a_m_B_i_n_a_r_y loads a program object with a program binary
              previously returned from ggll::ggeettPPrrooggrraammBBiinnaarryy//22 . _B_i_n_a_r_y_F_o_r_m_a_t
              and _B_i_n_a_r_y must be those returned by a previous call to
              ggll::ggeettPPrrooggrraammBBiinnaarryy//22 , and _L_e_n_g_t_h must be the length returned
              by ggll::ggeettPPrrooggrraammBBiinnaarryy//22 , or by ggll::ggeettPPrrooggrraammiivv//22 when called
              with _P_n_a_m_e set to _?_G_L___P_R_O_G_R_A_M___B_I_N_A_R_Y___L_E_N_G_T_H. If these conditions
              are not met, loading the program binary will fail and _P_r_o_g_r_a_m 's
              _?_G_L___L_I_N_K___S_T_A_T_U_S will be set to _?_G_L___F_A_L_S_E.

              A program object's program binary is replaced by calls to
              ggll::lliinnkkPPrrooggrraamm//11 or _g_l_:_p_r_o_g_r_a_m_B_i_n_a_r_y . When linking success or
              failure is concerned, _g_l_:_p_r_o_g_r_a_m_B_i_n_a_r_y can be considered to
              perform an implicit linking operation. ggll::lliinnkkPPrrooggrraamm//11 and
              _g_l_:_p_r_o_g_r_a_m_B_i_n_a_r_y both set the program object's _?_G_L___L_I_N_K___S_T_A_T_U_S
              to _?_G_L___T_R_U_E or _?_G_L___F_A_L_S_E .

              A successful call to _g_l_:_p_r_o_g_r_a_m_B_i_n_a_r_y will reset all uniform
              variables to their initial values. The initial value is either
              the value of the variable's initializer as specified in the
              original shader source, or zero if no initializer was present.
              Additionally, all vertex shader input and fragment shader output
              assignments that were in effect when the program was linked
              before saving are restored with _g_l_:_p_r_o_g_r_a_m_B_i_n_a_r_y is called.

              See external documentation.

       pprrooggrraammPPaarraammeetteerrii((PPrrooggrraamm,, PPnnaammee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Pname = enum()
                 Value = integer()

              Specify a parameter for a program object

              _g_l_:_p_r_o_g_r_a_m_P_a_r_a_m_e_t_e_r specifies a new value for the parameter
              nameed by _P_n_a_m_e for the program object _P_r_o_g_r_a_m .

              If _P_n_a_m_e is _?_G_L___P_R_O_G_R_A_M___B_I_N_A_R_Y___R_E_T_R_I_E_V_A_B_L_E___H_I_N_T, _V_a_l_u_e should be
              _?_G_L___F_A_L_S_E or _?_G_L___T_R_U_E to indicate to the implementation the
              intention of the application to retrieve the program's binary
              representation with ggll::ggeettPPrrooggrraammBBiinnaarryy//22 . The implementation
              may use this information to store information that may be useful
              for a future query of the program's binary. It is recommended to
              set _?_G_L___P_R_O_G_R_A_M___B_I_N_A_R_Y___R_E_T_R_I_E_V_A_B_L_E___H_I_N_T for the program to
              _?_G_L___T_R_U_E before calling ggll::lliinnkkPPrrooggrraamm//11 , and using the program
              at run-time if the binary is to be retrieved later.

              If _P_n_a_m_e is _?_G_L___P_R_O_G_R_A_M___S_E_P_A_R_A_B_L_E, _V_a_l_u_e must be _?_G_L___T_R_U_E or
              _?_G_L___F_A_L_S_E and indicates whether _P_r_o_g_r_a_m can be bound to
              individual pipeline stages via ggll::uusseePPrrooggrraammSSttaaggeess//33 . A
              program's _?_G_L___P_R_O_G_R_A_M___S_E_P_A_R_A_B_L_E parameter must be set to
              _?_G_L___T_R_U_E_b_e_f_o_r_e ggll::lliinnkkPPrrooggrraamm//11 is called in order for it to be
              usable with a program pipeline object. The initial state of
              _?_G_L___P_R_O_G_R_A_M___S_E_P_A_R_A_B_L_E is _?_G_L___F_A_L_S_E.

              See external documentation.

       uusseePPrrooggrraammSSttaaggeess((PPiippeelliinnee,, SSttaaggeess,, PPrrooggrraamm)) -->> ookk

              Types:

                 Pipeline = integer()
                 Stages = integer()
                 Program = integer()

              Bind stages of a program object to a program pipeline

              _g_l_:_u_s_e_P_r_o_g_r_a_m_S_t_a_g_e_s binds executables from a program object
              associated with a specified set of shader stages to the program
              pipeline object given by _P_i_p_e_l_i_n_e . _P_i_p_e_l_i_n_e specifies the
              program pipeline object to which to bind the executables. _S_t_a_g_e_s
              contains a logical combination of bits indicating the shader
              stages to use within _P_r_o_g_r_a_m with the program pipeline object
              _P_i_p_e_l_i_n_e . _S_t_a_g_e_s must be a logical combination of
              _?_G_L___V_E_R_T_E_X___S_H_A_D_E_R___B_I_T, _?_G_L___T_E_S_S___C_O_N_T_R_O_L___S_H_A_D_E_R___B_I_T,
              _?_G_L___T_E_S_S___E_V_A_L_U_A_T_I_O_N___S_H_A_D_E_R___B_I_T , _?_G_L___G_E_O_M_E_T_R_Y___S_H_A_D_E_R___B_I_T, and
              _?_G_L___F_R_A_G_M_E_N_T___S_H_A_D_E_R___B_I_T. Additionally, the special value
              _?_G_L___A_L_L___S_H_A_D_E_R___B_I_T_S may be specified to indicate that all
              executables contained in _P_r_o_g_r_a_m should be installed in _P_i_p_e_l_i_n_e
              .

              If _P_r_o_g_r_a_m refers to a program object with a valid shader
              attached for an indicated shader stage, _g_l_:_u_s_e_P_r_o_g_r_a_m_S_t_a_g_e_s
              installs the executable code for that stage in the indicated
              program pipeline object _P_i_p_e_l_i_n_e . If _P_r_o_g_r_a_m is zero, or refers
              to a program object with no valid shader executable for a given
              stage, it is as if the pipeline object has no programmable stage
              configured for the indicated shader stages. If _S_t_a_g_e_s contains
              bits other than those listed above, and is not equal to
              _?_G_L___A_L_L___S_H_A_D_E_R___B_I_T_S , an error is generated.

              See external documentation.

       aaccttiivveeSShhaaddeerrPPrrooggrraamm((PPiippeelliinnee,, PPrrooggrraamm)) -->> ookk

              Types:

                 Pipeline = integer()
                 Program = integer()

              Set the active program object for a program pipeline object

              _g_l_:_a_c_t_i_v_e_S_h_a_d_e_r_P_r_o_g_r_a_m sets the linked program named by _P_r_o_g_r_a_m
              to be the active program for the program pipeline object
              _P_i_p_e_l_i_n_e . The active program in the active program pipeline
              object is the target of calls to ggll::uunniiffoorrmm11ff//22 when no program
              has been made current through a call to ggll::uusseePPrrooggrraamm//11 .

              See external documentation.

       ccrreeaatteeSShhaaddeerrPPrrooggrraammvv((TTyyppee,, SSttrriinnggss)) -->> iinntteeggeerr(())

              Types:

                 Type = enum()
                 Strings = [string()]

              glCreateShaderProgramv

              See external documentation.

       bbiinnddPPrrooggrraammPPiippeelliinnee((PPiippeelliinnee)) -->> ookk

              Types:

                 Pipeline = integer()

              Bind a program pipeline to the current context

              _g_l_:_b_i_n_d_P_r_o_g_r_a_m_P_i_p_e_l_i_n_e binds a program pipeline object to the
              current context. _P_i_p_e_l_i_n_e must be a name previously returned
              from a call to ggll::ggeennPPrrooggrraammPPiippeelliinneess//11 . If no program pipeline
              exists with name _P_i_p_e_l_i_n_e then a new pipeline object is created
              with that name and initialized to the default state vector.

              When a program pipeline object is bound using
              _g_l_:_b_i_n_d_P_r_o_g_r_a_m_P_i_p_e_l_i_n_e, any previous binding is broken and is
              replaced with a binding to the specified pipeline object. If
              _P_i_p_e_l_i_n_e is zero, the previous binding is broken and is not
              replaced, leaving no pipeline object bound. If no current
              program object has been established by ggll::uusseePPrrooggrraamm//11 , the
              program objects used for each stage and for uniform updates are
              taken from the bound program pipeline object, if any. If there
              is a current program object established by ggll::uusseePPrrooggrraamm//11 , the
              bound program pipeline object has no effect on rendering or
              uniform updates. When a bound program pipeline object is used
              for rendering, individual shader executables are taken from its
              program objects.

              See external documentation.

       ddeelleetteePPrrooggrraammPPiippeelliinneess((PPiippeelliinneess)) -->> ookk

              Types:

                 Pipelines = [integer()]

              Delete program pipeline objects

              _g_l_:_d_e_l_e_t_e_P_r_o_g_r_a_m_P_i_p_e_l_i_n_e_s deletes the _N program pipeline objects
              whose names are stored in the array _P_i_p_e_l_i_n_e_s . Unused names in
              _P_i_p_e_l_i_n_e_s are ignored, as is the name zero. After a program
              pipeline object is deleted, its name is again unused and it has
              no contents. If program pipeline object that is currently bound
              is deleted, the binding for that object reverts to zero and no
              program pipeline object becomes current.

              See external documentation.

       ggeennPPrrooggrraammPPiippeelliinneess((NN)) -->> [[iinntteeggeerr(())]]

              Types:

                 N = integer()

              Reserve program pipeline object names

              _g_l_:_g_e_n_P_r_o_g_r_a_m_P_i_p_e_l_i_n_e_s returns _N previously unused program
              pipeline object names in _P_i_p_e_l_i_n_e_s . These names are marked as
              used, for the purposes of _g_l_:_g_e_n_P_r_o_g_r_a_m_P_i_p_e_l_i_n_e_s only, but they
              acquire program pipeline state only when they are first bound.

              See external documentation.

       iissPPrrooggrraammPPiippeelliinnee((PPiippeelliinnee)) -->> 00 || 11

              Types:

                 Pipeline = integer()

              Determine if a name corresponds to a program pipeline object

              _g_l_:_i_s_P_r_o_g_r_a_m_P_i_p_e_l_i_n_e returns _?_G_L___T_R_U_E if _P_i_p_e_l_i_n_e is currently
              the name of a program pipeline object. If _P_i_p_e_l_i_n_e is zero, or
              if _?_p_i_p_e_l_i_n_e is not the name of a program pipeline object, or if
              an error occurs, _g_l_:_i_s_P_r_o_g_r_a_m_P_i_p_e_l_i_n_e returns _?_G_L___F_A_L_S_E. If
              _P_i_p_e_l_i_n_e is a name returned by ggll::ggeennPPrrooggrraammPPiippeelliinneess//11 , but
              that has not yet been bound through a call to
              ggll::bbiinnddPPrrooggrraammPPiippeelliinnee//11 , then the name is not a program
              pipeline object and _g_l_:_i_s_P_r_o_g_r_a_m_P_i_p_e_l_i_n_e returns _?_G_L___F_A_L_S_E .

              See external documentation.

       ggeettPPrrooggrraammPPiippeelliinneeiivv((PPiippeelliinnee,, PPnnaammee)) -->> iinntteeggeerr(())

              Types:

                 Pipeline = integer()
                 Pname = enum()

              Retrieve properties of a program pipeline object

              _g_l_:_g_e_t_P_r_o_g_r_a_m_P_i_p_e_l_i_n_e_i_v retrieves the value of a property of the
              program pipeline object _P_i_p_e_l_i_n_e . _P_n_a_m_e specifies the name of
              the parameter whose value to retrieve. The value of the
              parameter is written to the variable whose address is given by
              _P_a_r_a_m_s .

              If _P_n_a_m_e is _?_G_L___A_C_T_I_V_E___P_R_O_G_R_A_M, the name of the active program
              object of the program pipeline object is returned in _P_a_r_a_m_s .

              If _P_n_a_m_e is _?_G_L___V_E_R_T_E_X___S_H_A_D_E_R, the name of the current program
              object for the vertex shader type of the program pipeline object
              is returned in _P_a_r_a_m_s .

              If _P_n_a_m_e is _?_G_L___T_E_S_S___C_O_N_T_R_O_L___S_H_A_D_E_R, the name of the current
              program object for the tessellation control shader type of the
              program pipeline object is returned in _P_a_r_a_m_s .

              If _P_n_a_m_e is _?_G_L___T_E_S_S___E_V_A_L_U_A_T_I_O_N___S_H_A_D_E_R, the name of the current
              program object for the tessellation evaluation shader type of
              the program pipeline object is returned in _P_a_r_a_m_s .

              If _P_n_a_m_e is _?_G_L___G_E_O_M_E_T_R_Y___S_H_A_D_E_R, the name of the current program
              object for the geometry shader type of the program pipeline
              object is returned in _P_a_r_a_m_s .

              If _P_n_a_m_e is _?_G_L___F_R_A_G_M_E_N_T___S_H_A_D_E_R, the name of the current program
              object for the fragment shader type of the program pipeline
              object is returned in _P_a_r_a_m_s .

              If _P_n_a_m_e is _?_G_L___I_N_F_O___L_O_G___L_E_N_G_T_H, the length of the info log,
              including the null terminator, is returned in _P_a_r_a_m_s . If there
              is no info log, zero is returned.

              See external documentation.

       pprrooggrraammUUnniiffoorrmm11ii((PPrrooggrraamm,, LLooccaattiioonn,, VV00)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 V0 = integer()

              Specify the value of a uniform variable for a specified program
              object

              _g_l_:_p_r_o_g_r_a_m_U_n_i_f_o_r_m modifies the value of a uniform variable or a
              uniform variable array. The location of the uniform variable to
              be modified is specified by _L_o_c_a_t_i_o_n , which should be a value
              returned by ggll::ggeettUUnniiffoorrmmLLooccaattiioonn//22 . _g_l_:_p_r_o_g_r_a_m_U_n_i_f_o_r_m operates
              on the program object specified by _P_r_o_g_r_a_m .

              The commands _g_l_:_p_r_o_g_r_a_m_U_n_i_f_o_r_m_{_1_|_2_|_3_|_4_}_{_f_|_i_|_u_i_} are used to
              change the value of the uniform variable specified by _L_o_c_a_t_i_o_n
              using the values passed as arguments. The number specified in
              the command should match the number of components in the data
              type of the specified uniform variable (e.g., _1 for float, int,
              unsigned int, bool; _2 for vec2, ivec2, uvec2, bvec2, etc.). The
              suffix _f indicates that floating-point values are being passed;
              the suffix _i indicates that integer values are being passed; the
              suffix _u_i indicates that unsigned integer values are being
              passed, and this type should also match the data type of the
              specified uniform variable. The _i variants of this function
              should be used to provide values for uniform variables defined
              as int, ivec2 , ivec3, ivec4, or arrays of these. The _u_i
              variants of this function should be used to provide values for
              uniform variables defined as unsigned int, uvec2, uvec3, uvec4,
              or arrays of these. The _f variants should be used to provide
              values for uniform variables of type float, vec2, vec3, vec4, or
              arrays of these. Either the _i, _u_i or _f variants may be used to
              provide values for uniform variables of type bool, bvec2 ,
              bvec3, bvec4, or arrays of these. The uniform variable will be
              set to false if the input value is 0 or 0.0f, and it will be set
              to true otherwise.

              All active uniform variables defined in a program object are
              initialized to 0 when the program object is linked successfully.
              They retain the values assigned to them by a call to
              _g_l_:_p_r_o_g_r_a_m_U_n_i_f_o_r_m until the next successful link operation
              occurs on the program object, when they are once again
              initialized to 0.

              The commands _g_l_:_p_r_o_g_r_a_m_U_n_i_f_o_r_m_{_1_|_2_|_3_|_4_}_{_f_|_i_|_u_i_}_v can be used to
              modify a single uniform variable or a uniform variable array.
              These commands pass a count and a pointer to the values to be
              loaded into a uniform variable or a uniform variable array. A
              count of 1 should be used if modifying the value of a single
              uniform variable, and a count of 1 or greater can be used to
              modify an entire array or part of an array. When loading _n
              elements starting at an arbitrary position _m in a uniform
              variable array, elements _m + _n - 1 in the array will be replaced
              with the new values. If _M + _N - 1 is larger than the size of the
              uniform variable array, values for all array elements beyond the
              end of the array will be ignored. The number specified in the
              name of the command indicates the number of components for each
              element in _V_a_l_u_e , and it should match the number of components
              in the data type of the specified uniform variable (e.g., _1 for
              float, int, bool; _2 for vec2, ivec2, bvec2, etc.). The data type
              specified in the name of the command must match the data type
              for the specified uniform variable as described previously for
              _g_l_:_p_r_o_g_r_a_m_U_n_i_f_o_r_m_{_1_|_2_|_3_|_4_}_{_f_|_i_|_u_i_}.

              For uniform variable arrays, each element of the array is
              considered to be of the type indicated in the name of the
              command (e.g., _g_l_:_p_r_o_g_r_a_m_U_n_i_f_o_r_m_3_f or _g_l_:_p_r_o_g_r_a_m_U_n_i_f_o_r_m_3_f_v can
              be used to load a uniform variable array of type vec3). The
              number of elements of the uniform variable array to be modified
              is specified by _C_o_u_n_t

              The commands
              _g_l_:_p_r_o_g_r_a_m_U_n_i_f_o_r_m_M_a_t_r_i_x_{_2_|_3_|_4_|_2_x_3_|_3_x_2_|_2_x_4_|_4_x_2_|_3_x_4_|_4_x_3_}_f_v are
              used to modify a matrix or an array of matrices. The numbers in
              the command name are interpreted as the dimensionality of the
              matrix. The number _2 indicates a 2 ~A 2 matrix (i.e., 4 values),
              the number _3 indicates a 3 ~A 3 matrix (i.e., 9 values), and the
              number _4 indicates a 4 ~A 4 matrix (i.e., 16 values). Non-square
              matrix dimensionality is explicit, with the first number
              representing the number of columns and the second number
              representing the number of rows. For example, _2_x_4 indicates a 2
              ~A 4 matrix with 2 columns and 4 rows (i.e., 8 values). If
              _T_r_a_n_s_p_o_s_e is _?_G_L___F_A_L_S_E, each matrix is assumed to be supplied in
              column major order. If _T_r_a_n_s_p_o_s_e is _?_G_L___T_R_U_E, each matrix is
              assumed to be supplied in row major order. The _C_o_u_n_t argument
              indicates the number of matrices to be passed. A count of 1
              should be used if modifying the value of a single matrix, and a
              count greater than 1 can be used to modify an array of matrices.

              See external documentation.

       pprrooggrraammUUnniiffoorrmm11iivv((PPrrooggrraamm,, LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Value = [integer()]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm11ff((PPrrooggrraamm,, LLooccaattiioonn,, VV00)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 V0 = float()

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm11ffvv((PPrrooggrraamm,, LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Value = [float()]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm11dd((PPrrooggrraamm,, LLooccaattiioonn,, VV00)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 V0 = float()

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm11ddvv((PPrrooggrraamm,, LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Value = [float()]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm11uuii((PPrrooggrraamm,, LLooccaattiioonn,, VV00)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 V0 = integer()

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm11uuiivv((PPrrooggrraamm,, LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Value = [integer()]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm22ii((PPrrooggrraamm,, LLooccaattiioonn,, VV00,, VV11)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 V0 = integer()
                 V1 = integer()

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm22iivv((PPrrooggrraamm,, LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Value = [{integer(), integer()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm22ff((PPrrooggrraamm,, LLooccaattiioonn,, VV00,, VV11)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 V0 = float()
                 V1 = float()

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm22ffvv((PPrrooggrraamm,, LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Value = [{float(), float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm22dd((PPrrooggrraamm,, LLooccaattiioonn,, VV00,, VV11)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 V0 = float()
                 V1 = float()

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm22ddvv((PPrrooggrraamm,, LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Value = [{float(), float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm22uuii((PPrrooggrraamm,, LLooccaattiioonn,, VV00,, VV11)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 V0 = integer()
                 V1 = integer()

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm22uuiivv((PPrrooggrraamm,, LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Value = [{integer(), integer()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm33ii((PPrrooggrraamm,, LLooccaattiioonn,, VV00,, VV11,, VV22)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 V0 = integer()
                 V1 = integer()
                 V2 = integer()

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm33iivv((PPrrooggrraamm,, LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Value = [{integer(), integer(), integer()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm33ff((PPrrooggrraamm,, LLooccaattiioonn,, VV00,, VV11,, VV22)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 V0 = float()
                 V1 = float()
                 V2 = float()

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm33ffvv((PPrrooggrraamm,, LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Value = [{float(), float(), float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm33dd((PPrrooggrraamm,, LLooccaattiioonn,, VV00,, VV11,, VV22)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 V0 = float()
                 V1 = float()
                 V2 = float()

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm33ddvv((PPrrooggrraamm,, LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Value = [{float(), float(), float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm33uuii((PPrrooggrraamm,, LLooccaattiioonn,, VV00,, VV11,, VV22)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 V0 = integer()
                 V1 = integer()
                 V2 = integer()

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm33uuiivv((PPrrooggrraamm,, LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Value = [{integer(), integer(), integer()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm44ii((PPrrooggrraamm,, LLooccaattiioonn,, VV00,, VV11,, VV22,, VV33)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 V0 = integer()
                 V1 = integer()
                 V2 = integer()
                 V3 = integer()

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm44iivv((PPrrooggrraamm,, LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Value = [{integer(), integer(), integer(), integer()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm44ff((PPrrooggrraamm,, LLooccaattiioonn,, VV00,, VV11,, VV22,, VV33)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 V0 = float()
                 V1 = float()
                 V2 = float()
                 V3 = float()

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm44ffvv((PPrrooggrraamm,, LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Value = [{float(), float(), float(), float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm44dd((PPrrooggrraamm,, LLooccaattiioonn,, VV00,, VV11,, VV22,, VV33)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 V0 = float()
                 V1 = float()
                 V2 = float()
                 V3 = float()

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm44ddvv((PPrrooggrraamm,, LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Value = [{float(), float(), float(), float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm44uuii((PPrrooggrraamm,, LLooccaattiioonn,, VV00,, VV11,, VV22,, VV33)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 V0 = integer()
                 V1 = integer()
                 V2 = integer()
                 V3 = integer()

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmm44uuiivv((PPrrooggrraamm,, LLooccaattiioonn,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Value = [{integer(), integer(), integer(), integer()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx22ffvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx33ffvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float(), float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx44ffvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float(), float(), float(), float(),
                 float(), float(), float(), float(), float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx22ddvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx33ddvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float(), float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx44ddvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float(), float(), float(), float(),
                 float(), float(), float(), float(), float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx22xx33ffvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx33xx22ffvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx22xx44ffvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx44xx22ffvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx33xx44ffvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float(), float(), float(), float(),
                 float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx44xx33ffvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float(), float(), float(), float(),
                 float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx22xx33ddvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx33xx22ddvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx22xx44ddvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx44xx22ddvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx33xx44ddvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float(), float(), float(), float(),
                 float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       pprrooggrraammUUnniiffoorrmmMMaattrriixx44xx33ddvv((PPrrooggrraamm,, LLooccaattiioonn,, TTrraannssppoossee,, VVaalluuee)) -->> ookk

              Types:

                 Program = integer()
                 Location = integer()
                 Transpose = 0 | 1
                 Value = [{float(), float(), float(), float(), float(),
                 float(), float(), float(), float(), float(), float(),
                 float()}]

              See pprrooggrraammUUnniiffoorrmm11ii//33

       vvaalliiddaatteePPrrooggrraammPPiippeelliinnee((PPiippeelliinnee)) -->> ookk

              Types:

                 Pipeline = integer()

              Validate a program pipeline object against current GL state

              _g_l_:_v_a_l_i_d_a_t_e_P_r_o_g_r_a_m_P_i_p_e_l_i_n_e instructs the implementation to
              validate the shader executables contained in _P_i_p_e_l_i_n_e against
              the current GL state. The implementation may use this as an
              opportunity to perform any internal shader modifications that
              may be required to ensure correct operation of the installed
              shaders given the current GL state.

              After a program pipeline has been validated, its validation
              status is set to _?_G_L___T_R_U_E . The validation status of a program
              pipeline object may be queried by calling
              ggll::ggeettPPrrooggrraammPPiippeelliinneeiivv//22 with parameter _?_G_L___V_A_L_I_D_A_T_E___S_T_A_T_U_S.

              If _P_i_p_e_l_i_n_e is a name previously returned from a call to
              ggll::ggeennPPrrooggrraammPPiippeelliinneess//11 but that has not yet been bound by a
              call to ggll::bbiinnddPPrrooggrraammPPiippeelliinnee//11 , a new program pipeline object
              is created with name _P_i_p_e_l_i_n_e and the default state vector.

              See external documentation.

       ggeettPPrrooggrraammPPiippeelliinneeIInnffooLLoogg((PPiippeelliinnee,, BBuuffSSiizzee)) -->> ssttrriinngg(())

              Types:

                 Pipeline = integer()
                 BufSize = integer()

              Retrieve the info log string from a program pipeline object

              _g_l_:_g_e_t_P_r_o_g_r_a_m_P_i_p_e_l_i_n_e_I_n_f_o_L_o_g retrieves the info log for the
              program pipeline object _P_i_p_e_l_i_n_e . The info log, including its
              null terminator, is written into the array of characters whose
              address is given by _I_n_f_o_L_o_g . The maximum number of characters
              that may be written into _I_n_f_o_L_o_g is given by _B_u_f_S_i_z_e , and the
              actual number of characters written into _I_n_f_o_L_o_g is returned in
              the integer whose address is given by _L_e_n_g_t_h . If _L_e_n_g_t_h is
              _?_N_U_L_L, no length is returned.

              The actual length of the info log for the program pipeline may
              be determined by calling ggll::ggeettPPrrooggrraammPPiippeelliinneeiivv//22 with _P_n_a_m_e
              set to _?_G_L___I_N_F_O___L_O_G___L_E_N_G_T_H.

              See external documentation.

       vveerrtteexxAAttttrriibbLL11dd((IInnddeexx,, XX)) -->> ookk

              Types:

                 Index = integer()
                 X = float()

              glVertexAttribL

              See external documentation.

       vveerrtteexxAAttttrriibbLL22dd((IInnddeexx,, XX,, YY)) -->> ookk

              Types:

                 Index = integer()
                 X = float()
                 Y = float()

              glVertexAttribL

              See external documentation.

       vveerrtteexxAAttttrriibbLL33dd((IInnddeexx,, XX,, YY,, ZZ)) -->> ookk

              Types:

                 Index = integer()
                 X = float()
                 Y = float()
                 Z = float()

              glVertexAttribL

              See external documentation.

       vveerrtteexxAAttttrriibbLL44dd((IInnddeexx,, XX,, YY,, ZZ,, WW)) -->> ookk

              Types:

                 Index = integer()
                 X = float()
                 Y = float()
                 Z = float()
                 W = float()

              glVertexAttribL

              See external documentation.

       vveerrtteexxAAttttrriibbLL11ddvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::float()}

              Equivalent to vveerrtteexxAAttttrriibbLL11dd((IInnddeexx,, XX)).

       vveerrtteexxAAttttrriibbLL22ddvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float()}

              Equivalent to vveerrtteexxAAttttrriibbLL22dd((IInnddeexx,, XX,, YY)).

       vveerrtteexxAAttttrriibbLL33ddvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float(), Z::float()}

              Equivalent to vveerrtteexxAAttttrriibbLL33dd((IInnddeexx,, XX,, YY,, ZZ)).

       vveerrtteexxAAttttrriibbLL44ddvv((IInnddeexx::::iinntteeggeerr(()),, VV)) -->> ookk

              Types:

                 V = {X::float(), Y::float(), Z::float(), W::float()}

              Equivalent to vveerrtteexxAAttttrriibbLL44dd((IInnddeexx,, XX,, YY,, ZZ,, WW)).

       vveerrtteexxAAttttrriibbLLPPooiinntteerr((IInnddeexx,, SSiizzee,, TTyyppee,, SSttrriiddee,, PPooiinntteerr)) -->> ookk

              Types:

                 Index = integer()
                 Size = integer()
                 Type = enum()
                 Stride = integer()
                 Pointer = offset() | mem()

              glVertexAttribLPointer

              See external documentation.

       ggeettVVeerrtteexxAAttttrriibbLLddvv((IInnddeexx,, PPnnaammee)) -->> {{ffllooaatt(()),, ffllooaatt(()),, ffllooaatt(()),,
       ffllooaatt(())}}

              Types:

                 Index = integer()
                 Pname = enum()

              glGetVertexAttribL

              See external documentation.

       vviieewwppoorrttAArrrraayyvv((FFiirrsstt,, VV)) -->> ookk

              Types:

                 First = integer()
                 V = [{float(), float(), float(), float()}]

              glViewportArrayv

              See external documentation.

       vviieewwppoorrttIInnddeexxeeddff((IInnddeexx,, XX,, YY,, WW,, HH)) -->> ookk

              Types:

                 Index = integer()
                 X = float()
                 Y = float()
                 W = float()
                 H = float()

              Set a specified viewport

              _g_l_:_v_i_e_w_p_o_r_t_I_n_d_e_x_e_d_f and _g_l_:_v_i_e_w_p_o_r_t_I_n_d_e_x_e_d_f_v specify the
              parameters for a single viewport. _I_n_d_e_x specifies the index of
              the viewport to modify. _I_n_d_e_x must be less than the value of
              _?_G_L___M_A_X___V_I_E_W_P_O_R_T_S. For _g_l_:_v_i_e_w_p_o_r_t_I_n_d_e_x_e_d_f, _X , _Y , _W , and _H
              specify the left, bottom, width and height of the viewport in
              pixels, respectively. For _g_l_:_v_i_e_w_p_o_r_t_I_n_d_e_x_e_d_f_v, _V contains the
              address of an array of floating point values specifying the left
              ( x), bottom ( y), width ( w), and height ( h) of each viewport,
              in that order. x and y give the location of the viewport's lower
              left corner, and w and h give the width and height of the
              viewport, respectively. The viewport specifies the affine
              transformation of x and y from normalized device coordinates to
              window coordinates. Let (x nd y nd) be normalized device
              coordinates. Then the window coordinates (x w y w) are computed
              as follows:

              x w=(x nd+1) (width/2)+x

              y w=(y nd+1) (height/2)+y

              The location of the viewport's bottom left corner, given by ( x,
              y) is clamped to be within the implementaiton-dependent viewport
              bounds range. The viewport bounds range [ min, max] can be
              determined by calling ggll::ggeettBBoooolleeaannvv//11 with argument
              _?_G_L___V_I_E_W_P_O_R_T___B_O_U_N_D_S___R_A_N_G_E . Viewport width and height are
              silently clamped to a range that depends on the implementation.
              To query this range, call ggll::ggeettBBoooolleeaannvv//11 with argument
              _?_G_L___M_A_X___V_I_E_W_P_O_R_T___D_I_M_S.

              The precision with which the GL interprets the floating point
              viewport bounds is implementation-dependent and may be
              determined by querying the impementation-defined constant
              _?_G_L___V_I_E_W_P_O_R_T___S_U_B_P_I_X_E_L___B_I_T_S .

              Calling _g_l_:_v_i_e_w_p_o_r_t_I_n_d_e_x_e_d_f_v is equivalent to calling see
              _g_l_V_i_e_w_p_o_r_t_A_r_r_a_y with _F_i_r_s_t set to _I_n_d_e_x , _C_o_u_n_t set to 1 and _V
              passsed directly. _g_l_:_v_i_e_w_p_o_r_t_I_n_d_e_x_e_d_f is equivalent to: void
              glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat
              w, GLfloat h) { const float v[4] = { x, y, w, h };
              glViewportArrayv(index, 1, v); }

              See external documentation.

       vviieewwppoorrttIInnddeexxeeddffvv((IInnddeexx,, VV)) -->> ookk

              Types:

                 Index = integer()
                 V = {float(), float(), float(), float()}

              See vviieewwppoorrttIInnddeexxeeddff//55

       sscciissssoorrAArrrraayyvv((FFiirrsstt,, VV)) -->> ookk

              Types:

                 First = integer()
                 V = [{integer(), integer(), integer(), integer()}]

              glScissorArrayv

              See external documentation.

       sscciissssoorrIInnddeexxeedd((IInnddeexx,, LLeefftt,, BBoottttoomm,, WWiiddtthh,, HHeeiigghhtt)) -->> ookk

              Types:

                 Index = integer()
                 Left = integer()
                 Bottom = integer()
                 Width = integer()
                 Height = integer()

              glScissorIndexe

              See external documentation.

       sscciissssoorrIInnddeexxeeddvv((IInnddeexx,, VV)) -->> ookk

              Types:

                 Index = integer()
                 V = {integer(), integer(), integer(), integer()}

              glScissorIndexe

              See external documentation.

       ddeepptthhRRaannggeeAArrrraayyvv((FFiirrsstt,, VV)) -->> ookk

              Types:

                 First = integer()
                 V = [{clamp(), clamp()}]

              glDepthRangeArrayv

              See external documentation.

       ddeepptthhRRaannggeeIInnddeexxeedd((IInnddeexx,, NN,, FF)) -->> ookk

              Types:

                 Index = integer()
                 N = clamp()
                 F = clamp()

              glDepthRangeIndexe

              See external documentation.

       ggeettFFllooaattii__vv((TTaarrggeett,, IInnddeexx)) -->> [[ffllooaatt(())]]

              Types:

                 Target = enum()
                 Index = integer()

              See ggeettBBoooolleeaannvv//11

       ggeettDDoouubblleeii__vv((TTaarrggeett,, IInnddeexx)) -->> [[ffllooaatt(())]]

              Types:

                 Target = enum()
                 Index = integer()

              See ggeettBBoooolleeaannvv//11

       ddeebbuuggMMeessssaaggeeCCoonnttrroollAARRBB((SSoouurrccee,, TTyyppee,, SSeevveerriittyy,, IIddss,, EEnnaabblleedd)) -->> ookk

              Types:

                 Source = enum()
                 Type = enum()
                 Severity = enum()
                 Ids = [integer()]
                 Enabled = 0 | 1

              glDebugMessageControlARB

              See external documentation.

       ddeebbuuggMMeessssaaggeeIInnsseerrttAARRBB((SSoouurrccee,, TTyyppee,, IIdd,, SSeevveerriittyy,, BBuuff)) -->> ookk

              Types:

                 Source = enum()
                 Type = enum()
                 Id = integer()
                 Severity = enum()
                 Buf = string()

              glDebugMessageInsertARB

              See external documentation.

       ggeettDDeebbuuggMMeessssaaggeeLLooggAARRBB((CCoouunntt,, BBuuffssiizzee)) -->> {{iinntteeggeerr(()),, SSoouurrcceess::::[[eennuumm(())]],,
       TTyyppeess::::[[eennuumm(())]],, IIddss::::[[iinntteeggeerr(())]],, SSeevveerriittiieess::::[[eennuumm(())]],,
       MMeessssaaggeeLLoogg::::[[ssttrriinngg(())]]}}

              Types:

                 Count = integer()
                 Bufsize = integer()

              glGetDebugMessageLogARB

              See external documentation.

       ggeettGGrraapphhiiccssRReesseettSSttaattuussAARRBB(()) -->> eennuumm(())

              glGetGraphicsResetStatusARB

              See external documentation.

       ddrraawwAArrrraayyssIInnssttaanncceeddBBaasseeIInnssttaannccee((MMooddee,, FFiirrsstt,, CCoouunntt,, PPrriimmccoouunntt,,
       BBaasseeiinnssttaannccee)) -->> ookk

              Types:

                 Mode = enum()
                 First = integer()
                 Count = integer()
                 Primcount = integer()
                 Baseinstance = integer()

              Draw multiple instances of a range of elements with offset
              applied to instanced attributes

              _g_l_:_d_r_a_w_A_r_r_a_y_s_I_n_s_t_a_n_c_e_d_B_a_s_e_I_n_s_t_a_n_c_e behaves identically to
              ggll::ddrraawwAArrrraayyss//33 except that _P_r_i_m_c_o_u_n_t instances of the range of
              elements are executed and the value of the internal counter
              _I_n_s_t_a_n_c_e_I_D advances for each iteration. _I_n_s_t_a_n_c_e_I_D is an
              internal 32-bit integer counter that may be read by a vertex
              shader as _?_g_l___I_n_s_t_a_n_c_e_I_D .

              _g_l_:_d_r_a_w_A_r_r_a_y_s_I_n_s_t_a_n_c_e_d_B_a_s_e_I_n_s_t_a_n_c_e has the same effect as: if (
              mode or count is invalid ) generate appropriate error else { for
              (int i = 0; i < primcount ; i++) { instanceID = i;
              glDrawArrays(mode, first, count); } instanceID = 0; }

              Specific vertex attributes may be classified as _i_n_s_t_a_n_c_e_d
              through the use of ggll::vveerrtteexxAAttttrriibbDDiivviissoorr//22 . Instanced vertex
              attributes supply per-instance vertex data to the vertex shader.
              The index of the vertex fetched from the enabled instanced
              vertex attribute arrays is calculated as: |gl_
              InstanceID/divisor|&plus; baseInstance. Note that _B_a_s_e_i_n_s_t_a_n_c_e
              does not affect the shader-visible value of _?_g_l___I_n_s_t_a_n_c_e_I_D.

              See external documentation.

       ddrraawwEElleemmeennttssIInnssttaanncceeddBBaasseeIInnssttaannccee((MMooddee,, CCoouunntt,, TTyyppee,, IInnddiicceess,,
       PPrriimmccoouunntt,, BBaasseeiinnssttaannccee)) -->> ookk

              Types:

                 Mode = enum()
                 Count = integer()
                 Type = enum()
                 Indices = offset() | mem()
                 Primcount = integer()
                 Baseinstance = integer()

              Draw multiple instances of a set of elements with offset applied
              to instanced attributes

              _g_l_:_d_r_a_w_E_l_e_m_e_n_t_s_I_n_s_t_a_n_c_e_d_B_a_s_e_I_n_s_t_a_n_c_e behaves identically to
              ggll::ddrraawwEElleemmeennttss//44 except that _P_r_i_m_c_o_u_n_t instances of the set of
              elements are executed and the value of the internal counter
              _I_n_s_t_a_n_c_e_I_D advances for each iteration. _I_n_s_t_a_n_c_e_I_D is an
              internal 32-bit integer counter that may be read by a vertex
              shader as _?_g_l___I_n_s_t_a_n_c_e_I_D .

              _g_l_:_d_r_a_w_E_l_e_m_e_n_t_s_I_n_s_t_a_n_c_e_d_B_a_s_e_I_n_s_t_a_n_c_e has the same effect as: if
              (mode, count, or type is invalid ) generate appropriate error
              else { for (int i = 0; i < primcount ; i++) { instanceID = i;
              glDrawElements(mode, count, type, indices); } instanceID = 0; }

              Specific vertex attributes may be classified as _i_n_s_t_a_n_c_e_d
              through the use of ggll::vveerrtteexxAAttttrriibbDDiivviissoorr//22 . Instanced vertex
              attributes supply per-instance vertex data to the vertex shader.
              The index of the vertex fetched from the enabled instanced
              vertex attribute arrays is calculated as |gl_
              InstanceID/divisor|&plus; baseInstance. Note that _B_a_s_e_i_n_s_t_a_n_c_e
              does not affect the shader-visible value of _?_g_l___I_n_s_t_a_n_c_e_I_D.

              See external documentation.

       ddrraawwEElleemmeennttssIInnssttaanncceeddBBaasseeVVeerrtteexxBBaasseeIInnssttaannccee((MMooddee,, CCoouunntt,, TTyyppee,, IInnddiicceess,,
       PPrriimmccoouunntt,, BBaasseevveerrtteexx,, BBaasseeiinnssttaannccee)) -->> ookk

              Types:

                 Mode = enum()
                 Count = integer()
                 Type = enum()
                 Indices = offset() | mem()
                 Primcount = integer()
                 Basevertex = integer()
                 Baseinstance = integer()

              Render multiple instances of a set of primitives from array data
              with a per-element offset

              _g_l_:_d_r_a_w_E_l_e_m_e_n_t_s_I_n_s_t_a_n_c_e_d_B_a_s_e_V_e_r_t_e_x_B_a_s_e_I_n_s_t_a_n_c_e behaves
              identically to ggll::ddrraawwEElleemmeennttssIInnssttaanncceedd//55 except that the _ith
              element transferred by the corresponding draw call will be taken
              from element _I_n_d_i_c_e_s [i] + _B_a_s_e_v_e_r_t_e_x of each enabled array. If
              the resulting value is larger than the maximum value
              representable by _T_y_p_e , it is as if the calculation were
              upconverted to 32-bit unsigned integers (with wrapping on
              overflow conditions). The operation is undefined if the sum
              would be negative. The _B_a_s_e_v_e_r_t_e_x has no effect on the shader-
              visible value of _?_g_l___V_e_r_t_e_x_I_D.

              Specific vertex attributes may be classified as _i_n_s_t_a_n_c_e_d
              through the use of ggll::vveerrtteexxAAttttrriibbDDiivviissoorr//22 . Instanced vertex
              attributes supply per-instance vertex data to the vertex shader.
              The index of the vertex fetched from the enabled instanced
              vertex attribute arrays is calculated as |gl_
              InstanceID/divisor|&plus; baseInstance. Note that _B_a_s_e_i_n_s_t_a_n_c_e
              does not affect the shader-visible value of _?_g_l___I_n_s_t_a_n_c_e_I_D.

              See external documentation.

       ddrraawwTTrraannssffoorrmmFFeeeeddbbaacckkIInnssttaanncceedd((MMooddee,, IIdd,, PPrriimmccoouunntt)) -->> ookk

              Types:

                 Mode = enum()
                 Id = integer()
                 Primcount = integer()

              glDrawTransformFeedbackInstance

              See external documentation.

       ddrraawwTTrraannssffoorrmmFFeeeeddbbaacckkSSttrreeaammIInnssttaanncceedd((MMooddee,, IIdd,, SSttrreeaamm,, PPrriimmccoouunntt)) -->> ookk

              Types:

                 Mode = enum()
                 Id = integer()
                 Stream = integer()
                 Primcount = integer()

              glDrawTransformFeedbackStreamInstance

              See external documentation.

       ggeettIInntteerrnnaallffoorrmmaattiivv((TTaarrggeett,, IInntteerrnnaallffoorrmmaatt,, PPnnaammee,, BBuuffSSiizzee)) -->>
       [[iinntteeggeerr(())]]

              Types:

                 Target = enum()
                 Internalformat = enum()
                 Pname = enum()
                 BufSize = integer()

              glGetInternalformat

              See external documentation.

       bbiinnddIImmaaggeeTTeexxttuurree((UUnniitt,, TTeexxttuurree,, LLeevveell,, LLaayyeerreedd,, LLaayyeerr,, AAcccceessss,, FFoorrmmaatt))
       -->> ookk

              Types:

                 Unit = integer()
                 Texture = integer()
                 Level = integer()
                 Layered = 0 | 1
                 Layer = integer()
                 Access = enum()
                 Format = enum()

              Bind a level of a texture to an image unit

              _g_l_:_b_i_n_d_I_m_a_g_e_T_e_x_t_u_r_e binds a single level of a texture to an
              image unit for the purpose of reading and writing it from
              shaders. _U_n_i_t specifies the zero-based index of the image unit
              to which to bind the texture level. _T_e_x_t_u_r_e specifies the name
              of an existing texture object to bind to the image unit. If
              _T_e_x_t_u_r_e is zero, then any existing binding to the image unit is
              broken. _L_e_v_e_l specifies the level of the texture to bind to the
              image unit.

              If _T_e_x_t_u_r_e is the name of a one-, two-, or three-dimensional
              array texture, a cube map or cube map array texture, or a two-
              dimensional multisample array texture, then it is possible to
              bind either the entire array, or only a single layer of the
              array to the image unit. In such cases, if _L_a_y_e_r_e_d is _?_G_L___T_R_U_E,
              the entire array is attached to the image unit and _L_a_y_e_r is
              ignored. However, if _L_a_y_e_r_e_d is _?_G_L___F_A_L_S_E then _L_a_y_e_r specifies
              the layer of the array to attach to the image unit.

              _A_c_c_e_s_s specifies the access types to be performed by shaders and
              may be set to _?_G_L___R_E_A_D___O_N_L_Y , _?_G_L___W_R_I_T_E___O_N_L_Y, or _?_G_L___R_E_A_D___W_R_I_T_E
              to indicate read-only, write-only or read-write access,
              respectively. Violation of the access type specified in _A_c_c_e_s_s
              (for example, if a shader writes to an image bound with _A_c_c_e_s_s
              set to _?_G_L___R_E_A_D___O_N_L_Y ) will lead to undefined results, possibly
              including program termination.

              _F_o_r_m_a_t specifies the format that is to be used when performing
              formatted stores into the image from shaders. _F_o_r_m_a_t must be
              compatible with the texture's internal format and must be one of
              the formats listed in the following table._I_m_a_g_e _U_n_i_t
              _F_o_r_m_a_t_F_o_r_m_a_t _Q_u_a_l_i_f_i_e_r
              _?_G_L___R_G_B_A_3_2_Frgba32f
              _?_G_L___R_G_B_A_1_6_F rgba16f
              _?_G_L___R_G_3_2_Frg32f
              _?_G_L___R_G_1_6_F rg16f
              _?_G_L___R_1_1_F___G_1_1_F___B_1_0_Fr11f_g11f_b10f
              _?_G_L___R_3_2_Fr32f
              _?_G_L___R_1_6_Fr16f
              _?_G_L___R_G_B_A_3_2_U_Irgba32ui
              _?_G_L___R_G_B_A_1_6_U_I rgba16ui
              _?_G_L___R_G_B_1_0___A_2_U_Irgb10_a2ui
              _?_G_L___R_G_B_A_8_U_I rgba8ui
              _?_G_L___R_G_3_2_U_Irg32ui
              _?_G_L___R_G_1_6_U_I rg16ui
              _?_G_L___R_G_8_U_Irg8ui
              _?_G_L___R_3_2_U_I r32ui
              _?_G_L___R_1_6_U_Ir16ui
              _?_G_L___R_8_U_I r8ui
              _?_G_L___R_G_B_A_3_2_Irgba32i
              _?_G_L___R_G_B_A_1_6_I rgba16i
              _?_G_L___R_G_B_A_8_Irgba8i
              _?_G_L___R_G_3_2_I rg32i
              _?_G_L___R_G_1_6_Irg16i
              _?_G_L___R_G_8_I rg8i
              _?_G_L___R_3_2_Ir32i
              _?_G_L___R_1_6_I r16i
              _?_G_L___R_8_Ir8i
              _?_G_L___R_G_B_A_1_6 rgba16
              _?_G_L___R_G_B_1_0___A_2rgb10_a2
              _?_G_L___R_G_B_A_8 rgba8
              _?_G_L___R_G_1_6rg16
              _?_G_L___R_G_8 rg8
              _?_G_L___R_1_6r16
              _?_G_L___R_8 r8
              _?_G_L___R_G_B_A_1_6___S_N_O_R_Mrgba16_snorm
              _?_G_L___R_G_B_A_8___S_N_O_R_M rgba8_snorm
              _?_G_L___R_G_1_6___S_N_O_R_Mrg16_snorm
              _?_G_L___R_G_8___S_N_O_R_Mrg8_snorm
              _?_G_L___R_1_6___S_N_O_R_Mr16_snorm
              _?_G_L___R_8___S_N_O_R_Mr8_snorm


              When a texture is bound to an image unit, the _F_o_r_m_a_t parameter
              for the image unit need not exactly match the texture internal
              format as long as the formats are considered compatible as
              defined in the OpenGL Specification. The matching criterion used
              for a given texture may be determined by calling
              ggll::ggeettTTeexxPPaarraammeetteerrffvv//22 with _V_a_l_u_e set to
              _?_G_L___I_M_A_G_E___F_O_R_M_A_T___C_O_M_P_A_T_I_B_I_L_I_T_Y___T_Y_P_E, with return values of
              _?_G_L___I_M_A_G_E___F_O_R_M_A_T___C_O_M_P_A_T_I_B_I_L_I_T_Y___B_Y___S_I_Z_E and
              _?_G_L___I_M_A_G_E___F_O_R_M_A_T___C_O_M_P_A_T_I_B_I_L_I_T_Y___B_Y___C_L_A_S_S, specifying matches by
              size and class, respectively.

              See external documentation.

       mmeemmoorryyBBaarrrriieerr((BBaarrrriieerrss)) -->> ookk

              Types:

                 Barriers = integer()

              Defines a barrier ordering memory transactions

              _g_l_:_m_e_m_o_r_y_B_a_r_r_i_e_r defines a barrier ordering the memory
              transactions issued prior to the command relative to those
              issued after the barrier. For the purposes of this ordering,
              memory transactions performed by shaders are considered to be
              issued by the rendering command that triggered the execution of
              the shader. _B_a_r_r_i_e_r_s is a bitfield indicating the set of
              operations that are synchronized with shader stores; the bits
              used in _B_a_r_r_i_e_r_s are as follows:

              _?_G_L___V_E_R_T_E_X___A_T_T_R_I_B___A_R_R_A_Y___B_A_R_R_I_E_R___B_I_T: If set, vertex data sourced
              from buffer objects after the barrier will reflect data written
              by shaders prior to the barrier. The set of buffer objects
              affected by this bit is derived from the buffer object bindings
              used for generic vertex attributes derived from the
              _?_G_L___V_E_R_T_E_X___A_T_T_R_I_B___A_R_R_A_Y___B_U_F_F_E_R bindings.

              _?_G_L___E_L_E_M_E_N_T___A_R_R_A_Y___B_A_R_R_I_E_R___B_I_T: If set, vertex array indices
              sourced from buffer objects after the barrier will reflect data
              written by shaders prior to the barrier. The buffer objects
              affected by this bit are derived from the
              _?_G_L___E_L_E_M_E_N_T___A_R_R_A_Y___B_U_F_F_E_R binding.

              _?_G_L___U_N_I_F_O_R_M___B_A_R_R_I_E_R___B_I_T: Shader uniforms sourced from buffer
              objects after the barrier will reflect data written by shaders
              prior to the barrier.

              _?_G_L___T_E_X_T_U_R_E___F_E_T_C_H___B_A_R_R_I_E_R___B_I_T: Texture fetches from shaders,
              including fetches from buffer object memory via buffer textures,
              after the barrier will reflect data written by shaders prior to
              the barrier.

              _?_G_L___S_H_A_D_E_R___I_M_A_G_E___A_C_C_E_S_S___B_A_R_R_I_E_R___B_I_T: Memory accesses using
              shader image load, store, and atomic built-in functions issued
              after the barrier will reflect data written by shaders prior to
              the barrier. Additionally, image stores and atomics issued after
              the barrier will not execute until all memory accesses (e.g.,
              loads, stores, texture fetches, vertex fetches) initiated prior
              to the barrier complete.

              _?_G_L___C_O_M_M_A_N_D___B_A_R_R_I_E_R___B_I_T: Command data sourced from buffer
              objects by Draw*Indirect commands after the barrier will reflect
              data written by shaders prior to the barrier. The buffer objects
              affected by this bit are derived from the
              _?_G_L___D_R_A_W___I_N_D_I_R_E_C_T___B_U_F_F_E_R binding.

              _?_G_L___P_I_X_E_L___B_U_F_F_E_R___B_A_R_R_I_E_R___B_I_T: Reads and writes of buffer objects
              via the _?_G_L___P_I_X_E_L___P_A_C_K___B_U_F_F_E_R and _?_G_L___P_I_X_E_L___U_N_P_A_C_K___B_U_F_F_E_R
              bindings (via ggll::rreeaaddPPiixxeellss//77 , ggll::tteexxSSuubbIImmaaggee11DD//77 , etc.) after
              the barrier will reflect data written by shaders prior to the
              barrier. Additionally, buffer object writes issued after the
              barrier will wait on the completion of all shader writes
              initiated prior to the barrier.

              _?_G_L___T_E_X_T_U_R_E___U_P_D_A_T_E___B_A_R_R_I_E_R___B_I_T: Writes to a texture via
              _g_l_:_t_e_x_(_S_u_b_)_I_m_a_g_e_*, _g_l_:_c_o_p_y_T_e_x_(_S_u_b_)_I_m_a_g_e_* ,
              _g_l_:_c_o_m_p_r_e_s_s_e_d_T_e_x_(_S_u_b_)_I_m_a_g_e_*, and reads via ggll::ggeettTTeexxIImmaaggee//55
              after the barrier will reflect data written by shaders prior to
              the barrier. Additionally, texture writes from these commands
              issued after the barrier will not execute until all shader
              writes initiated prior to the barrier complete.

              _?_G_L___B_U_F_F_E_R___U_P_D_A_T_E___B_A_R_R_I_E_R___B_I_T: Reads or writes via
              ggll::bbuuffffeerrSSuubbDDaattaa//44 , ggll::ccooppyyBBuuffffeerrSSuubbDDaattaa//55 , or
              ggll::ggeettBBuuffffeerrSSuubbDDaattaa//44 , or to buffer object memory mapped by see
              _g_l_M_a_p_B_u_f_f_e_r or see _g_l_M_a_p_B_u_f_f_e_r_R_a_n_g_e after the barrier will
              reflect data written by shaders prior to the barrier.
              Additionally, writes via these commands issued after the barrier
              will wait on the completion of any shader writes to the same
              memory initiated prior to the barrier.

              _?_G_L___F_R_A_M_E_B_U_F_F_E_R___B_A_R_R_I_E_R___B_I_T: Reads and writes via framebuffer
              object attachments after the barrier will reflect data written
              by shaders prior to the barrier. Additionally, framebuffer
              writes issued after the barrier will wait on the completion of
              all shader writes issued prior to the barrier.

              _?_G_L___T_R_A_N_S_F_O_R_M___F_E_E_D_B_A_C_K___B_A_R_R_I_E_R___B_I_T: Writes via transform
              feedback bindings after the barrier will reflect data written by
              shaders prior to the barrier. Additionally, transform feedback
              writes issued after the barrier will wait on the completion of
              all shader writes issued prior to the barrier.

              _?_G_L___A_T_O_M_I_C___C_O_U_N_T_E_R___B_A_R_R_I_E_R___B_I_T: Accesses to atomic counters
              after the barrier will reflect writes prior to the barrier.

              If _B_a_r_r_i_e_r_s is _?_G_L___A_L_L___B_A_R_R_I_E_R___B_I_T_S, shader memory accesses will
              be synchronized relative to all the operations described above.

              Implementations may cache buffer object and texture image memory
              that could be written by shaders in multiple caches; for
              example, there may be separate caches for texture, vertex
              fetching, and one or more caches for shader memory accesses.
              Implementations are not required to keep these caches coherent
              with shader memory writes. Stores issued by one invocation may
              not be immediately observable by other pipeline stages or other
              shader invocations because the value stored may remain in a
              cache local to the processor executing the store, or because
              data overwritten by the store is still in a cache elsewhere in
              the system. When _g_l_:_m_e_m_o_r_y_B_a_r_r_i_e_r is called, the GL flushes
              and/or invalidates any caches relevant to the operations
              specified by the _B_a_r_r_i_e_r_s parameter to ensure consistent
              ordering of operations across the barrier.

              To allow for independent shader invocations to communicate by
              reads and writes to a common memory address, image variables in
              the OpenGL Shading Language may be declared as "coherent".
              Buffer object or texture image memory accessed through such
              variables may be cached only if caches are automatically updated
              due to stores issued by any other shader invocation. If the same
              address is accessed using both coherent and non-coherent
              variables, the accesses using variables declared as coherent
              will observe the results stored using coherent variables in
              other invocations. Using variables declared as "coherent"
              guarantees only that the results of stores will be immediately
              visible to shader invocations using similarly-declared
              variables; calling _g_l_:_m_e_m_o_r_y_B_a_r_r_i_e_r is required to ensure that
              the stores are visible to other operations.

              The following guidelines may be helpful in choosing when to use
              coherent memory accesses and when to use barriers.

              Data that are read-only or constant may be accessed without
              using coherent variables or calling MemoryBarrier(). Updates to
              the read-only data via API calls such as BufferSubData will
              invalidate shader caches implicitly as required.

              Data that are shared between shader invocations at a fine
              granularity (e.g., written by one invocation, consumed by
              another invocation) should use coherent variables to read and
              write the shared data.

              Data written by one shader invocation and consumed by other
              shader invocations launched as a result of its execution
              ("dependent invocations") should use coherent variables in the
              producing shader invocation and call memoryBarrier() after the
              last write. The consuming shader invocation should also use
              coherent variables.

              Data written to image variables in one rendering pass and read
              by the shader in a later pass need not use coherent variables or
              memoryBarrier(). Calling MemoryBarrier() with the
              SHADER_IMAGE_ACCESS_BARRIER_BIT set in _B_a_r_r_i_e_r_s between passes
              is necessary.

              Data written by the shader in one rendering pass and read by
              another mechanism (e.g., vertex or index buffer pulling) in a
              later pass need not use coherent variables or memoryBarrier().
              Calling _g_l_:_m_e_m_o_r_y_B_a_r_r_i_e_r with the appropriate bits set in
              _B_a_r_r_i_e_r_s between passes is necessary.

              See external documentation.

       tteexxSSttoorraaggee11DD((TTaarrggeett,, LLeevveellss,, IInntteerrnnaallffoorrmmaatt,, WWiiddtthh)) -->> ookk

              Types:

                 Target = enum()
                 Levels = integer()
                 Internalformat = enum()
                 Width = integer()

              Simultaneously specify storage for all levels of a one-
              dimensional texture

              _g_l_:_t_e_x_S_t_o_r_a_g_e_1_D specifies the storage requirements for all
              levels of a one-dimensional texture simultaneously. Once a
              texture is specified with this command, the format and
              dimensions of all levels become immutable unless it is a proxy
              texture. The contents of the image may still be modified,
              however, its storage requirements may not change. Such a texture
              is referred to as an _i_m_m_u_t_a_b_l_e_-_f_o_r_m_a_t texture.

              Calling _g_l_:_t_e_x_S_t_o_r_a_g_e_1_D is equivalent, assuming no errors are
              generated, to executing the following pseudo-code: for (i = 0; i
              < levels; i++) { glTexImage1D(target, i, internalformat, width,
              0, format, type, NULL); width = max(1, (width / 2)); }

              Since no texture data is actually provided, the values used in
              the pseudo-code for _F_o_r_m_a_t and _T_y_p_e are irrelevant and may be
              considered to be any values that are legal for the chosen
              _I_n_t_e_r_n_a_l_f_o_r_m_a_t enumerant. _I_n_t_e_r_n_a_l_f_o_r_m_a_t must be one of the
              sized internal formats given in Table 1 below, one of the sized
              depth-component formats _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T_3_2_F ,
              _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T_2_4, or _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T_1_6, or one of the
              combined depth-stencil formats, _?_G_L___D_E_P_T_H_3_2_F___S_T_E_N_C_I_L_8, or
              _?_G_L___D_E_P_T_H_2_4___S_T_E_N_C_I_L_8. Upon success, the value of
              _?_G_L___T_E_X_T_U_R_E___I_M_M_U_T_A_B_L_E___F_O_R_M_A_T becomes _?_G_L___T_R_U_E. The value of
              _?_G_L___T_E_X_T_U_R_E___I_M_M_U_T_A_B_L_E___F_O_R_M_A_T may be discovered by calling
              ggll::ggeettTTeexxPPaarraammeetteerrffvv//22 with _P_n_a_m_e set to
              _?_G_L___T_E_X_T_U_R_E___I_M_M_U_T_A_B_L_E___F_O_R_M_A_T. No further changes to the
              dimensions or format of the texture object may be made. Using
              any command that might alter the dimensions or format of the
              texture object (such as ggll::tteexxIImmaaggee11DD//88 or another call to
              _g_l_:_t_e_x_S_t_o_r_a_g_e_1_D) will result in the generation of a
              _?_G_L___I_N_V_A_L_I_D___O_P_E_R_A_T_I_O_N error, even if it would not, in fact,
              alter the dimensions or format of the object.

              See external documentation.

       tteexxSSttoorraaggee22DD((TTaarrggeett,, LLeevveellss,, IInntteerrnnaallffoorrmmaatt,, WWiiddtthh,, HHeeiigghhtt)) -->> ookk

              Types:

                 Target = enum()
                 Levels = integer()
                 Internalformat = enum()
                 Width = integer()
                 Height = integer()

              Simultaneously specify storage for all levels of a two-
              dimensional or one-dimensional array texture

              _g_l_:_t_e_x_S_t_o_r_a_g_e_2_D specifies the storage requirements for all
              levels of a two-dimensional texture or one-dimensional texture
              array simultaneously. Once a texture is specified with this
              command, the format and dimensions of all levels become
              immutable unless it is a proxy texture. The contents of the
              image may still be modified, however, its storage requirements
              may not change. Such a texture is referred to as an _i_m_m_u_t_a_b_l_e_-
              _f_o_r_m_a_t texture.

              The behavior of _g_l_:_t_e_x_S_t_o_r_a_g_e_2_D depends on the _T_a_r_g_e_t parameter.
              When _T_a_r_g_e_t is _?_G_L___T_E_X_T_U_R_E___2_D, _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___2_D,
              _?_G_L___T_E_X_T_U_R_E___R_E_C_T_A_N_G_L_E, _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___R_E_C_T_A_N_G_L_E or
              _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___C_U_B_E___M_A_P, calling _g_l_:_t_e_x_S_t_o_r_a_g_e_2_D is
              equivalent, assuming no errors are generated, to executing the
              following pseudo-code: for (i = 0; i < levels; i++) {
              glTexImage2D(target, i, internalformat, width, height, 0,
              format, type, NULL); width = max(1, (width / 2)); height =
              max(1, (height / 2)); }

              When _T_a_r_g_e_t is _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P, _g_l_:_t_e_x_S_t_o_r_a_g_e_2_D is
              equivalent to: for (i = 0; i < levels; i++) { for (face in (+X,
              -X, +Y, -Y, +Z, -Z)) { glTexImage2D(face, i, internalformat,
              width, height, 0, format, type, NULL); } width = max(1, (width /
              2)); height = max(1, (height / 2)); }

              When _T_a_r_g_e_t is _?_G_L___T_E_X_T_U_R_E___1_D or _?_G_L___T_E_X_T_U_R_E___1_D___A_R_R_A_Y,
              _g_l_:_t_e_x_S_t_o_r_a_g_e_2_D is equivalent to: for (i = 0; i < levels; i++) {
              glTexImage2D(target, i, internalformat, width, height, 0,
              format, type, NULL); width = max(1, (width / 2)); }

              Since no texture data is actually provided, the values used in
              the pseudo-code for _F_o_r_m_a_t and _T_y_p_e are irrelevant and may be
              considered to be any values that are legal for the chosen
              _I_n_t_e_r_n_a_l_f_o_r_m_a_t enumerant. _I_n_t_e_r_n_a_l_f_o_r_m_a_t must be one of the
              sized internal formats given in Table 1 below, one of the sized
              depth-component formats _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T_3_2_F ,
              _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T_2_4, or _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T_1_6, or one of the
              combined depth-stencil formats, _?_G_L___D_E_P_T_H_3_2_F___S_T_E_N_C_I_L_8, or
              _?_G_L___D_E_P_T_H_2_4___S_T_E_N_C_I_L_8. Upon success, the value of
              _?_G_L___T_E_X_T_U_R_E___I_M_M_U_T_A_B_L_E___F_O_R_M_A_T becomes _?_G_L___T_R_U_E. The value of
              _?_G_L___T_E_X_T_U_R_E___I_M_M_U_T_A_B_L_E___F_O_R_M_A_T may be discovered by calling
              ggll::ggeettTTeexxPPaarraammeetteerrffvv//22 with _P_n_a_m_e set to
              _?_G_L___T_E_X_T_U_R_E___I_M_M_U_T_A_B_L_E___F_O_R_M_A_T. No further changes to the
              dimensions or format of the texture object may be made. Using
              any command that might alter the dimensions or format of the
              texture object (such as ggll::tteexxIImmaaggee22DD//99 or another call to
              _g_l_:_t_e_x_S_t_o_r_a_g_e_2_D) will result in the generation of a
              _?_G_L___I_N_V_A_L_I_D___O_P_E_R_A_T_I_O_N error, even if it would not, in fact,
              alter the dimensions or format of the object.

              See external documentation.

       tteexxSSttoorraaggee33DD((TTaarrggeett,, LLeevveellss,, IInntteerrnnaallffoorrmmaatt,, WWiiddtthh,, HHeeiigghhtt,, DDeepptthh)) -->>
       ookk

              Types:

                 Target = enum()
                 Levels = integer()
                 Internalformat = enum()
                 Width = integer()
                 Height = integer()
                 Depth = integer()

              Simultaneously specify storage for all levels of a three-
              dimensional, two-dimensional array or cube-map array texture

              _g_l_:_t_e_x_S_t_o_r_a_g_e_3_D specifies the storage requirements for all
              levels of a three-dimensional, two-dimensional array or cube-map
              array texture simultaneously. Once a texture is specified with
              this command, the format and dimensions of all levels become
              immutable unless it is a proxy texture. The contents of the
              image may still be modified, however, its storage requirements
              may not change. Such a texture is referred to as an _i_m_m_u_t_a_b_l_e_-
              _f_o_r_m_a_t texture.

              The behavior of _g_l_:_t_e_x_S_t_o_r_a_g_e_3_D depends on the _T_a_r_g_e_t parameter.
              When _T_a_r_g_e_t is _?_G_L___T_E_X_T_U_R_E___3_D, or _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___3_D, calling
              _g_l_:_t_e_x_S_t_o_r_a_g_e_3_D is equivalent, assuming no errors are generated,
              to executing the following pseudo-code: for (i = 0; i < levels;
              i++) { glTexImage3D(target, i, internalformat, width, height,
              depth, 0, format, type, NULL); width = max(1, (width / 2));
              height = max(1, (height / 2)); depth = max(1, (depth / 2)); }

              When _T_a_r_g_e_t is _?_G_L___T_E_X_T_U_R_E___2_D___A_R_R_A_Y, _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___2_D___A_R_R_A_Y,
              _?_G_L___T_E_X_T_U_R_E___C_U_B_E___M_A_P___A_R_R_A_Y , or
              _?_G_L___P_R_O_X_Y___T_E_X_T_U_R_E___C_U_B_E___M_A_P___A_R_R_A_Y, _g_l_:_t_e_x_S_t_o_r_a_g_e_3_D is equivalent
              to: for (i = 0; i < levels; i++) { glTexImage3D(target, i,
              internalformat, width, height, depth, 0, format, type, NULL);
              width = max(1, (width / 2)); height = max(1, (height / 2)); }

              Since no texture data is actually provided, the values used in
              the pseudo-code for _F_o_r_m_a_t and _T_y_p_e are irrelevant and may be
              considered to be any values that are legal for the chosen
              _I_n_t_e_r_n_a_l_f_o_r_m_a_t enumerant. _I_n_t_e_r_n_a_l_f_o_r_m_a_t must be one of the
              sized internal formats given in Table 1 below, one of the sized
              depth-component formats _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T_3_2_F ,
              _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T_2_4, or _?_G_L___D_E_P_T_H___C_O_M_P_O_N_E_N_T_1_6, or one of the
              combined depth-stencil formats, _?_G_L___D_E_P_T_H_3_2_F___S_T_E_N_C_I_L_8, or
              _?_G_L___D_E_P_T_H_2_4___S_T_E_N_C_I_L_8. Upon success, the value of
              _?_G_L___T_E_X_T_U_R_E___I_M_M_U_T_A_B_L_E___F_O_R_M_A_T becomes _?_G_L___T_R_U_E. The value of
              _?_G_L___T_E_X_T_U_R_E___I_M_M_U_T_A_B_L_E___F_O_R_M_A_T may be discovered by calling
              ggll::ggeettTTeexxPPaarraammeetteerrffvv//22 with _P_n_a_m_e set to
              _?_G_L___T_E_X_T_U_R_E___I_M_M_U_T_A_B_L_E___F_O_R_M_A_T. No further changes to the
              dimensions or format of the texture object may be made. Using
              any command that might alter the dimensions or format of the
              texture object (such as ggll::tteexxIImmaaggee33DD//1100 or another call to
              _g_l_:_t_e_x_S_t_o_r_a_g_e_3_D) will result in the generation of a
              _?_G_L___I_N_V_A_L_I_D___O_P_E_R_A_T_I_O_N error, even if it would not, in fact,
              alter the dimensions or format of the object.

              See external documentation.

       ddeepptthhBBoouunnddssEEXXTT((ZZmmiinn,, ZZmmaaxx)) -->> ookk

              Types:

                 Zmin = clamp()
                 Zmax = clamp()

              glDepthBoundsEXT

              See external documentation.

       sstteenncciillCClleeaarrTTaaggEEXXTT((SStteenncciillTTaaggBBiittss,, SStteenncciillCClleeaarrTTaagg)) -->> ookk

              Types:

                 StencilTagBits = integer()
                 StencilClearTag = integer()

              glStencilClearTagEXT

              See external documentation.

AAUUTTHHOORRSS
       _<_>



                                   wx 0.99.2                             gl(3)
