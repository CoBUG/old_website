inet(3)                    Erlang Module Definition                    inet(3)



NNAAMMEE
       inet - Access to TCP/IP Protocols

DDEESSCCRRIIPPTTIIOONN
       Provides access to TCP/IP protocols.

       See also _E_R_T_S _U_s_e_r_'_s _G_u_i_d_e_, _I_n_e_t _c_o_n_f_i_g_u_r_a_t_i_o_n for more information on
       how to configure an Erlang runtime system for IP communication.

       Two Kernel configuration parameters affect the behaviour of all sockets
       opened on an Erlang node: _i_n_e_t___d_e_f_a_u_l_t___c_o_n_n_e_c_t___o_p_t_i_o_n_s can contain a
       list of default options used for all sockets returned when doing
       _c_o_n_n_e_c_t, and _i_n_e_t___d_e_f_a_u_l_t___l_i_s_t_e_n___o_p_t_i_o_n_s can contain a list of default
       options used when issuing a _l_i_s_t_e_n call. When _a_c_c_e_p_t is issued, the
       values of the listensocket options are inherited, why no such
       application variable is needed for _a_c_c_e_p_t.

       Using the Kernel configuration parameters mentioned above, one can set
       default options for all TCP sockets on a node. This should be used with
       care, but options like _{_d_e_l_a_y___s_e_n_d_,_t_r_u_e_} might be specified in this
       way. An example of starting an Erlang node with all sockets using
       delayed send could look like this:

       $ erl -sname test -kernel \
       inet_default_connect_options '[{delay_send,true}]' \
       inet_default_listen_options '[{delay_send,true}]'

       Note that the default option _{_a_c_t_i_v_e_, _t_r_u_e_} currently cannot be
       changed, for internal reasons.

       Addresses as inputs to functions can be either a string or a tuple. For
       instance, the IP address 150.236.20.73 can be passed to _g_e_t_h_o_s_t_b_y_a_d_d_r_/_1
       either as the string "150.236.20.73" or as the tuple _{_1_5_0_, _2_3_6_, _2_0_,
       _7_3_}.

       IPv4 address examples:

       Address          ip_address()
       -------          ------------
       127.0.0.1        {127,0,0,1}
       192.168.42.2     {192,168,42,2}

       IPv6 address examples:

       Address          ip_address()
       -------          ------------
       ::1             {0,0,0,0,0,0,0,1}
       ::192.168.42.2  {0,0,0,0,0,0,(192 bsl 8) bor 168,(42 bsl 8) bor 2}
       FFFF::192.168.42.2
                       {16#FFFF,0,0,0,0,0,(192 bsl 8) bor 168,(42 bsl 8) bor 2}
       3ffe:b80:1f8d:2:204:acff:fe17:bf38
                       {16#3ffe,16#b80,16#1f8d,16#2,16#204,16#acff,16#fe17,16#bf38}
       fe80::204:acff:fe17:bf38
                       {16#fe80,0,0,0,0,16#204,16#acff,16#fe17,16#bf38}

       A function that may be useful is _i_n_e_t___p_a_r_s_e_:_a_d_d_r_e_s_s_/_1:

       1> inet_parse:address("192.168.42.2").
       {ok,{192,168,42,2}}
       2> inet_parse:address("FFFF::192.168.42.2").
       {ok,{65535,0,0,0,0,0,49320,10754}}

DDAATTAA TTYYPPEESS
       hhoosstteenntt(()) =
           #hostent{h_name = undefined | iinneett::hhoossttnnaammee(()),
                    h_aliases = [iinneett::hhoossttnnaammee(())],
                    h_addrtype = undefined | inet | inet6,
                    h_length = undefined | integer() >= 0,
                    h_addr_list = [iinneett::iipp__aaddddrreessss(())]}

              The record is defined in the Kernel include file "inet.hrl". Add
              the following directive to the module:

              -include_lib("kernel/include/inet.hrl").

       hhoossttnnaammee(()) = atom() | string()

       iipp__aaddddrreessss(()) = iipp44__aaddddrreessss(()) | iipp66__aaddddrreessss(())

       iipp44__aaddddrreessss(()) = {0..255, 0..255, 0..255, 0..255}

       iipp66__aaddddrreessss(()) =
           {0..65535,
            0..65535,
            0..65535,
            0..65535,
            0..65535,
            0..65535,
            0..65535,
            0..65535}

       ppoorrtt__nnuummbbeerr(()) = 0..65535

       ppoossiixx(()) = exbadport | exbadseq | ffiillee::ppoossiixx(())

              An atom which is named from the Posix error codes used in Unix,
              and in the runtime libraries of most C compilers. See PPOOSSIIXX
              EErrrroorr CCooddeess.

       ssoocckkeett(())

              See ggeenn__ttccpp((33)) and ggeenn__uuddpp((33)).

       aaddddrreessss__ffaammiillyy(()) = inet | inet6

EEXXPPOORRTTSS
       cclloossee((SSoocckkeett)) -->> ookk

              Types:

                 Socket = ssoocckkeett(())

              Closes a socket of any type.

       ggeett__rrcc(()) -->> [[{{PPaarr :::: aannyy(()),, VVaall :::: aannyy(())}}]]

              Returns the state of the Inet configuration database in form of
              a list of recorded configuration parameters. (See the ERTS
              User's Guide, Inet configuration, for more information). Only
              parameters with other than default values are returned.

       ffoorrmmaatt__eerrrroorr((RReeaassoonn)) -->> ssttrriinngg(())

              Types:

                 Reason = ppoossiixx(()) | system_limit

              Returns a diagnostic error string. See the section below for
              possible Posix values and the corresponding strings.

       ggeettaaddddrr((HHoosstt,, FFaammiillyy)) -->> {{ookk,, AAddddrreessss}} || {{eerrrroorr,, ppoossiixx(())}}

              Types:

                 Host = iipp__aaddddrreessss(()) | hhoossttnnaammee(())
                 Family = aaddddrreessss__ffaammiillyy(())
                 Address = iipp__aaddddrreessss(())

              Returns the IP-address for _H_o_s_t as a tuple of integers. _H_o_s_t can
              be an IP-address, a single hostname or a fully qualified
              hostname.

       ggeettaaddddrrss((HHoosstt,, FFaammiillyy)) -->> {{ookk,, AAddddrreesssseess}} || {{eerrrroorr,, ppoossiixx(())}}

              Types:

                 Host = iipp__aaddddrreessss(()) | hhoossttnnaammee(())
                 Family = aaddddrreessss__ffaammiillyy(())
                 Addresses = [iipp__aaddddrreessss(())]

              Returns a list of all IP-addresses for _H_o_s_t. _H_o_s_t can be an IP-
              address, a single hostname or a fully qualified hostname.

       ggeetthhoossttbbyyaaddddrr((AAddddrreessss)) -->> {{ookk,, HHoosstteenntt}} || {{eerrrroorr,, ppoossiixx(())}}

              Types:

                 Address = string() | iipp__aaddddrreessss(())
                 Hostent = hhoosstteenntt(())

              Returns a _h_o_s_t_e_n_t record given an address.

       ggeetthhoossttbbyynnaammee((HHoossttnnaammee)) -->> {{ookk,, HHoosstteenntt}} || {{eerrrroorr,, ppoossiixx(())}}

              Types:

                 Hostname = hhoossttnnaammee(())
                 Hostent = hhoosstteenntt(())

              Returns a _h_o_s_t_e_n_t record given a hostname.

       ggeetthhoossttbbyynnaammee((HHoossttnnaammee,, FFaammiillyy)) -->>
                        {{ookk,, HHoosstteenntt}} || {{eerrrroorr,, ppoossiixx(())}}

              Types:

                 Hostname = hhoossttnnaammee(())
                 Family = aaddddrreessss__ffaammiillyy(())
                 Hostent = hhoosstteenntt(())

              Returns a _h_o_s_t_e_n_t record given a hostname, restricted to the
              given address family.

       ggeetthhoossttnnaammee(()) -->> {{ookk,, HHoossttnnaammee}}

              Types:

                 Hostname = string()

              Returns the local hostname. Will never fail.

       ggeettiiffaaddddrrss(()) -->> {{ookk,, IIfflliisstt}} || {{eerrrroorr,, ppoossiixx(())}}

              Types:

                 Iflist = [{Ifname, [Ifopt]}]
                 Ifname = string()
                 Ifopt = {flag, [Flag]}
                       | {addr, Addr}
                       | {netmask, Netmask}
                       | {broadaddr, Broadaddr}
                       | {dstaddr, Dstaddr}
                       | {hwaddr, Hwaddr}
                 Flag = up
                      | broadcast
                      | loopback
                      | pointtopoint
                      | running
                      | multicast
                 Addr = Netmask = Broadaddr = Dstaddr = iipp__aaddddrreessss(())
                 Hwaddr = [byte()]

              Returns a list of 2-tuples containing interface names and the
              interface's addresses. _I_f_n_a_m_e is a Unicode string. _H_w_a_d_d_r is
              hardware dependent, e.g on Ethernet interfaces it is the 6-byte
              Ethernet address (MAC address (EUI-48 address)).

              The _{_a_d_d_r_,_A_d_d_r_}, _{_n_e_t_m_a_s_k_,___} and _{_b_r_o_a_d_a_d_d_r_,___} tuples are
              repeated in the result list iff the interface has multiple
              addresses. If you come across an interface that has multiple
              _{_f_l_a_g_,___} or _{_h_w_a_d_d_r_,___} tuples you have a really strange
              interface or possibly a bug in this function. The _{_f_l_a_g_,___} tuple
              is mandatory, all other optional.

              Do not rely too much on the order of _F_l_a_g atoms or _I_f_o_p_t tuples.
              There are some rules, though:

                *
                   Immediately after _{_a_d_d_r_,___} follows _{_n_e_t_m_a_s_k_,___}

                *
                   Immediately thereafter follows _{_b_r_o_a_d_a_d_d_r_,___} if the
                  _b_r_o_a_d_c_a_s_t flag is _n_o_t set and the _p_o_i_n_t_t_o_p_o_i_n_t flag _i_s set.

                *
                   Any _{_n_e_t_m_a_s_k_,___}, _{_b_r_o_a_d_a_d_d_r_,___} or _{_d_s_t_a_d_d_r_,___} tuples that
                  follow an _{_a_d_d_r_,___} tuple concerns that address.

              The _{_h_w_a_d_d_r_,___} tuple is not returned on Solaris since the
              hardware address historically belongs to the link layer and only
              the superuser can read such addresses.

              On Windows, the data is fetched from quite different OS API
              functions, so the _N_e_t_m_a_s_k and _B_r_o_a_d_a_d_d_r values may be
              calculated, just as some _F_l_a_g values. You have been warned.
              Report flagrant bugs.

       ggeettooppttss((SSoocckkeett,, OOppttiioonnss)) -->> {{ookk,, OOppttiioonnVVaalluueess}} || {{eerrrroorr,, ppoossiixx(())}}

              Types:

                 Socket = ssoocckkeett(())
                 Options = [ssoocckkeett__ggeettoopptt(())]
                 OptionValues = [ssoocckkeett__sseettoopptt(())]
                 ssoocckkeett__ggeettoopptt(()) = ggeenn__ssccttpp::ooppttiioonn__nnaammee(())
                                 | ggeenn__ttccpp::ooppttiioonn__nnaammee(())
                                 | ggeenn__uuddpp::ooppttiioonn__nnaammee(())
                 ssoocckkeett__sseettoopptt(()) = ggeenn__ssccttpp::ooppttiioonn(())
                                 | ggeenn__ttccpp::ooppttiioonn(())
                                 | ggeenn__uuddpp::ooppttiioonn(())

              Gets one or more options for a socket. See sseettooppttss//22 for a list
              of available options.

              The number of elements in the returned _O_p_t_i_o_n_V_a_l_u_e_s list does
              not necessarily correspond to the number of options asked for.
              If the operating system fails to support an option, it is simply
              left out in the returned list. An error tuple is only returned
              when getting options for the socket is impossible (i.e. the
              socket is closed or the buffer size in a raw request is too
              large). This behavior is kept for backward compatibility
              reasons.

              A raw option request _R_a_w_O_p_t_R_e_q _= _{_r_a_w_, _P_r_o_t_o_c_o_l_, _O_p_t_i_o_n_N_u_m_,
              _V_a_l_u_e_S_p_e_c_} can be used to get information about socket options
              not (explicitly) supported by the emulator. The use of raw
              socket options makes the code non portable, but allows the
              Erlang programmer to take advantage of unusual features present
              on the current platform.

              The _R_a_w_O_p_t_R_e_q consists of the tag _r_a_w followed by the protocol
              level, the option number and either a binary or the size, in
              bytes, of the buffer in which the option value is to be stored.
              A binary should be used when the underlying _g_e_t_s_o_c_k_o_p_t requires
              _i_n_p_u_t in the argument field, in which case the size of the
              binary should correspond to the required buffer size of the
              return value. The supplied values in a _R_a_w_O_p_t_R_e_q correspond to
              the second, third and fourth/fifth parameters to the _g_e_t_s_o_c_k_o_p_t
              call in the C socket API. The value stored in the buffer is
              returned as a binary _V_a_l_u_e_B_i_n where all values are coded in the
              native endianess.

              Asking for and inspecting raw socket options require low level
              information about the current operating system and TCP stack.

              As an example, consider a Linux machine where the _T_C_P___I_N_F_O
              option could be used to collect TCP statistics for a socket.
              Lets say we're interested in the _t_c_p_i___s_a_c_k_e_d field of the _s_t_r_u_c_t
              _t_c_p___i_n_f_o filled in when asking for _T_C_P___I_N_F_O. To be able to
              access this information, we need to know both the numeric value
              of the protocol level _I_P_P_R_O_T_O___T_C_P, the numeric value of the
              option _T_C_P___I_N_F_O, the size of the _s_t_r_u_c_t _t_c_p___i_n_f_o and the size
              and offset of the specific field. By inspecting the headers or
              writing a small C program, we found _I_P_P_R_O_T_O___T_C_P to be 6,
              _T_C_P___I_N_F_O to be 11, the structure size to be 92 (bytes), the
              offset of _t_c_p_i___s_a_c_k_e_d to be 28 bytes and the actual value to be
              a 32 bit integer. We could use the following code to retrieve
              the value:

                      get_tcpi_sacked(Sock) ->
                          {ok,[{raw,_,_,Info}]} = inet:getopts(Sock,[{raw,6,11,92}]),
                          <<_:28/binary,TcpiSacked:32/native,_/binary>> = Info,
                          TcpiSacked.

              Preferably, you would check the machine type, the OS and the
              kernel version prior to executing anything similar to the code
              above.

       ggeettssttaatt((SSoocckkeett)) -->> {{ookk,, OOppttiioonnVVaalluueess}} || {{eerrrroorr,, ppoossiixx(())}}

       ggeettssttaatt((SSoocckkeett,, OOppttiioonnss)) -->> {{ookk,, OOppttiioonnVVaalluueess}} || {{eerrrroorr,, ppoossiixx(())}}

              Types:

                 Socket = ssoocckkeett(())
                 Options = [ssttaatt__ooppttiioonn(())]
                 OptionValues = [{ssttaatt__ooppttiioonn(()), integer()}]
                 ssttaatt__ooppttiioonn(()) = recv_cnt
                               | recv_max
                               | recv_avg
                               | recv_oct
                               | recv_dvi
                               | send_cnt
                               | send_max
                               | send_avg
                               | send_oct
                               | send_pend

              Gets one or more statistic options for a socket.

              _g_e_t_s_t_a_t_(_S_o_c_k_e_t_) is equivalent to _g_e_t_s_t_a_t_(_S_o_c_k_e_t_, _[_r_e_c_v___a_v_g_,
              _r_e_c_v___c_n_t_, _r_e_c_v___d_v_i_, _r_e_c_v___m_a_x_, _r_e_c_v___o_c_t_, _s_e_n_d___a_v_g_, _s_e_n_d___c_n_t_,
              _s_e_n_d___d_v_i_, _s_e_n_d___m_a_x_, _s_e_n_d___o_c_t_]_)

              The following options are available:

                _r_e_c_v___a_v_g:
                  Average size of packets in bytes received to the socket.

                _r_e_c_v___c_n_t:
                  Number of packets received to the socket.

                _r_e_c_v___d_v_i:
                  Average packet size deviation in bytes received to the
                  socket.

                _r_e_c_v___m_a_x:
                  The size of the largest packet in bytes received to the
                  socket.

                _r_e_c_v___o_c_t:
                  Number of bytes received to the socket.

                _s_e_n_d___a_v_g:
                  Average size of packets in bytes sent from the socket.

                _s_e_n_d___c_n_t:
                  Number of packets sent from the socket.

                _s_e_n_d___d_v_i:
                  Average packet size deviation in bytes received sent from
                  the socket.

                _s_e_n_d___m_a_x:
                  The size of the largest packet in bytes sent from the
                  socket.

                _s_e_n_d___o_c_t:
                  Number of bytes sent from the socket.

       ppeeeerrnnaammee((SSoocckkeett)) -->> {{ookk,, {{AAddddrreessss,, PPoorrtt}}}} || {{eerrrroorr,, ppoossiixx(())}}

              Types:

                 Socket = ssoocckkeett(())
                 Address = iipp__aaddddrreessss(())
                 Port = integer() >= 0

              Returns the address and port for the other end of a connection.

       ppoorrtt((SSoocckkeett)) -->> {{ookk,, PPoorrtt}} || {{eerrrroorr,, aannyy(())}}

              Types:

                 Socket = ssoocckkeett(())
                 Port = ppoorrtt__nnuummbbeerr(())

              Returns the local port number for a socket.

       ssoocckknnaammee((SSoocckkeett)) -->> {{ookk,, {{AAddddrreessss,, PPoorrtt}}}} || {{eerrrroorr,, ppoossiixx(())}}

              Types:

                 Socket = ssoocckkeett(())
                 Address = iipp__aaddddrreessss(())
                 Port = integer() >= 0

              Returns the local address and port number for a socket.

       sseettooppttss((SSoocckkeett,, OOppttiioonnss)) -->> ookk || {{eerrrroorr,, ppoossiixx(())}}

              Types:

                 Socket = ssoocckkeett(())
                 Options = [ssoocckkeett__sseettoopptt(())]
                 ssoocckkeett__sseettoopptt(()) = ggeenn__ssccttpp::ooppttiioonn(())
                                 | ggeenn__ttccpp::ooppttiioonn(())
                                 | ggeenn__uuddpp::ooppttiioonn(())

              Sets one or more options for a socket. The following options are
              available:

                _{_a_c_t_i_v_e_, _t_r_u_e _| _f_a_l_s_e _| _o_n_c_e_}:
                  If the value is _t_r_u_e, which is the default, everything
                  received from the socket will be sent as messages to the
                  receiving process. If the value is _f_a_l_s_e (passive mode), the
                  process must explicitly receive incoming data by calling
                  _g_e_n___t_c_p_:_r_e_c_v_/_2_,_3 or _g_e_n___u_d_p_:_r_e_c_v_/_2_,_3 (depending on the type
                  of socket).

                  If the value is _o_n_c_e (_{_a_c_t_i_v_e_, _o_n_c_e_}), _o_n_e data message from
                  the socket will be sent to the process. To receive one more
                  message, _s_e_t_o_p_t_s_/_2 must be called again with the _{_a_c_t_i_v_e_,
                  _o_n_c_e_} option.

                  When using _{_a_c_t_i_v_e_, _o_n_c_e_}, the socket changes behaviour
                  automatically when data is received. This can sometimes be
                  confusing in combination with connection oriented sockets
                  (i.e. _g_e_n___t_c_p) as a socket with _{_a_c_t_i_v_e_, _f_a_l_s_e_} behaviour
                  reports closing differently than a socket with _{_a_c_t_i_v_e_,
                  _t_r_u_e_} behaviour. To make programming easier, a socket where
                  the peer closed and this was detected while in _{_a_c_t_i_v_e_,
                  _f_a_l_s_e_} mode, will still generate the message
                  _{_t_c_p___c_l_o_s_e_d_,_S_o_c_k_e_t_} when set to _{_a_c_t_i_v_e_, _o_n_c_e_} or _{_a_c_t_i_v_e_,
                  _t_r_u_e_} mode. It is therefore safe to assume that the message
                  _{_t_c_p___c_l_o_s_e_d_,_S_o_c_k_e_t_}, possibly followed by socket port
                  termination (depending on the _e_x_i_t___o_n___c_l_o_s_e option) will
                  eventually appear when a socket changes back and forth
                  between _{_a_c_t_i_v_e_, _t_r_u_e_} and _{_a_c_t_i_v_e_, _f_a_l_s_e_} mode. However,
                  _w_h_e_n peer closing is detected is all up to the underlying
                  TCP/IP stack and protocol.

                  Note that _{_a_c_t_i_v_e_,_t_r_u_e_} mode provides no flow control; a
                  fast sender could easily overflow the receiver with incoming
                  messages. Use active mode only if your high-level protocol
                  provides its own flow control (for instance, acknowledging
                  received messages) or the amount of data exchanged is small.
                  _{_a_c_t_i_v_e_,_f_a_l_s_e_} mode or use of the _{_a_c_t_i_v_e_, _o_n_c_e_} mode
                  provides flow control; the other side will not be able send
                  faster than the receiver can read.

                _{_b_i_t_8_, _c_l_e_a_r _| _s_e_t _| _o_n _| _o_f_f_}:
                  Scans every byte in received data-packets and checks if the
                  8 bit is set in any of them. Information is retrieved with
                  _i_n_e_t_:_g_e_t_o_p_t_s_/_2.

                  Note that the _b_i_t_8 option is deprecated and will be removed
                  in Erlang/OTP R16.

                _{_b_r_o_a_d_c_a_s_t_, _B_o_o_l_e_a_n_}(UDP sockets):
                  Enable/disable permission to send broadcasts.

                _{_b_u_f_f_e_r_, _S_i_z_e_}:
                  Determines the size of the user-level software buffer used
                  by the driver. Not to be confused with _s_n_d_b_u_f and _r_e_c_b_u_f
                  options which correspond to the kernel socket buffers. It is
                  recommended to have _v_a_l_(_b_u_f_f_e_r_) _>_=
                  _m_a_x_(_v_a_l_(_s_n_d_b_u_f_)_,_v_a_l_(_r_e_c_b_u_f_)_). In fact, the _v_a_l_(_b_u_f_f_e_r_) is
                  automatically set to the above maximum when _s_n_d_b_u_f or _r_e_c_b_u_f
                  values are set.

                _{_d_e_l_a_y___s_e_n_d_, _B_o_o_l_e_a_n_}:
                  Normally, when an Erlang process sends to a socket, the
                  driver will try to immediately send the data. If that fails,
                  the driver will use any means available to queue up the
                  message to be sent whenever the operating system says it can
                  handle it. Setting _{_d_e_l_a_y___s_e_n_d_, _t_r_u_e_} will make _a_l_l messages
                  queue up. This makes the messages actually sent onto the
                  network be larger but fewer. The option actually affects the
                  scheduling of send requests versus Erlang processes instead
                  of changing any real property of the socket. Needless to say
                  it is an implementation specific option. Default is _f_a_l_s_e.

                _{_d_e_l_i_v_e_r_, _p_o_r_t _| _t_e_r_m_}:
                  When _{_a_c_t_i_v_e_, _t_r_u_e_} delivers data on the forms _p_o_r_t : _{_S_,
                  _{_d_a_t_a_, _[_H_1_,_._._H_s_z _| _D_a_t_a_]_}_} or _t_e_r_m : _{_t_c_p_, _S_, _[_H_1_._._H_s_z _|
                  _D_a_t_a_]_}.

                _{_d_o_n_t_r_o_u_t_e_, _B_o_o_l_e_a_n_}:
                  Enable/disable routing bypass for outgoing messages.

                _{_e_x_i_t___o_n___c_l_o_s_e_, _B_o_o_l_e_a_n_}:
                  By default this option is set to _t_r_u_e.

                  The only reason to set it to _f_a_l_s_e is if you want to
                  continue sending data to the socket after a close has been
                  detected, for instance if the peer has used
                  ggeenn__ttccpp::sshhuuttddoowwnn//22 to shutdown the write side.

                _{_h_e_a_d_e_r_, _S_i_z_e_}:
                  This option is only meaningful if the _b_i_n_a_r_y option was
                  specified when the socket was created. If the _h_e_a_d_e_r option
                  is specified, the first _S_i_z_e number bytes of data received
                  from the socket will be elements of a list, and the rest of
                  the data will be a binary given as the tail of the same
                  list. If for example _S_i_z_e _=_= _2, the data received will match
                  _[_B_y_t_e_1_,_B_y_t_e_2_|_B_i_n_a_r_y_].

                _{_h_i_g_h___w_a_t_e_r_m_a_r_k_, _S_i_z_e_}:
                  Sender is forced busy if sent and enqueued data reaches the
                  highwater mark.
                  Default: 8192 kB.

                _{_k_e_e_p_a_l_i_v_e_, _B_o_o_l_e_a_n_}(TCP/IP sockets):
                  Enables/disables periodic transmission on a connected
                  socket, when no other data is being exchanged. If the other
                  end does not respond, the connection is considered broken
                  and an error message will be sent to the controlling
                  process. Default disabled.

                _{_l_i_n_g_e_r_, _{_t_r_u_e_|_f_a_l_s_e_, _S_e_c_o_n_d_s_}_}:
                  Determines the timeout in seconds for flushing unsent data
                  in the _c_l_o_s_e_/_1 socket call. If the 1st component of the
                  value tuple is _f_a_l_s_e, the 2nd one is ignored, which means
                  that _c_l_o_s_e_/_1 returns immediately not waiting for data to be
                  flushed. Otherwise, the 2nd component is the flushing time-
                  out in seconds.

                _{_l_o_w___w_a_t_e_r_m_a_r_k_, _S_i_z_e_}:
                  If the port has reached its _h_i_g_h___w_a_t_e_r_m_a_r_k it will force
                  busy onto senders. When the port data queue reaches the
                  _l_o_w___w_a_t_e_r_m_a_r_k callers are no longer forced busy.
                  Default: 4096 kB.

                _{_m_o_d_e_, _M_o_d_e _:_: _b_i_n_a_r_y _| _l_i_s_t_}:
                  Received _P_a_c_k_e_t is delivered as defined by Mode.

                _l_i_s_t:
                  Received _P_a_c_k_e_t is delivered as a list.

                _b_i_n_a_r_y:
                  Received _P_a_c_k_e_t is delivered as a binary.

                _{_n_o_d_e_l_a_y_, _B_o_o_l_e_a_n_}(TCP/IP sockets):
                  If _B_o_o_l_e_a_n _=_= _t_r_u_e, the _T_C_P___N_O_D_E_L_A_Y option is turned on for
                  the socket, which means that even small amounts of data will
                  be sent immediately.

                _{_p_a_c_k_e_t_, _P_a_c_k_e_t_T_y_p_e_}(TCP/IP sockets):
                  Defines the type of packets to use for a socket. The
                  following values are valid:

                  _r_a_w _| _0:
                    No packaging is done.

                  _1 _| _2 _| _4:
                    Packets consist of a header specifying the number of bytes
                    in the packet, followed by that number of bytes. The
                    length of header can be one, two, or four bytes;
                    containing an unsigned integer in big-endian byte order.
                    Each send operation will generate the header, and the
                    header will be stripped off on each receive operation.

                    In current implementation the 4-byte header is limited to
                    2Gb.

                  _a_s_n_1 _| _c_d_r _| _s_u_n_r_m _| _f_c_g_i _| _t_p_k_t _| _l_i_n_e:
                    These packet types only have effect on receiving. When
                    sending a packet, it is the responsibility of the
                    application to supply a correct header. On receiving,
                    however, there will be one message sent to the controlling
                    process for each complete packet received, and, similarly,
                    each call to _g_e_n___t_c_p_:_r_e_c_v_/_2_,_3 returns one complete packet.
                    The header is _n_o_t stripped off.

                    The meanings of the packet types are as follows:
                    _a_s_n_1 - ASN.1 BER,
                    _s_u_n_r_m - Sun's RPC encoding,
                    _c_d_r - CORBA (GIOP 1.1),
                    _f_c_g_i - Fast CGI,
                    _t_p_k_t - TPKT format [RFC1006],
                    _l_i_n_e - Line mode, a packet is a line terminated with
                    newline, lines longer than the receive buffer are
                    truncated.

                  _h_t_t_p _| _h_t_t_p___b_i_n:
                    The Hypertext Transfer Protocol. The packets are returned
                    with the format according to _H_t_t_p_P_a_c_k_e_t described in
                    eerrllaanngg::ddeeccooddee__ppaacckkeett//33. A socket in passive mode will
                    return _{_o_k_, _H_t_t_p_P_a_c_k_e_t_} from _g_e_n___t_c_p_:_r_e_c_v while an active
                    socket will send messages like _{_h_t_t_p_, _S_o_c_k_e_t_, _H_t_t_p_P_a_c_k_e_t_}.

                  _h_t_t_p_h _| _h_t_t_p_h___b_i_n:
                    These two types are often not needed as the socket will
                    automatically switch from _h_t_t_p/_h_t_t_p___b_i_n to _h_t_t_p_h/_h_t_t_p_h___b_i_n
                    internally after the first line has been read. There might
                    be occasions however when they are useful, such as parsing
                    trailers from chunked encoding.

                _{_p_a_c_k_e_t___s_i_z_e_, _I_n_t_e_g_e_r_}(TCP/IP sockets):
                  Sets the max allowed length of the packet body. If the
                  packet header indicates that the length of the packet is
                  longer than the max allowed length, the packet is considered
                  invalid. The same happens if the packet header is too big
                  for the socket receive buffer.

                  For line oriented protocols (_l_i_n_e,_h_t_t_p_*), option _p_a_c_k_e_t___s_i_z_e
                  also guarantees that lines up to the indicated length are
                  accepted and not considered invalid due to internal buffer
                  limitations.

                _{_p_r_i_o_r_i_t_y_, _P_r_i_o_r_i_t_y_}:
                  Set the protocol-defined priority for all packets to be sent
                  on this socket.

                _{_r_a_w_, _P_r_o_t_o_c_o_l_, _O_p_t_i_o_n_N_u_m_, _V_a_l_u_e_B_i_n_}:
                  See below.

                _{_r_e_a_d___p_a_c_k_e_t_s_, _I_n_t_e_g_e_r_}(UDP sockets):
                  Sets the max number of UDP packets to read without
                  intervention from the socket when data is available. When
                  this many packets have been read and delivered to the
                  destination process, new packets are not read until a new
                  notification of available data has arrived. The default is
                  5, and if this parameter is set too high the system can
                  become unresponsive due to UDP packet flooding.

                _{_r_e_c_b_u_f_, _S_i_z_e_}:
                  Gives the size of the receive buffer to use for the socket.

                _{_r_e_u_s_e_a_d_d_r_, _B_o_o_l_e_a_n_}:
                  Allows or disallows local reuse of port numbers. By default,
                  reuse is disallowed.

                _{_s_e_n_d___t_i_m_e_o_u_t_, _I_n_t_e_g_e_r_}:
                  Only allowed for connection oriented sockets.

                  Specifies a longest time to wait for a send operation to be
                  accepted by the underlying TCP stack. When the limit is
                  exceeded, the send operation will return _{_e_r_r_o_r_,_t_i_m_e_o_u_t_}.
                  How much of a packet that actually got sent is unknown, why
                  the socket should be closed whenever a timeout has occurred
                  (see _s_e_n_d___t_i_m_e_o_u_t___c_l_o_s_e). Default is _i_n_f_i_n_i_t_y.

                _{_s_e_n_d___t_i_m_e_o_u_t___c_l_o_s_e_, _B_o_o_l_e_a_n_}:
                  Only allowed for connection oriented sockets.

                  Used together with _s_e_n_d___t_i_m_e_o_u_t to specify whether the
                  socket will be automatically closed when the send operation
                  returns _{_e_r_r_o_r_,_t_i_m_e_o_u_t_}. The recommended setting is _t_r_u_e
                  which will automatically close the socket. Default is _f_a_l_s_e
                  due to backward compatibility.

                _{_s_n_d_b_u_f_, _S_i_z_e_}:
                  Gives the size of the send buffer to use for the socket.

                _{_p_r_i_o_r_i_t_y_, _I_n_t_e_g_e_r_}:
                  Sets the SO_PRIORITY socket level option on platforms where
                  this is implemented. The behaviour and allowed range varies
                  on different systems. The option is ignored on platforms
                  where the option is not implemented. Use with caution.

                _{_t_o_s_, _I_n_t_e_g_e_r_}:
                  Sets IP_TOS IP level options on platforms where this is
                  implemented. The behaviour and allowed range varies on
                  different systems. The option is ignored on platforms where
                  the option is not implemented. Use with caution.

              In addition to the options mentioned above, _r_a_w option
              specifications can be used. The raw options are specified as a
              tuple of arity four, beginning with the tag _r_a_w, followed by the
              protocol level, the option number and the actual option value
              specified as a binary. This corresponds to the second, third and
              fourth argument to the _s_e_t_s_o_c_k_o_p_t call in the C socket API. The
              option value needs to be coded in the native endianess of the
              platform and, if a structure is required, needs to follow the
              struct alignment conventions on the specific platform.

              Using raw socket options require detailed knowledge about the
              current operating system and TCP stack.

              As an example of the usage of raw options, consider a Linux
              system where you want to set the _T_C_P___L_I_N_G_E_R_2 option on the
              _I_P_P_R_O_T_O___T_C_P protocol level in the stack. You know that on this
              particular system it defaults to 60 (seconds), but you would
              like to lower it to 30 for a particular socket. The _T_C_P___L_I_N_G_E_R_2
              option is not explicitly supported by inet, but you know that
              the protocol level translates to the number 6, the option number
              to the number 8 and the value is to be given as a 32 bit
              integer. You can use this line of code to set the option for the
              socket named _S_o_c_k:

                      inet:setopts(Sock,[{raw,6,8,<<30:32/native>>}]),

              As many options are silently discarded by the stack if they are
              given out of range, it could be a good idea to check that a raw
              option really got accepted. This code places the value in the
              variable TcpLinger2:

                      {ok,[{raw,6,8,<<TcpLinger2:32/native>>}]}=inet:getopts(Sock,[{raw,6,8,4}]),

              Code such as the examples above is inherently non portable, even
              different versions of the same OS on the same platform may
              respond differently to this kind of option manipulation. Use
              with care.

              Note that the default options for TCP/IP sockets can be changed
              with the Kernel configuration parameters mentioned in the
              beginning of this document.

PPOOSSIIXX EERRRROORR CCOODDEESS
         * _e_2_b_i_g - argument list too long

         * _e_a_c_c_e_s - permission denied

         * _e_a_d_d_r_i_n_u_s_e - address already in use

         * _e_a_d_d_r_n_o_t_a_v_a_i_l - cannot assign requested address

         * _e_a_d_v - advertise error

         * _e_a_f_n_o_s_u_p_p_o_r_t - address family not supported by protocol family

         * _e_a_g_a_i_n - resource temporarily unavailable

         * _e_a_l_i_g_n - EALIGN

         * _e_a_l_r_e_a_d_y - operation already in progress

         * _e_b_a_d_e - bad exchange descriptor

         * _e_b_a_d_f - bad file number

         * _e_b_a_d_f_d - file descriptor in bad state

         * _e_b_a_d_m_s_g - not a data message

         * _e_b_a_d_r - bad request descriptor

         * _e_b_a_d_r_p_c - RPC structure is bad

         * _e_b_a_d_r_q_c - bad request code

         * _e_b_a_d_s_l_t - invalid slot

         * _e_b_f_o_n_t - bad font file format

         * _e_b_u_s_y - file busy

         * _e_c_h_i_l_d - no children

         * _e_c_h_r_n_g - channel number out of range

         * _e_c_o_m_m - communication error on send

         * _e_c_o_n_n_a_b_o_r_t_e_d - software caused connection abort

         * _e_c_o_n_n_r_e_f_u_s_e_d - connection refused

         * _e_c_o_n_n_r_e_s_e_t - connection reset by peer

         * _e_d_e_a_d_l_k - resource deadlock avoided

         * _e_d_e_a_d_l_o_c_k - resource deadlock avoided

         * _e_d_e_s_t_a_d_d_r_r_e_q - destination address required

         * _e_d_i_r_t_y - mounting a dirty fs w/o force

         * _e_d_o_m - math argument out of range

         * _e_d_o_t_d_o_t - cross mount point

         * _e_d_q_u_o_t - disk quota exceeded

         * _e_d_u_p_p_k_g - duplicate package name

         * _e_e_x_i_s_t - file already exists

         * _e_f_a_u_l_t - bad address in system call argument

         * _e_f_b_i_g - file too large

         * _e_h_o_s_t_d_o_w_n - host is down

         * _e_h_o_s_t_u_n_r_e_a_c_h - host is unreachable

         * _e_i_d_r_m - identifier removed

         * _e_i_n_i_t - initialization error

         * _e_i_n_p_r_o_g_r_e_s_s - operation now in progress

         * _e_i_n_t_r - interrupted system call

         * _e_i_n_v_a_l - invalid argument

         * _e_i_o - I/O error

         * _e_i_s_c_o_n_n - socket is already connected

         * _e_i_s_d_i_r - illegal operation on a directory

         * _e_i_s_n_a_m - is a named file

         * _e_l_2_h_l_t - level 2 halted

         * _e_l_2_n_s_y_n_c - level 2 not synchronized

         * _e_l_3_h_l_t - level 3 halted

         * _e_l_3_r_s_t - level 3 reset

         * _e_l_b_i_n - ELBIN

         * _e_l_i_b_a_c_c - cannot access a needed shared library

         * _e_l_i_b_b_a_d - accessing a corrupted shared library

         * _e_l_i_b_e_x_e_c - cannot exec a shared library directly

         * _e_l_i_b_m_a_x - attempting to link in more shared libraries than system
           limit

         * _e_l_i_b_s_c_n - .lib section in a.out corrupted

         * _e_l_n_r_n_g - link number out of range

         * _e_l_o_o_p - too many levels of symbolic links

         * _e_m_f_i_l_e - too many open files

         * _e_m_l_i_n_k - too many links

         * _e_m_s_g_s_i_z_e - message too long

         * _e_m_u_l_t_i_h_o_p - multihop attempted

         * _e_n_a_m_e_t_o_o_l_o_n_g - file name too long

         * _e_n_a_v_a_i_l - not available

         * _e_n_e_t - ENET

         * _e_n_e_t_d_o_w_n - network is down

         * _e_n_e_t_r_e_s_e_t - network dropped connection on reset

         * _e_n_e_t_u_n_r_e_a_c_h - network is unreachable

         * _e_n_f_i_l_e - file table overflow

         * _e_n_o_a_n_o - anode table overflow

         * _e_n_o_b_u_f_s - no buffer space available

         * _e_n_o_c_s_i - no CSI structure available

         * _e_n_o_d_a_t_a - no data available

         * _e_n_o_d_e_v - no such device

         * _e_n_o_e_n_t - no such file or directory

         * _e_n_o_e_x_e_c - exec format error

         * _e_n_o_l_c_k - no locks available

         * _e_n_o_l_i_n_k - link has be severed

         * _e_n_o_m_e_m - not enough memory

         * _e_n_o_m_s_g - no message of desired type

         * _e_n_o_n_e_t - machine is not on the network

         * _e_n_o_p_k_g - package not installed

         * _e_n_o_p_r_o_t_o_o_p_t - bad protocol option

         * _e_n_o_s_p_c - no space left on device

         * _e_n_o_s_r - out of stream resources or not a stream device

         * _e_n_o_s_y_m - unresolved symbol name

         * _e_n_o_s_y_s - function not implemented

         * _e_n_o_t_b_l_k - block device required

         * _e_n_o_t_c_o_n_n - socket is not connected

         * _e_n_o_t_d_i_r - not a directory

         * _e_n_o_t_e_m_p_t_y - directory not empty

         * _e_n_o_t_n_a_m - not a named file

         * _e_n_o_t_s_o_c_k - socket operation on non-socket

         * _e_n_o_t_s_u_p - operation not supported

         * _e_n_o_t_t_y - inappropriate device for ioctl

         * _e_n_o_t_u_n_i_q - name not unique on network

         * _e_n_x_i_o - no such device or address

         * _e_o_p_n_o_t_s_u_p_p - operation not supported on socket

         * _e_p_e_r_m - not owner

         * _e_p_f_n_o_s_u_p_p_o_r_t - protocol family not supported

         * _e_p_i_p_e - broken pipe

         * _e_p_r_o_c_l_i_m - too many processes

         * _e_p_r_o_c_u_n_a_v_a_i_l - bad procedure for program

         * _e_p_r_o_g_m_i_s_m_a_t_c_h - program version wrong

         * _e_p_r_o_g_u_n_a_v_a_i_l - RPC program not available

         * _e_p_r_o_t_o - protocol error

         * _e_p_r_o_t_o_n_o_s_u_p_p_o_r_t - protocol not supported

         * _e_p_r_o_t_o_t_y_p_e - protocol wrong type for socket

         * _e_r_a_n_g_e - math result unrepresentable

         * _e_r_e_f_u_s_e_d - EREFUSED

         * _e_r_e_m_c_h_g - remote address changed

         * _e_r_e_m_d_e_v - remote device

         * _e_r_e_m_o_t_e - pathname hit remote file system

         * _e_r_e_m_o_t_e_i_o - remote i/o error

         * _e_r_e_m_o_t_e_r_e_l_e_a_s_e - EREMOTERELEASE

         * _e_r_o_f_s - read-only file system

         * _e_r_p_c_m_i_s_m_a_t_c_h - RPC version is wrong

         * _e_r_r_e_m_o_t_e - object is remote

         * _e_s_h_u_t_d_o_w_n - cannot send after socket shutdown

         * _e_s_o_c_k_t_n_o_s_u_p_p_o_r_t - socket type not supported

         * _e_s_p_i_p_e - invalid seek

         * _e_s_r_c_h - no such process

         * _e_s_r_m_n_t - srmount error

         * _e_s_t_a_l_e - stale remote file handle

         * _e_s_u_c_c_e_s_s - Error 0

         * _e_t_i_m_e - timer expired

         * _e_t_i_m_e_d_o_u_t - connection timed out

         * _e_t_o_o_m_a_n_y_r_e_f_s - too many references

         * _e_t_x_t_b_s_y - text file or pseudo-device busy

         * _e_u_c_l_e_a_n - structure needs cleaning

         * _e_u_n_a_t_c_h - protocol driver not attached

         * _e_u_s_e_r_s - too many users

         * _e_v_e_r_s_i_o_n - version mismatch

         * _e_w_o_u_l_d_b_l_o_c_k - operation would block

         * _e_x_d_e_v - cross-domain link

         * _e_x_f_u_l_l - message tables full

         * _n_x_d_o_m_a_i_n - the hostname or domain name could not be found

Ericsson AB                      kernel 2.15.2                         inet(3)
