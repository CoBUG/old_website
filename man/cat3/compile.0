compile(3)                 Erlang Module Definition                 compile(3)



NNAAMMEE
       compile - Erlang Compiler

DDEESSCCRRIIPPTTIIOONN
       This module provides an interface to the standard Erlang compiler. It
       can generate either a new file which contains the object code, or
       return a binary which can be loaded directly.

EEXXPPOORRTTSS
       ffiillee((FFiillee))

              Is the same as _f_i_l_e_(_F_i_l_e_,
              _[_v_e_r_b_o_s_e_,_r_e_p_o_r_t___e_r_r_o_r_s_,_r_e_p_o_r_t___w_a_r_n_i_n_g_s_]_).

       ffiillee((FFiillee,, OOppttiioonnss)) -->> CCoommppRReett

              Types:

                 CompRet = ModRet | BinRet | ErrRet
                 ModRet = {ok,ModuleName} | {ok,ModuleName,Warnings}
                 BinRet = {ok,ModuleName,Binary} |
                 {ok,ModuleName,Binary,Warnings}
                 ErrRet = error | {error,Errors,Warnings}

              Compiles the code in the file _F_i_l_e, which is an Erlang source
              code file without the _._e_r_l extension. _O_p_t_i_o_n_s determine the
              behavior of the compiler.

              Returns _{_o_k_,_M_o_d_u_l_e_N_a_m_e_} if successful, or _e_r_r_o_r if there are
              errors. An object code file is created if the compilation
              succeeds with no errors. It is considered to be an error if the
              module name in the source code is not the same as the basename
              of the output file.

              Here follows first all elements of _O_p_t_i_o_n_s that in some way
              control the behavior of the compiler.

                _b_a_s_i_c___v_a_l_i_d_a_t_i_o_n:
                  This option is fast way to test whether a module will
                  compile successfully (mainly useful for code generators that
                  want to verify the code they emit). No code will generated.
                  If warnings are enabled, warnings generated by the _e_r_l___l_i_n_t
                  module (such as warnings for unused variables and functions)
                  will be returned too.

                  Use the _s_t_r_o_n_g___v_a_l_i_d_a_t_i_o_n option to generate all warnings
                  that the compiler would generate.

                _s_t_r_o_n_g___v_a_l_i_d_a_t_i_o_n:
                  Similar to the _b_a_s_i_c___v_a_l_i_d_a_t_i_o_n option, no code will be
                  generated, but more compiler passes will be run to ensure
                  also warnings generated by the optimization passes are
                  generated (such as clauses that will not match or
                  expressions that are guaranteed to fail with an exception at
                  run-time).

                _b_i_n_a_r_y:
                  Causes the compiler to return the object code in a binary
                  instead of creating an object file. If successful, the
                  compiler returns _{_o_k_,_M_o_d_u_l_e_N_a_m_e_,_B_i_n_a_r_y_}.

                _b_i_n___o_p_t___i_n_f_o:
                  The compiler will emit informational warnings about binary
                  matching optimizations (both successful and unsuccessful).
                  See the _E_f_f_i_c_i_e_n_c_y _G_u_i_d_e for further information.

                _c_o_m_p_r_e_s_s_e_d:
                  The compiler will compress the generated object code, which
                  can be useful for embedded systems.

                _d_e_b_u_g___i_n_f_o:


                  Include debug information in the form of abstract code (see
                  TThhee AAbbssttrraacctt FFoorrmmaatt in ERTS User's Guide) in the compiled
                  beam module. Tools such as Debugger, Xref and Cover require
                  the debug information to be included.

                  _W_a_r_n_i_n_g: Source code can be reconstructed from the debug
                  information. Use encrypted debug information (see below) to
                  prevent this.

                  See bbeeaamm__lliibb((33)) for details.

                _{_d_e_b_u_g___i_n_f_o___k_e_y_,_K_e_y_S_t_r_i_n_g_}:


                _{_d_e_b_u_g___i_n_f_o___k_e_y_,_{_M_o_d_e_,_K_e_y_S_t_r_i_n_g_}_}:


                  Include debug information, but encrypt it, so that it cannot
                  be accessed without supplying the key. (To give the
                  _d_e_b_u_g___i_n_f_o option as well is allowed, but is not necessary.)
                  Using this option is a good way to always have the debug
                  information available during testing, yet protect the source
                  code.

                  _M_o_d_e is the type of crypto algorithm to be used for
                  encrypting the debug information. The default type -- and
                  currently the only type -- is _d_e_s_3___c_b_c.

                  See bbeeaamm__lliibb((33)) for details.

                _e_n_c_r_y_p_t___d_e_b_u_g___i_n_f_o:


                  Like the _d_e_b_u_g___i_n_f_o___k_e_y option above, except that the key
                  will be read from an _._e_r_l_a_n_g_._c_r_y_p_t file.

                  See bbeeaamm__lliibb((33)) for details.

                _m_a_k_e_d_e_p:
                  Produce a Makefile rule to track headers dependencies. No
                  object file is produced.

                  By default, this rule is written to _<_F_i_l_e_>_._P_b_e_a_m. However,
                  if the option _b_i_n_a_r_y is set, nothing is written and the rule
                  is returned in _B_i_n_a_r_y.

                  For instance, if one has the following module:

                -module(module).

                -include_lib("eunit/include/eunit.hrl").
                -include("header.hrl").


                  Here is the Makefile rule generated by this option:

                module.beam: module.erl \
                  /usr/local/lib/erlang/lib/eunit/include/eunit.hrl \
                  header.hrl


                _{_m_a_k_e_d_e_p___o_u_t_p_u_t_, _O_u_t_p_u_t_}:
                  Write generated rule(s) to _O_u_t_p_u_t instead of the default
                  _<_F_i_l_e_>_._P_b_e_a_m. _O_u_t_p_u_t can be a filename or an _i_o___d_e_v_i_c_e_(_). To
                  write to stdout, use _s_t_a_n_d_a_r_d___i_o. However if _b_i_n_a_r_y is set,
                  nothing is written to _O_u_t_p_u_t and the result is returned to
                  the caller with _{_o_k_, _M_o_d_u_l_e_N_a_m_e_, _B_i_n_a_r_y_}.

                _{_m_a_k_e_d_e_p___t_a_r_g_e_t_, _T_a_r_g_e_t_}:
                  Change the name of the rule emitted to _T_a_r_g_e_t.

                _m_a_k_e_d_e_p___q_u_o_t_e___t_a_r_g_e_t:
                  Characters in _T_a_r_g_e_t special to make(1) are quoted.

                _m_a_k_e_d_e_p___a_d_d___m_i_s_s_i_n_g:
                  Consider missing headers as generated files and add them to
                  the dependencies.

                _m_a_k_e_d_e_p___p_h_o_n_y:
                  Add a phony target for each dependency.

                _'_P_':
                  Produces a listing of the parsed code after preprocessing
                  and parse transforms, in the file _<_F_i_l_e_>_._P. No object file
                  is produced.

                _'_E_':
                  Produces a listing of the code after all source code
                  transformations have been performed, in the file _<_F_i_l_e_>_._E.
                  No object file is produced.

                _'_S_':
                  Produces a listing of the assembler code in the file
                  _<_F_i_l_e_>_._S. No object file is produced.

                _r_e_p_o_r_t___e_r_r_o_r_s_/_r_e_p_o_r_t___w_a_r_n_i_n_g_s:
                  Causes errors/warnings to be printed as they occur.

                _r_e_p_o_r_t:
                  This is a short form for both _r_e_p_o_r_t___e_r_r_o_r_s and
                  _r_e_p_o_r_t___w_a_r_n_i_n_g_s.

                _r_e_t_u_r_n___e_r_r_o_r_s:
                  If this flag is set, then _{_e_r_r_o_r_,_E_r_r_o_r_L_i_s_t_,_W_a_r_n_i_n_g_L_i_s_t_} is
                  returned when there are errors.

                _r_e_t_u_r_n___w_a_r_n_i_n_g_s:
                  If this flag is set, then an extra field containing
                  _W_a_r_n_i_n_g_L_i_s_t is added to the tuples returned on success.

                _w_a_r_n_i_n_g_s___a_s___e_r_r_o_r_s:
                  Causes warnings to be treated as errors. This option is
                  supported since R13B04.

                _r_e_t_u_r_n:
                  This is a short form for both _r_e_t_u_r_n___e_r_r_o_r_s and
                  _r_e_t_u_r_n___w_a_r_n_i_n_g_s.

                _v_e_r_b_o_s_e:
                  Causes more verbose information from the compiler describing
                  what it is doing.

                _{_s_o_u_r_c_e_,_F_i_l_e_N_a_m_e_}:
                  Sets the value of the source, as returned by
                  _m_o_d_u_l_e___i_n_f_o_(_c_o_m_p_i_l_e_).

                _{_o_u_t_d_i_r_,_D_i_r_}:
                  Sets a new directory for the object code. The current
                  directory is used for output, except when a directory has
                  been specified with this option.

                _e_x_p_o_r_t___a_l_l:
                  Causes all functions in the module to be exported.

                _{_i_,_D_i_r_}:
                  Add _D_i_r to the list of directories to be searched when
                  including a file. When encountering an _-_i_n_c_l_u_d_e or
                  _-_i_n_c_l_u_d_e___l_i_b directive, the compiler searches for header
                  files in the following directories:

                  * _"_._", the current working directory of the file server;

                  * the base name of the compiled file;

                  * the directories specified using the _i option. The
                    directory specified last is searched first.

                _{_d_,_M_a_c_r_o_}:


                _{_d_,_M_a_c_r_o_,_V_a_l_u_e_}:
                  Defines a macro _M_a_c_r_o to have the value _V_a_l_u_e. _M_a_c_r_o is of
                  type atom, and _V_a_l_u_e can be any term. The default _V_a_l_u_e is
                  _t_r_u_e.

                _{_p_a_r_s_e___t_r_a_n_s_f_o_r_m_,_M_o_d_u_l_e_}:
                  Causes the parse transformation function
                  _M_o_d_u_l_e_:_p_a_r_s_e___t_r_a_n_s_f_o_r_m_/_2 to be applied to the parsed code
                  before the code is checked for errors.

                _a_s_m:
                  The input file is expected to be assembler code (default
                  file suffix ".S"). Note that the format of assembler files
                  is not documented, and may change between releases - this
                  option is primarily for internal debugging use.

                _n_o___s_t_r_i_c_t___r_e_c_o_r_d___t_e_s_t_s:
                  This option is not recommended.

                  By default, the generated code for the
                  _R_e_c_o_r_d_#_r_e_c_o_r_d___t_a_g_._f_i_e_l_d operation verifies that the tuple
                  _R_e_c_o_r_d is of the correct size for the record and that the
                  first element is the tag _r_e_c_o_r_d___t_a_g. Use this option to omit
                  the verification code.

                _n_o___e_r_r_o_r___m_o_d_u_l_e___m_i_s_m_a_t_c_h:
                  Normally the compiler verifies that the module name given in
                  the source code is the same as the base name of the output
                  file and refuses to generate an output file if there is a
                  mismatch. If you have a good reason (or other reason) for
                  having a module name unrelated to the name of the output
                  file, this option disables that verification (there will not
                  even be a warning if there is a mismatch).

                _{_n_o___a_u_t_o___i_m_p_o_r_t_,_[_{_F_,_A_}_, _._._._]_}:
                  Makes the function _F_/_A no longer being auto-imported from
                  the module _e_r_l_a_n_g, which resolves BIF name clashes. This
                  option has to be used to resolve name clashes with BIFs
                  auto-imported before R14A, if one wants to call the local
                  function with the same name as an auto-imported BIF without
                  module prefix.

            NNoottee::
                From R14A and forward, the compiler resolves calls without
                module prefix to local or imported functions before trying
                auto-imported BIFs. If the BIF is to be called, use the _e_r_l_a_n_g
                module prefix in the call, not _{ _n_o___a_u_t_o___i_m_p_o_r_t_,_[_{_F_,_A_}_, _._._._]_}


                  If this option is written in the source code, as a _-_c_o_m_p_i_l_e
                  directive, the syntax _F_/_A can be used instead of _{_F_,_A_}.
                  Example:

                -compile({no_auto_import,[error/1]}).

                _n_o___l_i_n_e___i_n_f_o:
                  Omit line number information in order to produce a slightly
                  smaller output file.

              If warnings are turned on (the _r_e_p_o_r_t___w_a_r_n_i_n_g_s option described
              above), the following options control what type of warnings that
              will be generated. With the exception of _{_w_a_r_n___f_o_r_m_a_t_,_V_e_r_b_o_s_i_t_y_}
              all options below have two forms; one _w_a_r_n___x_x_x form to turn on
              the warning and one _n_o_w_a_r_n___x_x_x form to turn off the warning. In
              the description that follows, the form that is used to change
              the default value is listed.

                _{_w_a_r_n___f_o_r_m_a_t_, _V_e_r_b_o_s_i_t_y_}:
                  Causes warnings to be emitted for malformed format strings
                  as arguments to _i_o_:_f_o_r_m_a_t and similar functions. _V_e_r_b_o_s_i_t_y
                  selects the amount of warnings: 0 = no warnings; 1 =
                  warnings for invalid format strings and incorrect number of
                  arguments; 2 = warnings also when the validity could not be
                  checked (for example, when the format string argument is a
                  variable). The default verbosity is 1. Verbosity 0 can also
                  be selected by the option _n_o_w_a_r_n___f_o_r_m_a_t.

                _n_o_w_a_r_n___b_i_f___c_l_a_s_h:
                  This option is removed, it will generate a fatal error if
                  used.

            WWaarrnniinngg::
                Beginning with R14A, the compiler no longer calls the auto-
                imported BIF if the name clashes with a local or explicitly
                imported function and a call without explicit module name is
                issued. Instead the local or imported function is called.
                Still accepting _n_o_w_a_r_n___b_i_f___c_l_a_s_h would makes a module calling
                functions clashing with autoimported BIFs compile with both
                the old and new compilers, but with completely different
                semantics, why the option was removed.

                The use of this option has always been strongly discouraged.
                From OTP R14A and forward it's an error to use it.

                To resolve BIF clashes, use explicit module names or the
                _{_n_o___a_u_t_o___i_m_p_o_r_t_,_[_F_/_A_]_} compiler directive.


                _{_n_o_w_a_r_n___b_i_f___c_l_a_s_h_, _F_A_s_}:
                  This option is removed, it will generate a fatal error if
                  used.

            WWaarrnniinngg::
                The use of this option has always been strongly discouraged.
                From OTP R14A and forward it's an error to use it.

                To resolve BIF clashes, use explicit module names or the
                _{_n_o___a_u_t_o___i_m_p_o_r_t_,_[_F_/_A_]_} compiler directive.


                _w_a_r_n___e_x_p_o_r_t___a_l_l:
                  Causes a warning to be emitted if the _e_x_p_o_r_t___a_l_l option has
                  also been given.

                _w_a_r_n___e_x_p_o_r_t___v_a_r_s:
                  Causes warnings to be emitted for all implicitly exported
                  variables referred to after the primitives where they were
                  first defined. No warnings for exported variables unless
                  they are referred to in some pattern, which is the default,
                  can be selected by the option _n_o_w_a_r_n___e_x_p_o_r_t___v_a_r_s.

                _w_a_r_n___s_h_a_d_o_w___v_a_r_s:
                  Causes warnings to be emitted for "fresh" variables in
                  functional objects or list comprehensions with the same name
                  as some already defined variable. The default is to warn for
                  such variables. No warnings for shadowed variables can be
                  selected by the option _n_o_w_a_r_n___s_h_a_d_o_w___v_a_r_s.

                _n_o_w_a_r_n___u_n_u_s_e_d___f_u_n_c_t_i_o_n:
                  Turns off warnings for unused local functions. By default
                  (_w_a_r_n___u_n_u_s_e_d___f_u_n_c_t_i_o_n), warnings are emitted for all local
                  functions that are not called directly or indirectly by an
                  exported function. The compiler does not include unused
                  local functions in the generated beam file, but the warning
                  is still useful to keep the source code cleaner.

                _{_n_o_w_a_r_n___u_n_u_s_e_d___f_u_n_c_t_i_o_n_, _F_A_s_}:
                  Turns off warnings for unused local functions as
                  _n_o_w_a_r_n___u_n_u_s_e_d___f_u_n_c_t_i_o_n but only for the mentioned local
                  functions. _F_A_s is a tuple _{_N_a_m_e_,_A_r_i_t_y_} or a list of such
                  tuples.

                _n_o_w_a_r_n___d_e_p_r_e_c_a_t_e_d___f_u_n_c_t_i_o_n:
                  Turns off warnings for calls to deprecated functions. By
                  default (_w_a_r_n___d_e_p_r_e_c_a_t_e_d___f_u_n_c_t_i_o_n), warnings are emitted for
                  every call to a function known by the compiler to be
                  deprecated. Note that the compiler does not know about the
                  _-_d_e_p_r_e_c_a_t_e_d_(_) attribute but uses an assembled list of
                  deprecated functions in Erlang/OTP. To do a more general
                  check the _X_r_e_f tool can be used. See also xxrreeff((33)) and the
                  function xxrreeff::mm//11 also accessible through the cc::xxmm//11
                  function.

                _{_n_o_w_a_r_n___d_e_p_r_e_c_a_t_e_d___f_u_n_c_t_i_o_n_, _M_F_A_s_}:
                  Turns off warnings for calls to deprecated functions as
                  _n_o_w_a_r_n___d_e_p_r_e_c_a_t_e_d___f_u_n_c_t_i_o_n but only for the mentioned
                  functions. _M_F_A_s is a tuple _{_M_o_d_u_l_e_,_N_a_m_e_,_A_r_i_t_y_} or a list of
                  such tuples.

                _w_a_r_n___o_b_s_o_l_e_t_e___g_u_a_r_d:
                  Causes warnings to be emitted for calls to old type testing
                  BIFs such as _p_i_d_/_1 and _l_i_s_t_/_1. See the EErrllaanngg RReeffeerreennccee
                  MMaannuuaall for a complete list of type testing BIFs and their
                  old equivalents. No warnings for calls to old type testing
                  BIFs, which is the default, can be selected by the option
                  _n_o_w_a_r_n___o_b_s_o_l_e_t_e___g_u_a_r_d.

                _w_a_r_n___u_n_u_s_e_d___i_m_p_o_r_t:
                  Causes warnings to be emitted for unused imported functions.
                  No warnings for unused imported functions, which is the
                  default, can be selected by the option _n_o_w_a_r_n___u_n_u_s_e_d___i_m_p_o_r_t.

                _n_o_w_a_r_n___u_n_u_s_e_d___v_a_r_s:
                  By default, warnings are emitted for variables which are not
                  used, with the exception of variables beginning with an
                  underscore ("Prolog style warnings"). Use this option to
                  turn off this kind of warnings.

                _n_o_w_a_r_n___u_n_u_s_e_d___r_e_c_o_r_d:
                  Turns off warnings for unused record types. By default
                  (_w_a_r_n___u_n_u_s_e_d___r_e_c_o_r_d_s), warnings are emitted for unused
                  locally defined record types.

              Another class of warnings is generated by the compiler during
              optimization and code generation. They warn about patterns that
              will never match (such as _a_=_b), guards that will always evaluate
              to false, and expressions that will always fail (such as
              _a_t_o_m_+_4_2).

              Note that the compiler does not warn for expressions that it
              does not attempt to optimize. For instance, the compiler tries
              to evaluate _1_/_0, notices that it will cause an exception and
              emits a warning. On the other hand, the compiler is silent about
              the similar expression _X_/_0; because of the variable in it, the
              compiler does not even try to evaluate and therefore it emits no
              warnings.

              Currently, those warnings cannot be disabled (except by
              disabling all warnings).

          WWaarrnniinngg::
              Obviously, the absence of warnings does not mean that there are
              no remaining errors in the code.


              Note that all the options except the include path (_{_i_,_D_i_r_}) can
              also be given in the file with a _-_c_o_m_p_i_l_e_(_[_O_p_t_i_o_n_,_._._._]_).
              attribute. The _-_c_o_m_p_i_l_e_(_) attribute is allowed after function
              definitions.

              Note also that the _{_n_o_w_a_r_n___u_n_u_s_e_d___f_u_n_c_t_i_o_n_, _F_A_s_},
              _{_n_o_w_a_r_n___b_i_f___c_l_a_s_h_, _F_A_s_}, and _{_n_o_w_a_r_n___d_e_p_r_e_c_a_t_e_d___f_u_n_c_t_i_o_n_, _M_F_A_s_}
              options are only recognized when given in files. They are not
              affected by the _w_a_r_n___u_n_u_s_e_d___f_u_n_c_t_i_o_n, _w_a_r_n___b_i_f___c_l_a_s_h, or
              _w_a_r_n___d_e_p_r_e_c_a_t_e_d___f_u_n_c_t_i_o_n options.

              For debugging of the compiler, or for pure curiosity, the
              intermediate code generated by each compiler pass can be
              inspected. A complete list of the options to produce list files
              can be printed by typing _c_o_m_p_i_l_e_:_o_p_t_i_o_n_s_(_) at the Erlang shell
              prompt. The options will be printed in order that the passes are
              executed. If more than one listing option is used, the one
              representing the earliest pass takes effect.

              _U_n_r_e_c_o_g_n_i_z_e_d _o_p_t_i_o_n_s _a_r_e _i_g_n_o_r_e_d_.

              Both _W_a_r_n_i_n_g_L_i_s_t and _E_r_r_o_r_L_i_s_t have the following format:

              [{FileName,[ErrorInfo]}].


              _E_r_r_o_r_I_n_f_o is described below. The file name has been included
              here as the compiler uses the Erlang pre-processor _e_p_p, which
              allows the code to be included in other files. For this reason,
              it is important to know to _w_h_i_c_h file an error or warning line
              number refers.

       ffoorrmmss((FFoorrmmss))

              Is the same as _f_o_r_m_s_(_F_i_l_e_,
              _[_v_e_r_b_o_s_e_,_r_e_p_o_r_t___e_r_r_o_r_s_,_r_e_p_o_r_t___w_a_r_n_i_n_g_s_]_).

       ffoorrmmss((FFoorrmmss,, OOppttiioonnss)) -->> CCoommppRReett

              Types:

                 Forms = [Form]
                 CompRet = BinRet | ErrRet
                 BinRet = {ok,ModuleName,BinaryOrCode} |
                 {ok,ModuleName,BinaryOrCode,Warnings}
                 BinaryOrCode = binary() | term()
                 ErrRet = error | {error,Errors,Warnings}

              Analogous to _f_i_l_e_/_1, but takes a list of forms (in the Erlang
              abstract format representation) as first argument. The option
              _b_i_n_a_r_y is implicit; i.e., no object code file is produced.
              Options that would ordinarily produce a listing file, such as
              'E', will instead cause the internal format for that compiler
              pass (an Erlang term; usually not a binary) to be returned
              instead of a binary.

       ffoorrmmaatt__eerrrroorr((EErrrroorrDDeessccrriippttoorr)) -->> cchhaarrss(())

              Types:

                 ErrorDescriptor = errordesc()

              Uses an _E_r_r_o_r_D_e_s_c_r_i_p_t_o_r and returns a deep list of characters
              which describes the error. This function is usually called
              implicitly when an _E_r_r_o_r_I_n_f_o structure is processed. See below.

       oouuttppuutt__ggeenneerraatteedd((OOppttiioonnss)) -->> ttrruuee || ffaallssee

              Types:

                 Options = [term()]

              Determines whether the compiler would generate a _b_e_a_m file with
              the given options. _t_r_u_e means that a _b_e_a_m file would be
              generated; _f_a_l_s_e means that the compiler would generate some
              listing file, return a binary, or merely check the syntax of the
              source code.

       nnooeennvv__ffiillee((FFiillee,, OOppttiioonnss)) -->> CCoommppRReett

              Works exactly like ffiillee//22, except that the environment variable
              _E_R_L___C_O_M_P_I_L_E_R___O_P_T_I_O_N_S is not consulted.

       nnooeennvv__ffoorrmmss((FFoorrmmss,, OOppttiioonnss)) -->> CCoommppRReett

              Works exactly like ffoorrmmss//22, except that the environment variable
              _E_R_L___C_O_M_P_I_L_E_R___O_P_T_I_O_N_S is not consulted.

       nnooeennvv__oouuttppuutt__ggeenneerraatteedd((OOppttiioonnss)) -->> ttrruuee || ffaallssee

              Types:

                 Options = [term()]

              Works exactly like oouuttppuutt__ggeenneerraatteedd//11, except that the
              environment variable _E_R_L___C_O_M_P_I_L_E_R___O_P_T_I_O_N_S is not consulted.

DDEEFFAAUULLTT CCOOMMPPIILLEERR OOPPTTIIOONNSS
       The (host operating system) environment variable _E_R_L___C_O_M_P_I_L_E_R___O_P_T_I_O_N_S
       can be used to give default compiler options. Its value must be a valid
       Erlang term. If the value is a list, it will be used as is. If it is
       not a list, it will be put into a list.

       The list will be appended to any options given to ffiillee//22, ffoorrmmss//22, and
       oouuttppuutt__ggeenneerraatteedd//22. Use the alternative functions nnooeennvv__ffiillee//22,
       nnooeennvv__ffoorrmmss//22, or nnooeennvv__oouuttppuutt__ggeenneerraatteedd//22 if you don't want the
       environment variable to be consulted (for instance, if you are calling
       the compiler recursively from inside a parse transform).

IINNLLIINNIINNGG
       The compiler can do function inlining within an Erlang module. Inlining
       means that a call to a function is replaced with the function body with
       the arguments replaced with the actual values. The semantics are
       preserved, except if exceptions are generated in the inlined code.
       Exceptions will be reported as occurring in the function the body was
       inlined into. Also, _f_u_n_c_t_i_o_n___c_l_a_u_s_e exceptions will be converted to
       similar _c_a_s_e___c_l_a_u_s_e exceptions.

       When a function is inlined, the original function will be kept if it is
       exported (either by an explicit export or if the _e_x_p_o_r_t___a_l_l option was
       given) or if not all calls to the function were inlined.

       Inlining does not necessarily improve running time. For instance,
       inlining may increase Beam stack usage which will probably be
       detrimental to performance for recursive functions.

       Inlining is never default; it must be explicitly enabled with a
       compiler option or a _-_c_o_m_p_i_l_e_(_) attribute in the source module.

       To enable inlining, either use the _i_n_l_i_n_e option to let the compiler
       decide which functions to inline or _{_i_n_l_i_n_e_,_[_{_N_a_m_e_,_A_r_i_t_y_}_,_._._._]_} to have
       the compiler inline all calls to the given functions. If the option is
       given inside a _c_o_m_p_i_l_e directive in an Erlang module, _{_N_a_m_e_,_A_r_i_t_y_} may
       be written as _N_a_m_e_/_A_r_i_t_y.

       Example of explicit inlining:

       -compile({inline,[pi/0]}).

       pi() -> 3.1416.


       Example of implicit inlining:

       -compile(inline).


       The _{_i_n_l_i_n_e___s_i_z_e_,_S_i_z_e_} option controls how large functions that are
       allowed to be inlined. Default is _2_4, which will keep the size of the
       inlined code roughly the same as the un-inlined version (only
       relatively small functions will be inlined).

       Example:

       %% Aggressive inlining - will increase code size.
       -compile(inline).
       -compile({inline_size,100}).


PPAARRSSEE TTRRAANNSSFFOORRMMAATTIIOONNSS
       Parse transformations are used when a programmer wants to use Erlang
       syntax but with different semantics. The original Erlang code is then
       transformed into other Erlang code.

EERRRROORR IINNFFOORRMMAATTIIOONN
       The _E_r_r_o_r_I_n_f_o mentioned above is the standard _E_r_r_o_r_I_n_f_o structure which
       is returned from all IO modules. It has the following format:

       {ErrorLine, Module, ErrorDescriptor}


       A string describing the error is obtained with the following call:

       Module:format_error(ErrorDescriptor)


SSEEEE AALLSSOO
       eepppp((33)), eerrll__iidd__ttrraannss((33)), eerrll__lliinntt((33)), bbeeaamm__lliibb((33))



Ericsson AB                     compiler 4.8.2                      compile(3)
