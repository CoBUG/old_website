re(3)                      Erlang Module Definition                      re(3)



NNAAMMEE
       re - Perl like regular expressions for Erlang

DDEESSCCRRIIPPTTIIOONN
       This module contains regular expression matching functions for strings
       and binaries.

       The regular expression syntax and semantics resemble that of Perl.

       The library's matching algorithms are currently based on the PCRE
       library, but not all of the PCRE library is interfaced and some parts
       of the library go beyond what PCRE offers. The sections of the PCRE
       documentation which are relevant to this module are included here.

   NNoottee::
       The Erlang literal syntax for strings uses the "\" (backslash)
       character as an escape code. You need to escape backslashes in literal
       strings, both in your code and in the shell, with an additional
       backslash, i.e.: "\\".


DDAATTAA TTYYPPEESS
       mmpp(()) = {re_pattern, term(), term(), term()}

              Opaque datatype containing a compiled regular expression. The
              mp() is guaranteed to be a tuple() having the atom 're_pattern'
              as its first element, to allow for matching in guards. The arity
              of the tuple() or the content of the other fields may change in
              future releases.

       nnll__ssppeecc(()) = cr | crlf | lf | anycrlf | any

       ccoommppiillee__ooppttiioonn(()) = unicode
                        | anchored
                        | caseless
                        | dollar_endonly
                        | dotall
                        | extended
                        | firstline
                        | multiline
                        | no_auto_capture
                        | dupnames
                        | ungreedy
                        | {newline, nnll__ssppeecc(())}
                        | bsr_anycrlf
                        | bsr_unicode

EEXXPPOORRTTSS
       ccoommppiillee((RReeggeexxpp)) -->> {{ookk,, MMPP}} || {{eerrrroorr,, EErrrrSSppeecc}}

              Types:

                 Regexp = iodata()

              The same as _c_o_m_p_i_l_e_(_R_e_g_e_x_p_,_[_]_)

       ccoommppiillee((RReeggeexxpp,,OOppttiioonnss)) -->> {{ookk,, MMPP}} || {{eerrrroorr,, EErrrrSSppeecc}}

              Types:

                 Regexp = iodata() | iioo::cchhaarrlliisstt(())
                 Options = [ Option ]
                 Option = ccoommppiillee__ooppttiioonn(())
                 NLSpec = nnll__ssppeecc(())
                 MP = mmpp(())
                 ErrSpec = {ErrString, Position}
                 ErrString = string()
                 Position = non_neg_integer()

              This function compiles a regular expression with the syntax
              described below into an internal format to be used later as a
              parameter to the run/2,3 functions.

              Compiling the regular expression before matching is useful if
              the same expression is to be used in matching against multiple
              subjects during the program's lifetime. Compiling once and
              executing many times is far more efficient than compiling each
              time one wants to match.

              When the unicode option is given, the regular expression should
              be given as a valid unicode _c_h_a_r_l_i_s_t_(_), otherwise as any valid
              _i_o_d_a_t_a_(_).

              The options have the following meanings:

                _u_n_i_c_o_d_e:
                  The regular expression is given as a unicode _c_h_a_r_l_i_s_t_(_) and
                  the resulting regular expression code is to be run against a
                  valid unicode _c_h_a_r_l_i_s_t_(_) subject.

                _a_n_c_h_o_r_e_d:
                  The pattern is forced to be "anchored", that is, it is
                  constrained to match only at the first matching point in the
                  string that is being searched (the "subject string"). This
                  effect can also be achieved by appropriate constructs in the
                  pattern itself.

                _c_a_s_e_l_e_s_s:
                  Letters in the pattern match both upper and lower case
                  letters. It is equivalent to Perl's /i option, and it can be
                  changed within a pattern by a (?i) option setting. Uppercase
                  and lowercase letters are defined as in the ISO-8859-1
                  character set.

                _d_o_l_l_a_r___e_n_d_o_n_l_y:
                  A dollar metacharacter in the pattern matches only at the
                  end of the subject string. Without this option, a dollar
                  also matches immediately before a newline at the end of the
                  string (but not before any other newlines). The
                  _d_o_l_l_a_r___e_n_d_o_n_l_y option is ignored if _m_u_l_t_i_l_i_n_e is given.
                  There is no equivalent option in Perl, and no way to set it
                  within a pattern.

                _d_o_t_a_l_l:
                  A dot in the pattern matches all characters, including those
                  that indicate newline. Without it, a dot does not match when
                  the current position is at a newline. This option is
                  equivalent to Perl's /s option, and it can be changed within
                  a pattern by a (?s) option setting. A negative class such as
                  [^a] always matches newline characters, independent of this
                  option's setting.

                _e_x_t_e_n_d_e_d:
                  Whitespace data characters in the pattern are ignored except
                  when escaped or inside a character class. Whitespace does
                  not include the VT character (ASCII 11). In addition,
                  characters between an unescaped # outside a character class
                  and the next newline, inclusive, are also ignored. This is
                  equivalent to Perl's /x option, and it can be changed within
                  a pattern by a (?x) option setting. This option makes it
                  possible to include comments inside complicated patterns.
                  Note, however, that this applies only to data characters.
                  Whitespace characters may never appear within special
                  character sequences in a pattern, for example within the
                  sequence _(_?_( which introduces a conditional subpattern.

                _f_i_r_s_t_l_i_n_e:
                  An unanchored pattern is required to match before or at the
                  first newline in the subject string, though the matched text
                  may continue over the newline.

                _m_u_l_t_i_l_i_n_e:
                  By default, PCRE treats the subject string as consisting of
                  a single line of characters (even if it actually contains
                  newlines). The "start of line" metacharacter (^) matches
                  only at the start of the string, while the "end of line"
                  metacharacter ($) matches only at the end of the string, or
                  before a terminating newline (unless _d_o_l_l_a_r___e_n_d_o_n_l_y is
                  given). This is the same as Perl.

                  When _m_u_l_t_i_l_i_n_e is given, the "start of line" and "end of
                  line" constructs match immediately following or immediately
                  before internal newlines in the subject string,
                  respectively, as well as at the very start and end. This is
                  equivalent to Perl's /m option, and it can be changed within
                  a pattern by a (?m) option setting. If there are no newlines
                  in a subject string, or no occurrences of ^ or $ in a
                  pattern, setting _m_u_l_t_i_l_i_n_e has no effect.

                _n_o___a_u_t_o___c_a_p_t_u_r_e:
                  Disables the use of numbered capturing parentheses in the
                  pattern. Any opening parenthesis that is not followed by ?
                  behaves as if it were followed by ?: but named parentheses
                  can still be used for capturing (and they acquire numbers in
                  the usual way). There is no equivalent of this option in
                  Perl.

                _d_u_p_n_a_m_e_s:
                  Names used to identify capturing subpatterns need not be
                  unique. This can be helpful for certain types of pattern
                  when it is known that only one instance of the named
                  subpattern can ever be matched. There are more details of
                  named subpatterns below

                _u_n_g_r_e_e_d_y:
                  This option inverts the "greediness" of the quantifiers so
                  that they are not greedy by default, but become greedy if
                  followed by "?". It is not compatible with Perl. It can also
                  be set by a (?U) option setting within the pattern.

                _{_n_e_w_l_i_n_e_, _N_L_S_p_e_c_}:
                  Override the default definition of a newline in the subject
                  string, which is LF (ASCII 10) in Erlang.

                  _c_r:
                    Newline is indicated by a single character CR (ASCII 13)

                  _l_f:
                    Newline is indicated by a single character LF (ASCII 10),
                    the default

                  _c_r_l_f:
                    Newline is indicated by the two-character CRLF (ASCII 13
                    followed by ASCII 10) sequence.

                  _a_n_y_c_r_l_f:
                    Any of the three preceding sequences should be recognized.

                  _a_n_y:
                    Any of the newline sequences above, plus the Unicode
                    sequences VT (vertical tab, U+000B), FF (formfeed,
                    U+000C), NEL (next line, U+0085), LS (line separator,
                    U+2028), and PS (paragraph separator, U+2029).

                _b_s_r___a_n_y_c_r_l_f:
                  Specifies specifically that \R is to match only the cr, lf
                  or crlf sequences, not the Unicode specific newline
                  characters.

                _b_s_r___u_n_i_c_o_d_e:
                  Specifies specifically that \R is to match all the Unicode
                  newline characters (including crlf etc, the default).

       rruunn((SSuubbjjeecctt,,RREE)) -->> {{mmaattcchh,, CCaappttuurreedd}} || nnoommaattcchh

              Types:

                 Subject = iodata() | iioo::cchhaarrlliisstt(())
                 RE = mmpp(()) | iodata()
                 Captured = [ CaptureData ]
                 CaptureData = {integer(),integer()}

              The same as _r_u_n_(_S_u_b_j_e_c_t_,_R_E_,_[_]_).

       rruunn((SSuubbjjeecctt,,RREE,,OOppttiioonnss)) -->> {{mmaattcchh,, CCaappttuurreedd}} || mmaattcchh || nnoommaattcchh

              Types:

                 Subject = iodata() | iioo::cchhaarrlliisstt(())
                 RE = mmpp(()) | iodata() | iioo::cchhaarrlliisstt(())
                 Options = [ Option ]
                 Option = anchored | global | notbol | noteol | notempty |
                 {offset, integer() >= 0} | {newline, NLSpec} | bsr_anycrlf |
                 bsr_unicode | {capture, ValueSpec} | {capture, ValueSpec,
                 Type} | CompileOpt
                 Type = index | list | binary
                 ValueSpec = all | all_but_first | first | none | ValueList
                 ValueList = [ ValueID ]
                 ValueID = integer() | string() | atom()
                 CompileOpt = ccoommppiillee__ooppttiioonn(())
                   See ccoommppiillee//22 above.
                 NLSpec = nnll__ssppeecc(())
                 Captured = [ CaptureData ] | [ [ CaptureData ] ... ]
                 CaptureData = {integer(),integer()} | ListConversionData |
                 binary()
                 ListConversionData = string() | {error, string(), binary()} |
                 {incomplete, string(), binary()}

              Executes a regexp matching, returning _m_a_t_c_h_/_{_m_a_t_c_h_, _C_a_p_t_u_r_e_d_} or
              _n_o_m_a_t_c_h. The regular expression can be given either as _i_o_d_a_t_a_(_)
              in which case it is automatically compiled (as by _r_e_:_c_o_m_p_i_l_e_/_2)
              and executed, or as a pre compiled _m_p_(_) in which case it is
              executed against the subject directly.

              When compilation is involved, the exception _b_a_d_a_r_g is thrown if
              a compilation error occurs. Call _r_e_:_c_o_m_p_i_l_e_/_2 to get information
              about the location of the error in the regular expression.

              If the regular expression is previously compiled, the option
              list can only contain the options _a_n_c_h_o_r_e_d, _g_l_o_b_a_l, _n_o_t_b_o_l,
              _n_o_t_e_o_l, _n_o_t_e_m_p_t_y, _{_o_f_f_s_e_t_, _i_n_t_e_g_e_r_(_) _>_= _0_}, _{_n_e_w_l_i_n_e_, _N_L_S_p_e_c_}
              and _{_c_a_p_t_u_r_e_, _V_a_l_u_e_S_p_e_c_}_/_{_c_a_p_t_u_r_e_, _V_a_l_u_e_S_p_e_c_, _T_y_p_e_}. Otherwise
              all options valid for the _r_e_:_c_o_m_p_i_l_e_/_2 function are allowed as
              well. Options allowed both for compilation and execution of a
              match, namely _a_n_c_h_o_r_e_d and _{_n_e_w_l_i_n_e_, _N_L_S_p_e_c_}, will affect both
              the compilation and execution if present together with a non
              pre-compiled regular expression.

              If the regular expression was previously compiled with the
              option _u_n_i_c_o_d_e, the _S_u_b_j_e_c_t should be provided as a valid
              Unicode _c_h_a_r_l_i_s_t_(_), otherwise any _i_o_d_a_t_a_(_) will do. If
              compilation is involved and the option _u_n_i_c_o_d_e is given, both
              the _S_u_b_j_e_c_t and the regular expression should be given as valid
              Unicode _c_h_a_r_l_i_s_t_s_(_).

              The _{_c_a_p_t_u_r_e_, _V_a_l_u_e_S_p_e_c_}_/_{_c_a_p_t_u_r_e_, _V_a_l_u_e_S_p_e_c_, _T_y_p_e_} defines what
              to return from the function upon successful matching. The
              _c_a_p_t_u_r_e tuple may contain both a value specification telling
              which of the captured substrings are to be returned, and a type
              specification, telling how captured substrings are to be
              returned (as index tuples, lists or binaries). The _c_a_p_t_u_r_e
              option makes the function quite flexible and powerful. The
              different options are described in detail below.

              If the capture options describe that no substring capturing at
              all is to be done (_{_c_a_p_t_u_r_e_, _n_o_n_e_}), the function will return
              the single atom _m_a_t_c_h upon successful matching, otherwise the
              tuple _{_m_a_t_c_h_, _V_a_l_u_e_L_i_s_t_} is returned. Disabling capturing can be
              done either by specifying _n_o_n_e or an empty list as _V_a_l_u_e_S_p_e_c.

              The options relevant for execution are:

                _a_n_c_h_o_r_e_d:
                  Limits _r_e_:_r_u_n_/_3 to matching at the first matching position.
                  If a pattern was compiled with _a_n_c_h_o_r_e_d, or turned out to be
                  anchored by virtue of its contents, it cannot be made
                  unanchored at matching time, hence there is no _u_n_a_n_c_h_o_r_e_d
                  option.

                _g_l_o_b_a_l:
                  Implements global (repetitive) search (the _g flag in Perl).
                  Each match is returned as a separate _l_i_s_t_(_) containing the
                  specific match as well as any matching subexpressions (or as
                  specified by the _c_a_p_t_u_r_e _o_p_t_i_o_n). The _C_a_p_t_u_r_e_d part of the
                  return value will hence be a _l_i_s_t_(_) of _l_i_s_t_(_)s when this
                  option is given.

                  The interaction of the global option with a regular
                  expression which matches an empty string surprises some
                  users. When the global option is given, _r_e_:_r_u_n_/_3 handles
                  empty matches in the same way as Perl: a zero-length match
                  at any point will be retried with the options _[_a_n_c_h_o_r_e_d_,
                  _n_o_t_e_m_p_t_y_] as well. If that search gives a result of length >
                  0, the result is included. For example:

                    re:run("cat","(|at)",[global]).

                  The following matching will be performed:

                  AAtt ooffffsseett _0:
                    The regexp _(_|_a_t_) will first match at the initial position
                    of the string _c_a_t, giving the result set _[_{_0_,_0_}_,_{_0_,_0_}_]
                    (the second _{_0_,_0_} is due to the subexpression marked by
                    the parentheses). As the length of the match is 0, we
                    don't advance to the next position yet.

                  AAtt ooffffsseett _0 with _[_a_n_c_h_o_r_e_d_, _n_o_t_e_m_p_t_y_]:
                     The search is retried with the options _[_a_n_c_h_o_r_e_d_,
                    _n_o_t_e_m_p_t_y_] at the same position, which does not give any
                    interesting result of longer length, so the search
                    position is now advanced to the next character (_a).

                  AAtt ooffffsseett _1:
                    This time, the search results in _[_{_1_,_0_}_,_{_1_,_0_}_], so this
                    search will also be repeated with the extra options.

                  AAtt ooffffsseett _1 with _[_a_n_c_h_o_r_e_d_, _n_o_t_e_m_p_t_y_]:
                    Now the _a_b alternative is found and the result will be
                    [{1,2},{1,2}]. The result is added to the list of results
                    and the position in the search string is advanced two
                    steps.

                  AAtt ooffffsseett _3:
                    The search now once again matches the empty string, giving
                    _[_{_3_,_0_}_,_{_3_,_0_}_].

                  AAtt ooffffsseett _1 with _[_a_n_c_h_o_r_e_d_, _n_o_t_e_m_p_t_y_]:
                    This will give no result of length > 0 and we are at the
                    last position, so the global search is complete.

                  The result of the call is:

                     {match,[[{0,0},{0,0}],[{1,0},{1,0}],[{1,2},{1,2}],[{3,0},{3,0}]]}

                _n_o_t_e_m_p_t_y:
                  An empty string is not considered to be a valid match if
                  this option is given. If there are alternatives in the
                  pattern, they are tried. If all the alternatives match the
                  empty string, the entire match fails. For example, if the
                  pattern

                    a?b?

                  is applied to a string not beginning with "a" or "b", it
                  would normally match the empty string at the start of the
                  subject. With the _n_o_t_e_m_p_t_y option, this match is not valid,
                  so re:run/3 searches further into the string for occurrences
                  of "a" or "b".

                  Perl has no direct equivalent of _n_o_t_e_m_p_t_y, but it does make
                  a special case of a pattern match of the empty string within
                  its split() function, and when using the /g modifier. It is
                  possible to emulate Perl's behavior after matching a null
                  string by first trying the match again at the same offset
                  with _n_o_t_e_m_p_t_y and _a_n_c_h_o_r_e_d, and then, if that fails, by
                  advancing the starting offset (see below) and trying an
                  ordinary match again.

                _n_o_t_b_o_l:
                  This option specifies that the first character of the
                  subject string is not the beginning of a line, so the
                  circumflex metacharacter should not match before it. Setting
                  this without _m_u_l_t_i_l_i_n_e (at compile time) causes circumflex
                  never to match. This option only affects the behavior of the
                  circumflex metacharacter. It does not affect \A.

                _n_o_t_e_o_l:
                  This option specifies that the end of the subject string is
                  not the end of a line, so the dollar metacharacter should
                  not match it nor (except in multiline mode) a newline
                  immediately before it. Setting this without _m_u_l_t_i_l_i_n_e (at
                  compile time) causes dollar never to match. This option
                  affects only the behavior of the dollar metacharacter. It
                  does not affect \Z or \z.

                _{_o_f_f_s_e_t_, _i_n_t_e_g_e_r_(_) _>_= _0_}:
                  Start matching at the offset (position) given in the subject
                  string. The offset is zero-based, so that the default is
                  _{_o_f_f_s_e_t_,_0_} (all of the subject string).

                _{_n_e_w_l_i_n_e_, _N_L_S_p_e_c_}:
                  Override the default definition of a newline in the subject
                  string, which is LF (ASCII 10) in Erlang.

                  _c_r:
                    Newline is indicated by a single character CR (ASCII 13)

                  _l_f:
                    Newline is indicated by a single character LF (ASCII 10),
                    the default

                  _c_r_l_f:
                    Newline is indicated by the two-character CRLF (ASCII 13
                    followed by ASCII 10) sequence.

                  _a_n_y_c_r_l_f:
                    Any of the three preceding sequences should be recognized.

                  _a_n_y:
                    Any of the newline sequences above, plus the Unicode
                    sequences VT (vertical tab, U+000B), FF (formfeed,
                    U+000C), NEL (next line, U+0085), LS (line separator,
                    U+2028), and PS (paragraph separator, U+2029).

                _b_s_r___a_n_y_c_r_l_f:
                  Specifies specifically that \R is to match only the cr, lf
                  or crlf sequences, not the Unicode specific newline
                  characters. (overrides compilation option)

                _b_s_r___u_n_i_c_o_d_e:
                  Specifies specifically that \R is to match all the Unicode
                  newline characters (including crlf etc, the
                  default).(overrides compilation option)

                _{_c_a_p_t_u_r_e_, _V_a_l_u_e_S_p_e_c_}/_{_c_a_p_t_u_r_e_, _V_a_l_u_e_S_p_e_c_, _T_y_p_e_}:
                  Specifies which captured substrings are returned and in what
                  format. By default, _r_e_:_r_u_n_/_3 captures all of the matching
                  part of the substring as well as all capturing subpatterns
                  (all of the pattern is automatically captured). The default
                  return type is (zero-based) indexes of the captured parts of
                  the string, given as _{_O_f_f_s_e_t_,_L_e_n_g_t_h_} pairs (the _i_n_d_e_x _T_y_p_e
                  of capturing).

                  As an example of the default behavior, the following call:

                    re:run("ABCabcdABC","abcd",[]).

                  returns, as first and only captured string the matching part
                  of the subject ("abcd" in the middle) as a index pair _{_3_,_4_},
                  where character positions are zero based, just as in
                  offsets. The return value of the call above would then be:

                    {match,[{3,4}]}

                  Another (and quite common) case is where the regular
                  expression matches all of the subject, as in:

                    re:run("ABCabcdABC",".*abcd.*",[]).

                  where the return value correspondingly will point out all of
                  the string, beginning at index 0 and being 10 characters
                  long:

                    {match,[{0,10}]}

                  If the regular expression contains capturing subpatterns,
                  like in the following case:

                    re:run("ABCabcdABC",".*(abcd).*",[]).

                  all of the matched subject is captured, as well as the
                  captured substrings:

                    {match,[{0,10},{3,4}]}

                  the complete matching pattern always giving the first return
                  value in the list and the rest of the subpatterns being
                  added in the order they occurred in the regular expression.

                  The capture tuple is built up as follows:

                  _V_a_l_u_e_S_p_e_c:
                    Specifies which captured (sub)patterns are to be returned.
                    The ValueSpec can either be an atom describing a
                    predefined set of return values, or a list containing
                    either the indexes or the names of specific subpatterns to
                    return.

                    The predefined sets of subpatterns are:

                    _a_l_l:
                      All captured subpatterns including the complete matching
                      string. This is the default.

                    _f_i_r_s_t:
                      Only the first captured subpattern, which is always the
                      complete matching part of the subject. All explicitly
                      captured subpatterns are discarded.

                    _a_l_l___b_u_t___f_i_r_s_t:
                      All but the first matching subpattern, i.e. all
                      explicitly captured subpatterns, but not the complete
                      matching part of the subject string. This is useful if
                      the regular expression as a whole matches a large part
                      of the subject, but the part you're interested in is in
                      an explicitly captured subpattern. If the return type is
                      _l_i_s_t or _b_i_n_a_r_y, not returning subpatterns you're not
                      interested in is a good way to optimize.

                    _n_o_n_e:
                      Do not return matching subpatterns at all, yielding the
                      single atom _m_a_t_c_h as the return value of the function
                      when matching successfully instead of the _{_m_a_t_c_h_,
                      _l_i_s_t_(_)_} return. Specifying an empty list gives the same
                      behavior.

                    The value list is a list of indexes for the subpatterns to
                    return, where index 0 is for all of the pattern, and 1 is
                    for the first explicit capturing subpattern in the regular
                    expression, and so forth. When using named captured
                    subpatterns (see below) in the regular expression, one can
                    use _a_t_o_m_(_)s or _s_t_r_i_n_g_(_)s to specify the subpatterns to be
                    returned. For example, consider the regular expression:

                      ".*(abcd).*"

                    matched against the string ""ABCabcdABC", capturing only
                    the "abcd" part (the first explicit subpattern):

                      re:run("ABCabcdABC",".*(abcd).*",[{capture,[1]}]).

                    The call will yield the following result:

                      {match,[{3,4}]}

                    as the first explicitly captured subpattern is "(abcd)",
                    matching "abcd" in the subject, at (zero-based) position
                    3, of length 4.

                    Now consider the same regular expression, but with the
                    subpattern explicitly named 'FOO':

                      ".*(?<FOO>abcd).*"

                    With this expression, we could still give the index of the
                    subpattern with the following call:

                      re:run("ABCabcdABC",".*(?<FOO>abcd).*",[{capture,[1]}]).

                    giving the same result as before. But, since the
                    subpattern is named, we can also specify its name in the
                    value list:

                      re:run("ABCabcdABC",".*(?<FOO>abcd).*",[{capture,['FOO']}]).

                    which would yield the same result as the earlier examples,
                    namely:

                      {match,[{3,4}]}

                    The values list might specify indexes or names not present
                    in the regular expression, in which case the return values
                    vary depending on the type. If the type is _i_n_d_e_x, the
                    tuple _{_-_1_,_0_} is returned for values having no
                    corresponding subpattern in the regexp, but for the other
                    types (_b_i_n_a_r_y and _l_i_s_t), the values are the empty binary
                    or list respectively.

                  _T_y_p_e:
                    Optionally specifies how captured substrings are to be
                    returned. If omitted, the default of _i_n_d_e_x is used. The
                    _T_y_p_e can be one of the following:

                    _i_n_d_e_x:
                      Return captured substrings as pairs of byte indexes into
                      the subject string and length of the matching string in
                      the subject (as if the subject string was flattened with
                      _i_o_l_i_s_t___t_o___b_i_n_a_r_y_/_1 or _u_n_i_c_o_d_e_:_c_h_a_r_a_c_t_e_r_s___t_o___b_i_n_a_r_y_/_2
                      prior to matching). Note that the _u_n_i_c_o_d_e option results
                      in _b_y_t_e_-_o_r_i_e_n_t_e_d indexes in a (possibly virtual) _U_T_F_-_8
                      _e_n_c_o_d_e_d binary. A byte index tuple _{_0_,_2_} might therefore
                      represent one or two characters when _u_n_i_c_o_d_e is in
                      effect. This might seem counter-intuitive, but has been
                      deemed the most effective and useful way to way to do
                      it. To return lists instead might result in simpler code
                      if that is desired. This return type is the default.

                    _l_i_s_t:
                      Return matching substrings as lists of characters
                      (Erlang _s_t_r_i_n_g_(_)s). It the _u_n_i_c_o_d_e option is used in
                      combination with the \C sequence in the regular
                      expression, a captured subpattern can contain bytes that
                      are not valid UTF-8 (\C matches bytes regardless of
                      character encoding). In that case the _l_i_s_t capturing may
                      result in the same types of tuples that
                      _u_n_i_c_o_d_e_:_c_h_a_r_a_c_t_e_r_s___t_o___l_i_s_t_/_2 can return, namely three-
                      tuples with the tag _i_n_c_o_m_p_l_e_t_e or _e_r_r_o_r, the
                      successfully converted characters and the invalid UTF-8
                      tail of the conversion as a binary. The best strategy is
                      to avoid using the \C sequence when capturing lists.

                    _b_i_n_a_r_y:
                      Return matching substrings as binaries. If the _u_n_i_c_o_d_e
                      option is used, these binaries are in UTF-8. If the \C
                      sequence is used together with _u_n_i_c_o_d_e the binaries may
                      be invalid UTF-8.

                  In general, subpatterns that were not assigned a value in
                  the match are returned as the tuple _{_-_1_,_0_} when _t_y_p_e is
                  _i_n_d_e_x. Unassigned subpatterns are returned as the empty
                  binary or list, respectively, for other return types.
                  Consider the regular expression:

                    ".*((?<FOO>abdd)|a(..d)).*"

                  There are three explicitly capturing subpatterns, where the
                  opening parenthesis position determines the order in the
                  result, hence _(_(_?_<_F_O_O_>_a_b_d_d_)_|_a_(_._._d_)_) is subpattern index 1,
                  _(_?_<_F_O_O_>_a_b_d_d_) is subpattern index 2 and _(_._._d_) is subpattern
                  index 3. When matched against the following string:

                    "ABCabcdABC"

                  the subpattern at index 2 won't match, as "abdd" is not
                  present in the string, but the complete pattern matches (due
                  to the alternative _a_(_._._d_). The subpattern at index 2 is
                  therefore unassigned and the default return value will be:

                    {match,[{0,10},{3,4},{-1,0},{4,3}]}

                  Setting the capture _T_y_p_e to _b_i_n_a_r_y would give the following:

                    {match,[<<"ABCabcdABC">>,<<"abcd">>,<<>>,<<"bcd">>]}

                  where the empty binary (_<_<_>_>) represents the unassigned
                  subpattern. In the _b_i_n_a_r_y case, some information about the
                  matching is therefore lost, the _<_<_>_> might just as well be
                  an empty string captured.

                  If differentiation between empty matches and non existing
                  subpatterns is necessary, use the _t_y_p_e _i_n_d_e_x and do the
                  conversion to the final type in Erlang code.

                  When the option _g_l_o_b_a_l is given, the _c_a_p_t_u_r_e specification
                  affects each match separately, so that:

                    re:run("cacb","c(a|b)",[global,{capture,[1],list}]).

                  gives the result:

                    {match,[["a"],["b"]]}

              The options solely affecting the compilation step are described
              in the _r_e_:_c_o_m_p_i_l_e_/_2 function.

       rreeppllaaccee((SSuubbjjeecctt,, RREE,, RReeppllaacceemmeenntt)) -->> iiooddaattaa(()) || uunniiccooddee::cchhaarrlliisstt(())

              Types:

                 Subject = iodata() | uunniiccooddee::cchhaarrlliisstt(())
                 RE = mmpp(()) | iodata()
                 Replacement = iodata() | uunniiccooddee::cchhaarrlliisstt(())

              The same as _r_e_p_l_a_c_e_(_S_u_b_j_e_c_t_,_R_E_,_R_e_p_l_a_c_e_m_e_n_t_,_[_]_).

       rreeppllaaccee((SSuubbjjeecctt,, RREE,, RReeppllaacceemmeenntt,, OOppttiioonnss)) -->>
                  iiooddaattaa(()) || uunniiccooddee::cchhaarrlliisstt(())

              Types:

                 Subject = iodata() | uunniiccooddee::cchhaarrlliisstt(())
                 RE = mmpp(()) | iodata() | uunniiccooddee::cchhaarrlliisstt(())
                 Replacement = iodata() | uunniiccooddee::cchhaarrlliisstt(())
                 Options = [Option]
                 Option = anchored
                        | global
                        | notbol
                        | noteol
                        | notempty
                        | {offset, integer() >= 0}
                        | {newline, NLSpec}
                        | bsr_anycrlf
                        | bsr_unicode
                        | {return, ReturnType}
                        | CompileOpt
                 ReturnType = iodata | list | binary
                 CompileOpt = ccoommppiillee__ooppttiioonn(())
                 NLSpec = cr | crlf | lf | anycrlf | any

              Replaces the matched part of the _S_u_b_j_e_c_t string with the
              contents of _R_e_p_l_a_c_e_m_e_n_t.

              The permissible options are the same as for _r_e_:_r_u_n_/_3, except
              that the _c_a_p_t_u_r_e option is not allowed. Instead a _{_r_e_t_u_r_n_,
              _R_e_t_u_r_n_T_y_p_e_} is present. The default return type is _i_o_d_a_t_a,
              constructed in a way to minimize copying. The _i_o_d_a_t_a result can
              be used directly in many i/o-operations. If a flat _l_i_s_t_(_) is
              desired, specify _{_r_e_t_u_r_n_, _l_i_s_t_} and if a binary is preferred,
              specify _{_r_e_t_u_r_n_, _b_i_n_a_r_y_}.

              As in the _r_e_:_r_u_n_/_3 function, an _m_p_(_) compiled with the _u_n_i_c_o_d_e
              option requires the _S_u_b_j_e_c_t to be a Unicode _c_h_a_r_l_i_s_t_(_). If
              compilation is done implicitly and the _u_n_i_c_o_d_e compilation
              option is given to this function, both the regular expression
              and the _S_u_b_j_e_c_t should be given as valid Unicode _c_h_a_r_l_i_s_t_(_)s.

              The replacement string can contain the special character _&,
              which inserts the whole matching expression in the result, and
              the special sequence _\N (where N is an integer > 0), resulting
              in the subexpression number N will be inserted in the result. If
              no subexpression with that number is generated by the regular
              expression, nothing is inserted.

              To insert an _& or _\ in the result, precede it with a _\. Note
              that Erlang already gives a special meaning to _\ in literal
              strings, so a single _\ has to be written as _"_\_\_" and therefore a
              double _\ as _"_\_\_\_\_". Example:

                  re:replace("abcd","c","[&]",[{return,list}]).

              gives

                  "ab[c]d"

              while

                  re:replace("abcd","c","[\\&]",[{return,list}]).

              gives

                  "ab[&]d"

              As with _r_e_:_r_u_n_/_3, compilation errors raise the _b_a_d_a_r_g exception,
              _r_e_:_c_o_m_p_i_l_e_/_2 can be used to get more information about the
              error.

       sspplliitt((SSuubbjjeecctt,, RREE)) -->> SSpplliittLLiisstt

              Types:

                 Subject = iodata() | uunniiccooddee::cchhaarrlliisstt(())
                 RE = mmpp(()) | iodata()
                 SplitList = [iodata() | uunniiccooddee::cchhaarrlliisstt(())]

              The same as _s_p_l_i_t_(_S_u_b_j_e_c_t_,_R_E_,_[_]_).

       sspplliitt((SSuubbjjeecctt,, RREE,, OOppttiioonnss)) -->> SSpplliittLLiisstt

              Types:

                 Subject = iodata() | uunniiccooddee::cchhaarrlliisstt(())
                 RE = mmpp(()) | iodata() | uunniiccooddee::cchhaarrlliisstt(())
                 Options = [Option]
                 Option = anchored
                        | notbol
                        | noteol
                        | notempty
                        | {offset, integer() >= 0}
                        | {newline, nnll__ssppeecc(())}
                        | bsr_anycrlf
                        | bsr_unicode
                        | {return, ReturnType}
                        | {parts, NumParts}
                        | group
                        | trim
                        | CompileOpt
                 NumParts = integer() >= 0 | infinity
                 ReturnType = iodata | list | binary
                 CompileOpt = ccoommppiillee__ooppttiioonn(())
                   See ccoommppiillee//22 above.
                 SplitList = [RetData] | [GroupedRetData]
                 GroupedRetData = [RetData]
                 RetData = iodata() | uunniiccooddee::cchhaarrlliisstt(()) | binary() | list()

              This function splits the input into parts by finding tokens
              according to the regular expression supplied.

              The splitting is done basically by running a global regexp match
              and dividing the initial string wherever a match occurs. The
              matching part of the string is removed from the output.

              As in the _r_e_:_r_u_n_/_3 function, an _m_p_(_) compiled with the _u_n_i_c_o_d_e
              option requires the _S_u_b_j_e_c_t to be a Unicode _c_h_a_r_l_i_s_t_(_). If
              compilation is done implicitly and the _u_n_i_c_o_d_e compilation
              option is given to this function, both the regular expression
              and the _S_u_b_j_e_c_t should be given as valid Unicode _c_h_a_r_l_i_s_t_(_)s.

              The result is given as a list of "strings", the preferred
              datatype given in the _r_e_t_u_r_n option (default iodata).

              If subexpressions are given in the regular expression, the
              matching subexpressions are returned in the resulting list as
              well. An example:

                  re:split("Erlang","[ln]",[{return,list}]).

              will yield the result:

                  ["Er","a","g"]

              while

                  re:split("Erlang","([ln])",[{return,list}]).

              will yield

                  ["Er","l","a","n","g"]

              The text matching the subexpression (marked by the parentheses
              in the regexp) is inserted in the result list where it was
              found. In effect this means that concatenating the result of a
              split where the whole regexp is a single subexpression (as in
              the example above) will always result in the original string.

              As there is no matching subexpression for the last part in the
              example (the "g"), there is nothing inserted after that. To make
              the group of strings and the parts matching the subexpressions
              more obvious, one might use the _g_r_o_u_p option, which groups
              together the part of the subject string with the parts matching
              the subexpressions when the string was split:

                  re:split("Erlang","([ln])",[{return,list},group]).

              gives:

                  [["Er","l"],["a","n"],["g"]]

              Here the regular expression matched first the "l", causing "Er"
              to be the first part in the result. When the regular expression
              matched, the (only) subexpression was bound to the "l", so the
              "l" is inserted in the group together with "Er". The next match
              is of the "n", making "a" the next part to be returned. Since
              the subexpression is bound to the substring "n" in this case,
              the "n" is inserted into this group. The last group consists of
              the rest of the string, as no more matches are found.

              By default, all parts of the string, including the empty
              strings, are returned from the function. For example:

                  re:split("Erlang","[lg]",[{return,list}]).

              will return:

                  ["Er","an",[]]

              since the matching of the "g" in the end of the string leaves an
              empty rest which is also returned. This behaviour differs from
              the default behaviour of the split function in Perl, where empty
              strings at the end are by default removed. To get the "trimming"
              default behavior of Perl, specify _t_r_i_m as an option:

                  re:split("Erlang","[lg]",[{return,list},trim]).

              The result will be:

                  ["Er","an"]

              The "trim" option in effect says; "give me as many parts as
              possible except the empty ones", which might be useful in some
              circumstances. You can also specify how many parts you want, by
              specifying _{_p_a_r_t_s_,N_}:

                  re:split("Erlang","[lg]",[{return,list},{parts,2}]).

              This will give:

                  ["Er","ang"]

              Note that the last part is "ang", not "an", as we only specified
              splitting into two parts, and the splitting stops when enough
              parts are given, which is why the result differs from that of
              _t_r_i_m.

              More than three parts are not possible with this indata, so

                  re:split("Erlang","[lg]",[{return,list},{parts,4}]).

              will give the same result as the default, which is to be viewed
              as "an infinite number of parts".

              Specifying _0 as the number of parts gives the same effect as the
              option _t_r_i_m. If subexpressions are captured, empty subexpression
              matches at the end are also stripped from the result if _t_r_i_m or
              _{_p_a_r_t_s_,_0_} is specified.

              If you are familiar with Perl, the _t_r_i_m behaviour corresponds
              exactly to the Perl default, the _{_p_a_r_t_s_,_N_} where N is a positive
              integer corresponds exactly to the Perl behaviour with a
              positive numerical third parameter and the default behaviour of
              _r_e_:_s_p_l_i_t_/_3 corresponds to that when the Perl routine is given a
              negative integer as the third parameter.

              Summary of options not previously described for the _r_e_:_r_u_n_/_3
              function:

                {{rreettuurrnn,,RReettuurrnnTTyyppee}}::
                  Specifies how the parts of the original string are presented
                  in the result list. The possible types are:

                  iiooddaattaa::
                    The variant of _i_o_d_a_t_a_(_) that gives the least copying of
                    data with the current implementation (often a binary, but
                    don't depend on it).

                  bbiinnaarryy::
                    All parts returned as binaries.

                  lliisstt::
                    All parts returned as lists of characters ("strings").

                ggrroouupp::
                  Groups together the part of the string with the parts of the
                  string matching the subexpressions of the regexp.

                  The return value from the function will in this case be a
                  _l_i_s_t_(_) of _l_i_s_t_(_)s. Each sublist begins with the string
                  picked out of the subject string, followed by the parts
                  matching each of the subexpressions in order of occurrence
                  in the regular expression.

                {{ppaarrttss,,NN}}::
                  Specifies the number of parts the subject string is to be
                  split into.

                  The number of parts should be a positive integer for a
                  specific maximum on the number of parts and _i_n_f_i_n_i_t_y for the
                  maximum number of parts possible (the default). Specifying
                  _{_p_a_r_t_s_,_0_} gives as many parts as possible disregarding empty
                  parts at the end, the same as specifying _t_r_i_m

                ttrriimm::
                  Specifies that empty parts at the end of the result list are
                  to be disregarded. The same as specifying _{_p_a_r_t_s_,_0_}. This
                  corresponds to the default behaviour of the _s_p_l_i_t built in
                  function in Perl.

PPEERRLL LLIIKKEE RREEGGUULLAARR EEXXPPRREESSSSIIOONNSS SSYYNNTTAAXX
       The following sections contain reference material for the regular
       expressions used by this module. The regular expression reference is
       based on the PCRE documentation, with changes in cases where the re
       module behaves differently to the PCRE library.

PPCCRREE RREEGGUULLAARR EEXXPPRREESSSSIIOONN DDEETTAAIILLSS
       The syntax and semantics of the regular expressions that are supported
       by PCRE are described in detail below. Perl's regular expressions are
       described in its own documentation, and regular expressions in general
       are covered in a number of books, some of which have copious examples.
       Jeffrey Friedl's "Mastering Regular Expressions", published by
       O'Reilly, covers regular expressions in great detail. This description
       of PCRE's regular expressions is intended as reference material.

       The reference material is divided into the following sections:

         * NNeewwlliinnee ccoonnvveennttiioonnss

         * CChhaarraacctteerrss aanndd mmeettaacchhaarraacctteerrss

         * BBaacckkssllaasshh

         * CCiirrccuummfflleexx aanndd ddoollllaarr

         * FFuullll ssttoopp ((ppeerriioodd,, ddoott))

         * MMaattcchhiinngg aa ssiinnggllee bbyyttee

         * SSqquuaarree bbrraacckkeettss aanndd cchhaarraacctteerr ccllaasssseess

         * PPOOSSIIXX cchhaarraacctteerr ccllaasssseess

         * VVeerrttiiccaall bbaarr

         * IInntteerrnnaall ooppttiioonn sseettttiinngg

         * SSuubbppaatttteerrnnss

         * DDuupplliiccaattee ssuubbppaatttteerrnn nnuummbbeerrss

         * NNaammeedd ssuubbppaatttteerrnnss

         * RReeppeettiittiioonn

         * AAttoommiicc ggrroouuppiinngg aanndd ppoosssseessssiivvee qquuaannttiiffiieerrss

         * BBaacckk rreeffeerreenncceess

         * AAsssseerrttiioonnss

         * CCoonnddiittiioonnaall ssuubbppaatttteerrnnss

         * CCoommmmeennttss

         * RReeccuurrssiivvee ppaatttteerrnnss

         * SSuubbppaatttteerrnnss aass ssuubbrroouuttiinneess

         * BBaacckkttrraacckkiinngg ccoonnttrrooll

NNEEWWLLIINNEE CCOONNVVEENNTTIIOONNSS
       PCRE supports five different conventions for indicating line breaks in
       strings: a single CR (carriage return) character, a single LF
       (linefeed) character, the two-character sequence CRLF , any of the
       three preceding, or any Unicode newline sequence.

       It is also possible to specify a newline convention by starting a
       pattern string with one of the following five sequences:

         ((**CCRR))::
           carriage return

         ((**LLFF))::
           linefeed

         ((**CCRRLLFF))::
           carriage return, followed by linefeed

         ((**AANNYYCCRRLLFF))::
           any of the three above

         ((**AANNYY))::
           all Unicode newline sequences

       These override the default and the options given to _r_e_:_c_o_m_p_i_l_e_/_2. For
       example, the pattern:

       (*CR)a.b

       changes the convention to CR. That pattern matches "a\nb" because LF is
       no longer a newline. Note that these special settings, which are not
       Perl-compatible, are recognized only at the very start of a pattern,
       and that they must be in upper case. If more than one of them is
       present, the last one is used.

       The newline convention does not affect what the \R escape sequence
       matches. By default, this is any Unicode newline sequence, for Perl
       compatibility. However, this can be changed; see the description of \R
       in the section entitled "Newline sequences" below. A change of \R
       setting can be combined with a change of newline convention.

CCHHAARRAACCTTEERRSS AANNDD MMEETTAACCHHAARRAACCTTEERRSS
       A regular expression is a pattern that is matched against a subject
       string from left to right. Most characters stand for themselves in a
       pattern, and match the corresponding characters in the subject. As a
       trivial example, the pattern

       The quick brown fox

       matches a portion of a subject string that is identical to itself. When
       caseless matching is specified (the _c_a_s_e_l_e_s_s option), letters are
       matched independently of case.

       The power of regular expressions comes from the ability to include
       alternatives and repetitions in the pattern. These are encoded in the
       pattern by the use of _m_e_t_a_c_h_a_r_a_c_t_e_r_s, which do not stand for themselves
       but instead are interpreted in some special way.

       There are two different sets of metacharacters: those that are
       recognized anywhere in the pattern except within square brackets, and
       those that are recognized within square brackets. Outside square
       brackets, the metacharacters are as follows:

         \\::
           general escape character with several uses

         ^^::
           assert start of string (or line, in multiline mode)

         $$::
           assert end of string (or line, in multiline mode)

         ..::
           match any character except newline (by default)

         [[::
           start character class definition

         ||::
           start of alternative branch

         ((::
           start subpattern

         ))::
           end subpattern

         ??::
           extends the meaning of (, also 0 or 1 quantifier, also quantifier
           minimizer

         **::
           0 or more quantifier

         ++::
           1 or more quantifier, also "possessive quantifier"

         {{::
           start min/max quantifier

       Part of a pattern that is in square brackets is called a "character
       class". In a character class the only metacharacters are:

         \\::
           general escape character

         ^^::
           negate the class, but only if the first character

         --::
           indicates character range

         [[::
           POSIX character class (only if followed by POSIX syntax)

         ]]::
           terminates the character class

       The following sections describe the use of each of the metacharacters.

BBAACCKKSSLLAASSHH
       The backslash character has several uses. Firstly, if it is followed by
       a non-alphanumeric character, it takes away any special meaning that
       character may have. This use of backslash as an escape character
       applies both inside and outside character classes.

       For example, if you want to match a * character, you write \* in the
       pattern. This escaping action applies whether or not the following
       character would otherwise be interpreted as a metacharacter, so it is
       always safe to precede a non-alphanumeric with backslash to specify
       that it stands for itself. In particular, if you want to match a
       backslash, you write \\.

       If a pattern is compiled with the _e_x_t_e_n_d_e_d option, whitespace in the
       pattern (other than in a character class) and characters between a #
       outside a character class and the next newline are ignored. An escaping
       backslash can be used to include a whitespace or # character as part of
       the pattern.

       If you want to remove the special meaning from a sequence of
       characters, you can do so by putting them between \Q and \E. This is
       different from Perl in that $ and @ are handled as literals in \Q...\E
       sequences in PCRE, whereas in Perl, $ and @ cause variable
       interpolation. Note the following examples:

         Pattern           PCRE matches   Perl matches

         \Qabc$xyz\E       abc$xyz        abc followed by the contents of $xyz
         \Qabc\$xyz\E      abc\$xyz       abc\$xyz
         \Qabc\E\$\Qxyz\E  abc$xyz        abc$xyz

       The \Q...\E sequence is recognized both inside and outside character
       classes.

       _N_o_n_-_p_r_i_n_t_i_n_g _c_h_a_r_a_c_t_e_r_s

       A second use of backslash provides a way of encoding non-printing
       characters in patterns in a visible manner. There is no restriction on
       the appearance of non-printing characters, apart from the binary zero
       that terminates a pattern, but when a pattern is being prepared by text
       editing, it is usually easier to use one of the following escape
       sequences than the binary character it represents:

         \\aa::
           alarm, that is, the BEL character (hex 07)

         \\ccxx::
           "control-x", where x is any character

         \\ee ::
           escape (hex 1B)

         \\ff::
           formfeed (hex 0C)

         \\nn::
           linefeed (hex 0A)

         \\rr::
           carriage return (hex 0D)

         \\tt ::
           tab (hex 09)

         \\dddddd::
           character with octal code ddd, or backreference

         \\xxhhhh ::
           character with hex code hh

         \\xx{{hhhhhh....}}::
           character with hex code hhh..

       The precise effect of \cx is as follows: if x is a lower case letter,
       it is converted to upper case. Then bit 6 of the character (hex 40) is
       inverted. Thus \cz becomes hex 1A, but \c{ becomes hex 3B, while \c;
       becomes hex 7B.

       After \x, from zero to two hexadecimal digits are read (letters can be
       in upper or lower case). Any number of hexadecimal digits may appear
       between \x{ and }, but the value of the character code must be less
       than 256 in non-UTF-8 mode, and less than 2**31 in UTF-8 mode. That is,
       the maximum value in hexadecimal is 7FFFFFFF. Note that this is bigger
       than the largest Unicode code point, which is 10FFFF.

       If characters other than hexadecimal digits appear between \x{ and },
       or if there is no terminating }, this form of escape is not recognized.
       Instead, the initial \x will be interpreted as a basic hexadecimal
       escape, with no following digits, giving a character whose value is
       zero.

       Characters whose value is less than 256 can be defined by either of the
       two syntaxes for \x. There is no difference in the way they are
       handled. For example, \xdc is exactly the same as \x{dc}.

       After \0 up to two further octal digits are read. If there are fewer
       than two digits, just those that are present are used. Thus the
       sequence \0\x\07 specifies two binary zeros followed by a BEL character
       (code value 7). Make sure you supply two digits after the initial zero
       if the pattern character that follows is itself an octal digit.

       The handling of a backslash followed by a digit other than 0 is
       complicated. Outside a character class, PCRE reads it and any following
       digits as a decimal number. If the number is less than 10, or if there
       have been at least that many previous capturing left parentheses in the
       expression, the entire sequence is taken as a _b_a_c_k _r_e_f_e_r_e_n_c_e. A
       description of how this works is given later, following the discussion
       of parenthesized subpatterns.

       Inside a character class, or if the decimal number is greater than 9
       and there have not been that many capturing subpatterns, PCRE re-reads
       up to three octal digits following the backslash, and uses them to
       generate a data character. Any subsequent digits stand for themselves.
       The value of a character specified in octal must be less than \400. In
       non-UTF-8 mode, the value of a character specified in octal must be
       less than \400. In UTF-8 mode, values up to \777 are permitted. For
       example:

         \\004400::
           is another way of writing a space

         \\4400::
           is the same, provided there are fewer than 40 previous capturing
           subpatterns

         \\77::
           is always a back reference

         \\1111::
            might be a back reference, or another way of writing a tab

         \\001111::
           is always a tab

         \\00111133::
           is a tab followed by the character "3"

         \\111133::
           might be a back reference, otherwise the character with octal code
           113

         \\337777::
           might be a back reference, otherwise the byte consisting entirely
           of 1 bits

         \\8811::
           is either a back reference, or a binary zero followed by the two
           characters "8" and "1"

       Note that octal values of 100 or greater must not be introduced by a
       leading zero, because no more than three octal digits are ever read.

       All the sequences that define a single character value can be used both
       inside and outside character classes. In addition, inside a character
       class, the sequence \b is interpreted as the backspace character (hex
       08), and the sequences \R and \X are interpreted as the characters "R"
       and "X", respectively. Outside a character class, these sequences have
       different meanings (see below).

       _A_b_s_o_l_u_t_e _a_n_d _r_e_l_a_t_i_v_e _b_a_c_k _r_e_f_e_r_e_n_c_e_s

       The sequence \g followed by an unsigned or a negative number,
       optionally enclosed in braces, is an absolute or relative back
       reference. A named back reference can be coded as \g{name}. Back
       references are discussed later, following the discussion of
       parenthesized subpatterns.

       _G_e_n_e_r_i_c _c_h_a_r_a_c_t_e_r _t_y_p_e_s

       Another use of backslash is for specifying generic character types. The
       following are always recognized:

         \\dd::
           any decimal digit

         \\DD::
           any character that is not a decimal digit

         \\hh::
           any horizontal whitespace character

         \\HH::
           any character that is not a horizontal whitespace character

         \\ss::
           any whitespace character

         \\SS::
           any character that is not a whitespace character

         \\vv::
           any vertical whitespace character

         \\VV::
           any character that is not a vertical whitespace character

         \\ww::
           any "word" character

         \\WW::
           any "non-word" character

       Each pair of escape sequences partitions the complete set of characters
       into two disjoint sets. Any given character matches one, and only one,
       of each pair.

       These character type sequences can appear both inside and outside
       character classes. They each match one character of the appropriate
       type. If the current matching point is at the end of the subject
       string, all of them fail, since there is no character to match.

       For compatibility with Perl, \s does not match the VT character (code
       11). This makes it different from the POSIX "space" class. The \s
       characters are HT (9), LF (10), FF (12), CR (13), and space (32). If
       "use locale;" is included in a Perl script, \s may match the VT
       character. In PCRE, it never does.

       In UTF-8 mode, characters with values greater than 128 never match \d,
       \s, or \w, and always match \D, \S, and \W. This is true even when
       Unicode character property support is available. These sequences retain
       their original meanings from before UTF-8 support was available, mainly
       for efficiency reasons.

       The sequences \h, \H, \v, and \V are Perl 5.10 features. In contrast to
       the other sequences, these do match certain high-valued codepoints in
       UTF-8 mode. The horizontal space characters are:

         UU++00000099::
           Horizontal tab

         UU++00002200::
           Space

         UU++0000AA00::
           Non-break space

         UU++11668800::
           Ogham space mark

         UU++118800EE::
           Mongolian vowel separator

         UU++22000000::
           En quad

         UU++22000011::
           Em quad

         UU++22000022::
           En space

         UU++22000033::
           Em space

         UU++22000044::
           Three-per-em space

         UU++22000055::
           Four-per-em space

         UU++22000066::
           Six-per-em space

         UU++22000077::
           Figure space

         UU++22000088::
           Punctuation space

         UU++22000099::
           Thin space

         UU++220000AA::
           Hair space

         UU++220022FF::
           Narrow no-break space

         UU++220055FF::
           Medium mathematical space

         UU++33000000::
           Ideographic space

       The vertical space characters are:

         UU++000000AA::
           Linefeed

         UU++000000BB::
           Vertical tab

         UU++000000CC::
           Formfeed

         UU++000000DD::
           Carriage return

         UU++00008855::
           Next line

         UU++22002288::
           Line separator

         UU++22002299::
           Paragraph separator

       A "word" character is an underscore or any character less than 256 that
       is a letter or digit. The definition of letters and digits is
       controlled by PCRE's low-valued character tables, which are always
       ISO-8859-1.

       _N_e_w_l_i_n_e _s_e_q_u_e_n_c_e_s

       Outside a character class, by default, the escape sequence \R matches
       any Unicode newline sequence. This is a Perl 5.10 feature. In non-UTF-8
       mode \R is equivalent to the following:

       (?>\r\n|\n|\x0b|\f|\r|\x85)

       This is an example of an "atomic group", details of which are given
       below.

       This particular group matches either the two-character sequence CR
       followed by LF, or one of the single characters LF (linefeed, U+000A),
       VT (vertical tab, U+000B), FF (formfeed, U+000C), CR (carriage return,
       U+000D), or NEL (next line, U+0085). The two-character sequence is
       treated as a single unit that cannot be split.

       In UTF-8 mode, two additional characters whose codepoints are greater
       than 255 are added: LS (line separator, U+2028) and PS (paragraph
       separator, U+2029). Unicode character property support is not needed
       for these characters to be recognized.

       It is possible to restrict \R to match only CR, LF, or CRLF (instead of
       the complete set of Unicode line endings) by setting the option
       _b_s_r___a_n_y_c_r_l_f either at compile time or when the pattern is matched. (BSR
       is an abbreviation for "backslash R".) This can be made the default
       when PCRE is built; if this is the case, the other behaviour can be
       requested via the _b_s_r___u_n_i_c_o_d_e option. It is also possible to specify
       these settings by starting a pattern string with one of the following
       sequences:

       (*BSR_ANYCRLF) CR, LF, or CRLF only (*BSR_UNICODE) any Unicode newline
       sequence

       These override the default and the options given to _r_e_:_c_o_m_p_i_l_e_/_2, but
       they can be overridden by options given to _r_e_:_r_u_n_/_3. Note that these
       special settings, which are not Perl-compatible, are recognized only at
       the very start of a pattern, and that they must be in upper case. If
       more than one of them is present, the last one is used. They can be
       combined with a change of newline convention, for example, a pattern
       can start with:

       (*ANY)(*BSR_ANYCRLF)

       Inside a character class, \R matches the letter "R".

       _U_n_i_c_o_d_e _c_h_a_r_a_c_t_e_r _p_r_o_p_e_r_t_i_e_s

       When PCRE is built with Unicode character property support, three
       additional escape sequences that match characters with specific
       properties are available. When not in UTF-8 mode, these sequences are
       of course limited to testing characters whose codepoints are less than
       256, but they do work in this mode. The extra escape sequences are:

       \p{_x_x} a character with the _x_x property \P{_x_x} a character without the
       _x_x property \X an extended Unicode sequence

       The property names represented by _x_x above are limited to the Unicode
       script names, the general category properties, and "Any", which matches
       any character (including newline). Other properties such as
       "InMusicalSymbols" are not currently supported by PCRE. Note that
       \P{Any} does not match any characters, so always causes a match
       failure.

       Sets of Unicode characters are defined as belonging to certain scripts.
       A character from one of these sets can be matched using a script name.
       For example:

       \p{Greek} \P{Han}

       Those that are not part of an identified script are lumped together as
       "Common". The current list of scripts is:

         * Arabic

         * Armenian

         * Balinese

         * Bengali

         * Bopomofo

         * Braille

         * Buginese

         * Buhid

         * Canadian_Aboriginal

         * Cherokee

         * Common

         * Coptic

         * Cuneiform

         * Cypriot

         * Cyrillic

         * Deseret

         * Devanagari

         * Ethiopic

         * Georgian

         * Glagolitic

         * Gothic

         * Greek

         * Gujarati

         * Gurmukhi

         * Han

         * Hangul

         * Hanunoo

         * Hebrew

         * Hiragana

         * Inherited

         * Kannada

         * Katakana

         * Kharoshthi

         * Khmer

         * Lao

         * Latin

         * Limbu

         * Linear_B

         * Malayalam

         * Mongolian

         * Myanmar

         * New_Tai_Lue

         * Nko

         * Ogham

         * Old_Italic

         * Old_Persian

         * Oriya

         * Osmanya

         * Phags_Pa

         * Phoenician

         * Runic

         * Shavian

         * Sinhala

         * Syloti_Nagri

         * Syriac

         * Tagalog

         * Tagbanwa

         * Tai_Le

         * Tamil

         * Telugu

         * Thaana

         * Thai

         * Tibetan

         * Tifinagh

         * Ugaritic

         * Yi

       Each character has exactly one general category property, specified by
       a two-letter abbreviation. For compatibility with Perl, negation can be
       specified by including a circumflex between the opening brace and the
       property name. For example, \p{^Lu} is the same as \P{Lu}.

       If only one letter is specified with \p or \P, it includes all the
       general category properties that start with that letter. In this case,
       in the absence of negation, the curly brackets in the escape sequence
       are optional; these two examples have the same effect:

         * \p{L}

         * \pL

       The following general category property codes are supported:

         CC::
           Other

         CCcc::
           Control

         CCff::
           Format

         CCnn::
           Unassigned

         CCoo::
           Private use

         CCss::
           Surrogate

         LL::
           Letter

         LLll::
           Lower case letter

         LLmm::
           Modifier letter

         LLoo::
           Other letter

         LLtt::
           Title case letter

         LLuu::
           Upper case letter

         MM::
           Mark

         MMcc::
           Spacing mark

         MMee::
           Enclosing mark

         MMnn::
           Non-spacing mark

         NN::
           Number

         NNdd::
           Decimal number

         NNll::
           Letter number

         NNoo::
           Other number

         PP::
           Punctuation

         PPcc::
           Connector punctuation

         PPdd::
           Dash punctuation

         PPee::
           Close punctuation

         PPff::
           Final punctuation

         PPii::
           Initial punctuation

         PPoo::
           Other punctuation

         PPss::
           Open punctuation

         SS::
           Symbol

         SScc::
           Currency symbol

         SSkk::
           Modifier symbol

         SSmm::
           Mathematical symbol

         SSoo::
           Other symbol

         ZZ::
           Separator

         ZZll::
           Line separator

         ZZpp::
           Paragraph separator

         ZZss::
           Space separator

       The special property L& is also supported: it matches a character that
       has the Lu, Ll, or Lt property, in other words, a letter that is not
       classified as a modifier or "other".

       The Cs (Surrogate) property applies only to characters in the range
       U+D800 to U+DFFF. Such characters are not valid in UTF-8 strings (see
       RFC 3629) and so cannot be tested by PCRE, unless UTF-8 validity
       checking has been turned off (see the discussion of _n_o___u_t_f_8___c_h_e_c_k in
       the _p_c_r_e_a_p_i page).

       The long synonyms for these properties that Perl supports (such as
       \p{Letter}) are not supported by PCRE, nor is it permitted to prefix
       any of these properties with "Is".

       No character that is in the Unicode table has the Cn (unassigned)
       property. Instead, this property is assumed for any code point that is
       not in the Unicode table.

       Specifying caseless matching does not affect these escape sequences.
       For example, \p{Lu} always matches only upper case letters.

       The \X escape matches any number of Unicode characters that form an
       extended Unicode sequence. \X is equivalent to

       (?>\PM\pM*)

       That is, it matches a character without the "mark" property, followed
       by zero or more characters with the "mark" property, and treats the
       sequence as an atomic group (see below). Characters with the "mark"
       property are typically accents that affect the preceding character.
       None of them have codepoints less than 256, so in non-UTF-8 mode \X
       matches any one character.

       Matching characters by Unicode property is not fast, because PCRE has
       to search a structure that contains data for over fifteen thousand
       characters. That is why the traditional escape sequences such as \d and
       \w do not use Unicode properties in PCRE.

       _R_e_s_e_t_t_i_n_g _t_h_e _m_a_t_c_h _s_t_a_r_t

       The escape sequence \K, which is a Perl 5.10 feature, causes any
       previously matched characters not to be included in the final matched
       sequence. For example, the pattern:

       foo\Kbar

       matches "foobar", but reports that it has matched "bar". This feature
       is similar to a lookbehind assertion (described below). However, in
       this case, the part of the subject before the real match does not have
       to be of fixed length, as lookbehind assertions do. The use of \K does
       not interfere with the setting of captured substrings. For example,
       when the pattern

       (foo)\Kbar

       matches "foobar", the first substring is still set to "foo".

       _S_i_m_p_l_e _a_s_s_e_r_t_i_o_n_s

       The final use of backslash is for certain simple assertions. An
       assertion specifies a condition that has to be met at a particular
       point in a match, without consuming any characters from the subject
       string. The use of subpatterns for more complicated assertions is
       described below. The backslashed assertions are:

         \\bb::
           matches at a word boundary

         \\BB::
           matches when not at a word boundary

         \\AA::
           matches at the start of the subject

         \\ZZ::
           matches at the end of the subject also matches before a newline at
           the end of the subject

         \\zz::
           matches only at the end of the subject

         \\GG::
           matches at the first matching position in the subject

       These assertions may not appear in character classes (but note that \b
       has a different meaning, namely the backspace character, inside a
       character class).

       A word boundary is a position in the subject string where the current
       character and the previous character do not both match \w or \W (i.e.
       one matches \w and the other matches \W), or the start or end of the
       string if the first or last character matches \w, respectively.

       The \A, \Z, and \z assertions differ from the traditional circumflex
       and dollar (described in the next section) in that they only ever match
       at the very start and end of the subject string, whatever options are
       set. Thus, they are independent of multiline mode. These three
       assertions are not affected by the _n_o_t_b_o_l or _n_o_t_e_o_l options, which
       affect only the behaviour of the circumflex and dollar metacharacters.
       However, if the _s_t_a_r_t_o_f_f_s_e_t argument of _r_e_:_r_u_n_/_3 is non-zero,
       indicating that matching is to start at a point other than the
       beginning of the subject, \A can never match. The difference between \Z
       and \z is that \Z matches before a newline at the end of the string as
       well as at the very end, whereas \z matches only at the end.

       The \G assertion is true only when the current matching position is at
       the start point of the match, as specified by the _s_t_a_r_t_o_f_f_s_e_t argument
       of _r_e_:_r_u_n_/_3. It differs from \A when the value of _s_t_a_r_t_o_f_f_s_e_t is non-
       zero. By calling _r_e_:_r_u_n_/_3 multiple times with appropriate arguments,
       you can mimic Perl's /g option, and it is in this kind of
       implementation where \G can be useful.

       Note, however, that PCRE's interpretation of \G, as the start of the
       current match, is subtly different from Perl's, which defines it as the
       end of the previous match. In Perl, these can be different when the
       previously matched string was empty. Because PCRE does just one match
       at a time, it cannot reproduce this behaviour.

       If all the alternatives of a pattern begin with \G, the expression is
       anchored to the starting match position, and the "anchored" flag is set
       in the compiled regular expression.

CCIIRRCCUUMMFFLLEEXX AANNDD DDOOLLLLAARR
       Outside a character class, in the default matching mode, the circumflex
       character is an assertion that is true only if the current matching
       point is at the start of the subject string. If the _s_t_a_r_t_o_f_f_s_e_t
       argument of _r_e_:_r_u_n_/_3 is non-zero, circumflex can never match if the
       _m_u_l_t_i_l_i_n_e option is unset. Inside a character class, circumflex has an
       entirely different meaning (see below).

       Circumflex need not be the first character of the pattern if a number
       of alternatives are involved, but it should be the first thing in each
       alternative in which it appears if the pattern is ever to match that
       branch. If all possible alternatives start with a circumflex, that is,
       if the pattern is constrained to match only at the start of the
       subject, it is said to be an "anchored" pattern. (There are also other
       constructs that can cause a pattern to be anchored.)

       A dollar character is an assertion that is true only if the current
       matching point is at the end of the subject string, or immediately
       before a newline at the end of the string (by default). Dollar need not
       be the last character of the pattern if a number of alternatives are
       involved, but it should be the last item in any branch in which it
       appears. Dollar has no special meaning in a character class.

       The meaning of dollar can be changed so that it matches only at the
       very end of the string, by setting the _d_o_l_l_a_r___e_n_d_o_n_l_y option at compile
       time. This does not affect the \Z assertion.

       The meanings of the circumflex and dollar characters are changed if the
       _m_u_l_t_i_l_i_n_e option is set. When this is the case, a circumflex matches
       immediately after internal newlines as well as at the start of the
       subject string. It does not match after a newline that ends the string.
       A dollar matches before any newlines in the string, as well as at the
       very end, when _m_u_l_t_i_l_i_n_e is set. When newline is specified as the two-
       character sequence CRLF, isolated CR and LF characters do not indicate
       newlines.

       For example, the pattern /^abc$/ matches the subject string "def\nabc"
       (where \n represents a newline) in multiline mode, but not otherwise.
       Consequently, patterns that are anchored in single line mode because
       all branches start with ^ are not anchored in multiline mode, and a
       match for circumflex is possible when the _s_t_a_r_t_o_f_f_s_e_t argument of
       _r_e_:_r_u_n_/_3 is non-zero. The _d_o_l_l_a_r___e_n_d_o_n_l_y option is ignored if _m_u_l_t_i_l_i_n_e
       is set.

       Note that the sequences \A, \Z, and \z can be used to match the start
       and end of the subject in both modes, and if all branches of a pattern
       start with \A it is always anchored, whether or not _m_u_l_t_i_l_i_n_e is set.

FFUULLLL SSTTOOPP ((PPEERRIIOODD,, DDOOTT))
       Outside a character class, a dot in the pattern matches any one
       character in the subject string except (by default) a character that
       signifies the end of a line. In UTF-8 mode, the matched character may
       be more than one byte long.

       When a line ending is defined as a single character, dot never matches
       that character; when the two-character sequence CRLF is used, dot does
       not match CR if it is immediately followed by LF, but otherwise it
       matches all characters (including isolated CRs and LFs). When any
       Unicode line endings are being recognized, dot does not match CR or LF
       or any of the other line ending characters.

       The behaviour of dot with regard to newlines can be changed. If the
       _d_o_t_a_l_l option is set, a dot matches any one character, without
       exception. If the two-character sequence CRLF is present in the subject
       string, it takes two dots to match it.

       The handling of dot is entirely independent of the handling of
       circumflex and dollar, the only relationship being that they both
       involve newlines. Dot has no special meaning in a character class.

MMAATTCCHHIINNGG AA SSIINNGGLLEE BBYYTTEE
       Outside a character class, the escape sequence \C matches any one byte,
       both in and out of UTF-8 mode. Unlike a dot, it always matches any
       line-ending characters. The feature is provided in Perl in order to
       match individual bytes in UTF-8 mode. Because it breaks up UTF-8
       characters into individual bytes, what remains in the string may be a
       malformed UTF-8 string. For this reason, the \C escape sequence is best
       avoided.

       PCRE does not allow \C to appear in lookbehind assertions (described
       below), because in UTF-8 mode this would make it impossible to
       calculate the length of the lookbehind.

SSQQUUAARREE BBRRAACCKKEETTSS AANNDD CCHHAARRAACCTTEERR CCLLAASSSSEESS
       An opening square bracket introduces a character class, terminated by a
       closing square bracket. A closing square bracket on its own is not
       special. If a closing square bracket is required as a member of the
       class, it should be the first data character in the class (after an
       initial circumflex, if present) or escaped with a backslash.

       A character class matches a single character in the subject. In UTF-8
       mode, the character may occupy more than one byte. A matched character
       must be in the set of characters defined by the class, unless the first
       character in the class definition is a circumflex, in which case the
       subject character must not be in the set defined by the class. If a
       circumflex is actually required as a member of the class, ensure it is
       not the first character, or escape it with a backslash.

       For example, the character class [aeiou] matches any lower case vowel,
       while [^aeiou] matches any character that is not a lower case vowel.
       Note that a circumflex is just a convenient notation for specifying the
       characters that are in the class by enumerating those that are not. A
       class that starts with a circumflex is not an assertion: it still
       consumes a character from the subject string, and therefore it fails if
       the current pointer is at the end of the string.

       In UTF-8 mode, characters with values greater than 255 can be included
       in a class as a literal string of bytes, or by using the \x{ escaping
       mechanism.

       When caseless matching is set, any letters in a class represent both
       their upper case and lower case versions, so for example, a caseless
       [aeiou] matches "A" as well as "a", and a caseless [^aeiou] does not
       match "A", whereas a caseful version would. In UTF-8 mode, PCRE always
       understands the concept of case for characters whose values are less
       than 128, so caseless matching is always possible. For characters with
       higher values, the concept of case is supported if PCRE is compiled
       with Unicode property support, but not otherwise. If you want to use
       caseless matching for characters 128 and above, you must ensure that
       PCRE is compiled with Unicode property support as well as with UTF-8
       support.

       Characters that might indicate line breaks are never treated in any
       special way when matching character classes, whatever line-ending
       sequence is in use, and whatever setting of the _d_o_t_a_l_l and _m_u_l_t_i_l_i_n_e
       options is used. A class such as [^a] always matches one of these
       characters.

       The minus (hyphen) character can be used to specify a range of
       characters in a character class. For example, [d-m] matches any letter
       between d and m, inclusive. If a minus character is required in a
       class, it must be escaped with a backslash or appear in a position
       where it cannot be interpreted as indicating a range, typically as the
       first or last character in the class.

       It is not possible to have the literal character "]" as the end
       character of a range. A pattern such as [W-]46] is interpreted as a
       class of two characters ("W" and "-") followed by a literal string
       "46]", so it would match "W46]" or "-46]". However, if the "]" is
       escaped with a backslash it is interpreted as the end of range, so
       [W-\]46] is interpreted as a class containing a range followed by two
       other characters. The octal or hexadecimal representation of "]" can
       also be used to end a range.

       Ranges operate in the collating sequence of character values. They can
       also be used for characters specified numerically, for example
       [\000-\037]. In UTF-8 mode, ranges can include characters whose values
       are greater than 255, for example [\x{100}-\x{2ff}].

       If a range that includes letters is used when caseless matching is set,
       it matches the letters in either case. For example, [W-c] is equivalent
       to [][\\^_`wxyzabc], matched caselessly , and in non-UTF-8 mode, if
       character tables for a French locale are in use, [\xc8-\xcb] matches
       accented E characters in both cases. In UTF-8 mode, PCRE supports the
       concept of case for characters with values greater than 128 only when
       it is compiled with Unicode property support.

       The character types \d, \D, \p, \P, \s, \S, \w, and \W may also appear
       in a character class, and add the characters that they match to the
       class. For example, [\dABCDEF] matches any hexadecimal digit. A
       circumflex can conveniently be used with the upper case character types
       to specify a more restricted set of characters than the matching lower
       case type. For example, the class [^\W_] matches any letter or digit,
       but not underscore.

       The only metacharacters that are recognized in character classes are
       backslash, hyphen (only where it can be interpreted as specifying a
       range), circumflex (only at the start), opening square bracket (only
       when it can be interpreted as introducing a POSIX class name - see the
       next section), and the terminating closing square bracket. However,
       escaping other non-alphanumeric characters does no harm.

PPOOSSIIXX CCHHAARRAACCTTEERR CCLLAASSSSEESS
       Perl supports the POSIX notation for character classes. This uses names
       enclosed by [: and :] within the enclosing square brackets. PCRE also
       supports this notation. For example,

       [01[:alpha:]%]

       matches "0", "1", any alphabetic character, or "%". The supported class
       names are

         aallnnuumm::
           letters and digits

         aallpphhaa::
           letters

         aasscciiii::
           character codes 0 - 127

         bbllaannkk::
           space or tab only

         ccnnttrrll::
           control characters

         ddiiggiitt::
           decimal digits (same as \d)

         ggrraapphh::
           printing characters, excluding space

         lloowweerr::
           lower case letters

         pprriinntt::
           printing characters, including space

         ppuunncctt::
           printing characters, excluding letters and digits

         ssppaaccee::
           whitespace (not quite the same as \s)

         uuppppeerr::
           upper case letters

         wwoorrdd::
           "word" characters (same as \w)

         xxddiiggiitt::
           hexadecimal digits

       The "space" characters are HT (9), LF (10), VT (11), FF (12), CR (13),
       and space (32). Notice that this list includes the VT character (code
       11). This makes "space" different to \s, which does not include VT (for
       Perl compatibility).

       The name "word" is a Perl extension, and "blank" is a GNU extension
       from Perl 5.8. Another Perl extension is negation, which is indicated
       by a ^ character after the colon. For example,

       [12[:^digit:]]

       matches "1", "2", or any non-digit. PCRE (and Perl) also recognize the
       POSIX syntax [.ch.] and [=ch=] where "ch" is a "collating element", but
       these are not supported, and an error is given if they are encountered.

       In UTF-8 mode, characters with values greater than 128 do not match any
       of the POSIX character classes.

VVEERRTTIICCAALL BBAARR
       Vertical bar characters are used to separate alternative patterns. For
       example, the pattern

       gilbert|sullivan

       matches either "gilbert" or "sullivan". Any number of alternatives may
       appear, and an empty alternative is permitted (matching the empty
       string). The matching process tries each alternative in turn, from left
       to right, and the first one that succeeds is used. If the alternatives
       are within a subpattern (defined below), "succeeds" means matching the
       rest of the main pattern as well as the alternative in the subpattern.

IINNTTEERRNNAALL OOPPTTIIOONN SSEETTTTIINNGG
       The settings of the _c_a_s_e_l_e_s_s, _m_u_l_t_i_l_i_n_e, _d_o_t_a_l_l, and _e_x_t_e_n_d_e_d options
       (which are Perl-compatible) can be changed from within the pattern by a
       sequence of Perl option letters enclosed between "(?" and ")". The
       option letters are

         ii::
           for _c_a_s_e_l_e_s_s

         mm::
           for _m_u_l_t_i_l_i_n_e

         ss::
           for _d_o_t_a_l_l

         xx::
           for _e_x_t_e_n_d_e_d

       For example, (?im) sets caseless, multiline matching. It is also
       possible to unset these options by preceding the letter with a hyphen,
       and a combined setting and unsetting such as (?im-sx), which sets
       _c_a_s_e_l_e_s_s and _m_u_l_t_i_l_i_n_e while unsetting _d_o_t_a_l_l and _e_x_t_e_n_d_e_d, is also
       permitted. If a letter appears both before and after the hyphen, the
       option is unset.

       The PCRE-specific options _d_u_p_n_a_m_e_s, _u_n_g_r_e_e_d_y, and _e_x_t_r_a can be changed
       in the same way as the Perl-compatible options by using the characters
       J, U and X respectively.

       When an option change occurs at top level (that is, not inside
       subpattern parentheses), the change applies to the remainder of the
       pattern that follows. If the change is placed right at the start of a
       pattern, PCRE extracts it into the global options

       An option change within a subpattern (see below for a description of
       subpatterns) affects only that part of the current pattern that follows
       it, so

       (a(?i)b)c

       matches abc and aBc and no other strings (assuming _c_a_s_e_l_e_s_s is not
       used). By this means, options can be made to have different settings in
       different parts of the pattern. Any changes made in one alternative do
       carry on into subsequent branches within the same subpattern. For
       example,

       (a(?i)b|c)

       matches "ab", "aB", "c", and "C", even though when matching "C" the
       first branch is abandoned before the option setting. This is because
       the effects of option settings happen at compile time. There would be
       some very weird behaviour otherwise.

       _N_o_t_e_: There are other PCRE-specific options that can be set by the
       application when the compile or match functions are called. In some
       cases the pattern can contain special leading sequences to override
       what the application has set or what has been defaulted. Details are
       given in the section entitled "Newline sequences" above.

SSUUBBPPAATTTTEERRNNSS
       Subpatterns are delimited by parentheses (round brackets), which can be
       nested. Turning part of a pattern into a subpattern does two things:

       1. It localizes a set of alternatives. For example, the pattern

       cat(aract|erpillar|)

       matches one of the words "cat", "cataract", or "caterpillar". Without
       the parentheses, it would match "cataract", "erpillar" or an empty
       string.

       2. It sets up the subpattern as a capturing subpattern. This means
       that, when the complete pattern matches, that portion of the subject
       string that matched the subpattern is passed back to the caller via the
       return value of _r_e_:_r_u_n_/_3. Opening parentheses are counted from left to
       right (starting from 1) to obtain numbers for the capturing
       subpatterns.

       For example, if the string "the red king" is matched against the
       pattern

       the ((red|white) (king|queen))

       the captured substrings are "red king", "red", and "king", and are
       numbered 1, 2, and 3, respectively.

       The fact that plain parentheses fulfil two functions is not always
       helpful. There are often times when a grouping subpattern is required
       without a capturing requirement. If an opening parenthesis is followed
       by a question mark and a colon, the subpattern does not do any
       capturing, and is not counted when computing the number of any
       subsequent capturing subpatterns. For example, if the string "the white
       queen" is matched against the pattern

       the ((?:red|white) (king|queen))

       the captured substrings are "white queen" and "queen", and are numbered
       1 and 2. The maximum number of capturing subpatterns is 65535.

       As a convenient shorthand, if any option settings are required at the
       start of a non-capturing subpattern, the option letters may appear
       between the "?" and the ":". Thus the two patterns

         * (?i:saturday|sunday)

         * (?:(?i)saturday|sunday)

       match exactly the same set of strings. Because alternative branches are
       tried from left to right, and options are not reset until the end of
       the subpattern is reached, an option setting in one branch does affect
       subsequent branches, so the above patterns match "SUNDAY" as well as
       "Saturday".

DDUUPPLLIICCAATTEE SSUUBBPPAATTTTEERRNN NNUUMMBBEERRSS
       Perl 5.10 introduced a feature whereby each alternative in a subpattern
       uses the same numbers for its capturing parentheses. Such a subpattern
       starts with (?| and is itself a non-capturing subpattern. For example,
       consider this pattern:

       (?|(Sat)ur|(Sun))day

       Because the two alternatives are inside a (?| group, both sets of
       capturing parentheses are numbered one. Thus, when the pattern matches,
       you can look at captured substring number one, whichever alternative
       matched. This construct is useful when you want to capture part, but
       not all, of one of a number of alternatives. Inside a (?| group,
       parentheses are numbered as usual, but the number is reset at the start
       of each branch. The numbers of any capturing buffers that follow the
       subpattern start after the highest number used in any branch. The
       following example is taken from the Perl documentation. The numbers
       underneath show in which buffer the captured content will be stored.

         # before  ---------------branch-reset----------- after
         / ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
         # 1            2         2  3        2     3     4

       A backreference or a recursive call to a numbered subpattern always
       refers to the first one in the pattern with the given number.

       An alternative approach to using this "branch reset" feature is to use
       duplicate named subpatterns, as described in the next section.

NNAAMMEEDD SSUUBBPPAATTTTEERRNNSS
       Identifying capturing parentheses by number is simple, but it can be
       very hard to keep track of the numbers in complicated regular
       expressions. Furthermore, if an expression is modified, the numbers may
       change. To help with this difficulty, PCRE supports the naming of
       subpatterns. This feature was not added to Perl until release 5.10.
       Python had the feature earlier, and PCRE introduced it at release 4.0,
       using the Python syntax. PCRE now supports both the Perl and the Python
       syntax.

       In PCRE, a subpattern can be named in one of three ways: (?<name>...)
       or (?'name'...) as in Perl, or (?P<name>...) as in Python. References
       to capturing parentheses from other parts of the pattern, such as
       backreferences, recursion, and conditions, can be made by name as well
       as by number.

       Names consist of up to 32 alphanumeric characters and underscores.
       Named capturing parentheses are still allocated numbers as well as
       names, exactly as if the names were not present. The _c_a_p_t_u_r_e
       specification to _r_e_:_r_u_n_/_3 can use named values if they are present in
       the regular expression.

       By default, a name must be unique within a pattern, but it is possible
       to relax this constraint by setting the _d_u_p_n_a_m_e_s option at compile
       time. This can be useful for patterns where only one instance of the
       named parentheses can match. Suppose you want to match the name of a
       weekday, either as a 3-letter abbreviation or as the full name, and in
       both cases you want to extract the abbreviation. This pattern (ignoring
       the line breaks) does the job:

         (?<DN>Mon|Fri|Sun)(?:day)?|
         (?<DN>Tue)(?:sday)?|
         (?<DN>Wed)(?:nesday)?|
         (?<DN>Thu)(?:rsday)?|
         (?<DN>Sat)(?:urday)?

       There are five capturing substrings, but only one is ever set after a
       match. (An alternative way of solving this problem is to use a "branch
       reset" subpattern, as described in the previous section.)

       In case of capturing named subpatterns which are not unique, the first
       occurrence is returned from _r_e_:_e_x_e_c_/_3, if the name is specified int the
       _v_a_l_u_e_s part of the _c_a_p_t_u_r_e statement.

RREEPPEETTIITTIIOONN
       Repetition is specified by quantifiers, which can follow any of the
       following items:

         * a literal data character

         * the dot metacharacter

         * the \C escape sequence

         * the \X escape sequence (in UTF-8 mode with Unicode properties)

         * the \R escape sequence

         * an escape such as \d that matches a single character

         * a character class

         * a back reference (see next section)

         * a parenthesized subpattern (unless it is an assertion)

       The general repetition quantifier specifies a minimum and maximum
       number of permitted matches, by giving the two numbers in curly
       brackets (braces), separated by a comma. The numbers must be less than
       65536, and the first must be less than or equal to the second. For
       example:

       z{2,4}

       matches "zz", "zzz", or "zzzz". A closing brace on its own is not a
       special character. If the second number is omitted, but the comma is
       present, there is no upper limit; if the second number and the comma
       are both omitted, the quantifier specifies an exact number of required
       matches. Thus

       [aeiou]{3,}

       matches at least 3 successive vowels, but may match many more, while

       \d{8}

       matches exactly 8 digits. An opening curly bracket that appears in a
       position where a quantifier is not allowed, or one that does not match
       the syntax of a quantifier, is taken as a literal character. For
       example, {,6} is not a quantifier, but a literal string of four
       characters.

       In UTF-8 mode, quantifiers apply to UTF-8 characters rather than to
       individual bytes. Thus, for example, \x{100}{2} matches two UTF-8
       characters, each of which is represented by a two-byte sequence.
       Similarly, when Unicode property support is available, \X{3} matches
       three Unicode extended sequences, each of which may be several bytes
       long (and they may be of different lengths).

       The quantifier {0} is permitted, causing the expression to behave as if
       the previous item and the quantifier were not present.

       For convenience, the three most common quantifiers have single-
       character abbreviations:

         **::
           is equivalent to {0,}

         ++::
           is equivalent to {1,}

         ??::
           is equivalent to {0,1}

       It is possible to construct infinite loops by following a subpattern
       that can match no characters with a quantifier that has no upper limit,
       for example:

       (a?)*

       Earlier versions of Perl and PCRE used to give an error at compile time
       for such patterns. However, because there are cases where this can be
       useful, such patterns are now accepted, but if any repetition of the
       subpattern does in fact match no characters, the loop is forcibly
       broken.

       By default, the quantifiers are "greedy", that is, they match as much
       as possible (up to the maximum number of permitted times), without
       causing the rest of the pattern to fail. The classic example of where
       this gives problems is in trying to match comments in C programs. These
       appear between /* and */ and within the comment, individual * and /
       characters may appear. An attempt to match C comments by applying the
       pattern

       /\*.*\*/

       to the string

       /* first comment */ not comment /* second comment */

       fails, because it matches the entire string owing to the greediness of
       the .* item.

       However, if a quantifier is followed by a question mark, it ceases to
       be greedy, and instead matches the minimum number of times possible, so
       the pattern

       /\*.*?\*/

       does the right thing with the C comments. The meaning of the various
       quantifiers is not otherwise changed, just the preferred number of
       matches. Do not confuse this use of question mark with its use as a
       quantifier in its own right. Because it has two uses, it can sometimes
       appear doubled, as in

       \d??\d

       which matches one digit by preference, but can match two if that is the
       only way the rest of the pattern matches.

       If the _u_n_g_r_e_e_d_y option is set (an option that is not available in
       Perl), the quantifiers are not greedy by default, but individual ones
       can be made greedy by following them with a question mark. In other
       words, it inverts the default behaviour.

       When a parenthesized subpattern is quantified with a minimum repeat
       count that is greater than 1 or with a limited maximum, more memory is
       required for the compiled pattern, in proportion to the size of the
       minimum or maximum.

       If a pattern starts with .* or .{0,} and the _d_o_t_a_l_l option (equivalent
       to Perl's /s) is set, thus allowing the dot to match newlines, the
       pattern is implicitly anchored, because whatever follows will be tried
       against every character position in the subject string, so there is no
       point in retrying the overall match at any position after the first.
       PCRE normally treats such a pattern as though it were preceded by \A.

       In cases where it is known that the subject string contains no
       newlines, it is worth setting _d_o_t_a_l_l in order to obtain this
       optimization, or alternatively using ^ to indicate anchoring
       explicitly.

       However, there is one situation where the optimization cannot be used.
       When .* is inside capturing parentheses that are the subject of a
       backreference elsewhere in the pattern, a match at the start may fail
       where a later one succeeds. Consider, for example:

       (.*)abc\1

       If the subject is "xyz123abc123" the match point is the fourth
       character. For this reason, such a pattern is not implicitly anchored.

       When a capturing subpattern is repeated, the value captured is the
       substring that matched the final iteration. For example, after

       (tweedle[dume]{3}\s*)+

       has matched "tweedledum tweedledee" the value of the captured substring
       is "tweedledee". However, if there are nested capturing subpatterns,
       the corresponding captured values may have been set in previous
       iterations. For example, after

       /(a|(b))+/

       matches "aba" the value of the second captured substring is "b".

AATTOOMMIICC GGRROOUUPPIINNGG AANNDD PPOOSSSSEESSSSIIVVEE QQUUAANNTTIIFFIIEERRSS
       With both maximizing ("greedy") and minimizing ("ungreedy" or "lazy")
       repetition, failure of what follows normally causes the repeated item
       to be re-evaluated to see if a different number of repeats allows the
       rest of the pattern to match. Sometimes it is useful to prevent this,
       either to change the nature of the match, or to cause it fail earlier
       than it otherwise might, when the author of the pattern knows there is
       no point in carrying on.

       Consider, for example, the pattern \d+foo when applied to the subject
       line

       123456bar

       After matching all 6 digits and then failing to match "foo", the normal
       action of the matcher is to try again with only 5 digits matching the
       \d+ item, and then with 4, and so on, before ultimately failing.
       "Atomic grouping" (a term taken from Jeffrey Friedl's book) provides
       the means for specifying that once a subpattern has matched, it is not
       to be re-evaluated in this way.

       If we use atomic grouping for the previous example, the matcher gives
       up immediately on failing to match "foo" the first time. The notation
       is a kind of special parenthesis, starting with (?> as in this example:

       (?>\d+)foo

       This kind of parenthesis "locks up" the part of the pattern it contains
       once it has matched, and a failure further into the pattern is
       prevented from backtracking into it. Backtracking past it to previous
       items, however, works as normal.

       An alternative description is that a subpattern of this type matches
       the string of characters that an identical standalone pattern would
       match, if anchored at the current point in the subject string.

       Atomic grouping subpatterns are not capturing subpatterns. Simple cases
       such as the above example can be thought of as a maximizing repeat that
       must swallow everything it can. So, while both \d+ and \d+? are
       prepared to adjust the number of digits they match in order to make the
       rest of the pattern match, (?>\d+) can only match an entire sequence of
       digits.

       Atomic groups in general can of course contain arbitrarily complicated
       subpatterns, and can be nested. However, when the subpattern for an
       atomic group is just a single repeated item, as in the example above, a
       simpler notation, called a "possessive quantifier" can be used. This
       consists of an additional + character following a quantifier. Using
       this notation, the previous example can be rewritten as

       \d++foo

       Note that a possessive quantifier can be used with an entire group, for
       example:

       (abc|xyz){2,3}+

       Possessive quantifiers are always greedy; the setting of the _u_n_g_r_e_e_d_y
       option is ignored. They are a convenient notation for the simpler forms
       of atomic group. However, there is no difference in the meaning of a
       possessive quantifier and the equivalent atomic group, though there may
       be a performance difference; possessive quantifiers should be slightly
       faster.

       The possessive quantifier syntax is an extension to the Perl 5.8
       syntax. Jeffrey Friedl originated the idea (and the name) in the first
       edition of his book. Mike McCloskey liked it, so implemented it when he
       built Sun's Java package, and PCRE copied it from there. It ultimately
       found its way into Perl at release 5.10.

       PCRE has an optimization that automatically "possessifies" certain
       simple pattern constructs. For example, the sequence A+B is treated as
       A++B because there is no point in backtracking into a sequence of A's
       when B must follow.

       When a pattern contains an unlimited repeat inside a subpattern that
       can itself be repeated an unlimited number of times, the use of an
       atomic group is the only way to avoid some failing matches taking a
       very long time indeed. The pattern

       (\D+|<\d+>)*[!?]

       matches an unlimited number of substrings that either consist of non-
       digits, or digits enclosed in <>, followed by either ! or ?. When it
       matches, it runs quickly. However, if it is applied to

       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

       it takes a long time before reporting failure. This is because the
       string can be divided between the internal \D+ repeat and the external
       * repeat in a large number of ways, and all have to be tried. (The
       example uses [!?] rather than a single character at the end, because
       both PCRE and Perl have an optimization that allows for fast failure
       when a single character is used. They remember the last single
       character that is required for a match, and fail early if it is not
       present in the string.) If the pattern is changed so that it uses an
       atomic group, like this:

       ((?>\D+)|<\d+>)*[!?]

       sequences of non-digits cannot be broken, and failure happens quickly.

BBAACCKK RREEFFEERREENNCCEESS
       Outside a character class, a backslash followed by a digit greater than
       0 (and possibly further digits) is a back reference to a capturing
       subpattern earlier (that is, to its left) in the pattern, provided
       there have been that many previous capturing left parentheses.

       However, if the decimal number following the backslash is less than 10,
       it is always taken as a back reference, and causes an error only if
       there are not that many capturing left parentheses in the entire
       pattern. In other words, the parentheses that are referenced need not
       be to the left of the reference for numbers less than 10. A "forward
       back reference" of this type can make sense when a repetition is
       involved and the subpattern to the right has participated in an earlier
       iteration.

       It is not possible to have a numerical "forward back reference" to a
       subpattern whose number is 10 or more using this syntax because a
       sequence such as \50 is interpreted as a character defined in octal.
       See the subsection entitled "Non-printing characters" above for further
       details of the handling of digits following a backslash. There is no
       such problem when named parentheses are used. A back reference to any
       subpattern is possible using named parentheses (see below).

       Another way of avoiding the ambiguity inherent in the use of digits
       following a backslash is to use the \g escape sequence, which is a
       feature introduced in Perl 5.10. This escape must be followed by an
       unsigned number or a negative number, optionally enclosed in braces.
       These examples are all identical:

         * (ring), \1

         * (ring), \g1

         * (ring), \g{1}

       An unsigned number specifies an absolute reference without the
       ambiguity that is present in the older syntax. It is also useful when
       literal digits follow the reference. A negative number is a relative
       reference. Consider this example:

       (abc(def)ghi)\g{-1}

       The sequence \g{-1} is a reference to the most recently started
       capturing subpattern before \g, that is, is it equivalent to \2.
       Similarly, \g{-2} would be equivalent to \1. The use of relative
       references can be helpful in long patterns, and also in patterns that
       are created by joining together fragments that contain references
       within themselves.

       A back reference matches whatever actually matched the capturing
       subpattern in the current subject string, rather than anything matching
       the subpattern itself (see "Subpatterns as subroutines" below for a way
       of doing that). So the pattern

       (sens|respons)e and \1ibility

       matches "sense and sensibility" and "response and responsibility", but
       not "sense and responsibility". If caseful matching is in force at the
       time of the back reference, the case of letters is relevant. For
       example,

       ((?i)rah)\s+\1

       matches "rah rah" and "RAH RAH", but not "RAH rah", even though the
       original capturing subpattern is matched caselessly.

       There are several different ways of writing back references to named
       subpatterns. The .NET syntax \k{name} and the Perl syntax \k<name> or
       \k'name' are supported, as is the Python syntax (?P=name). Perl 5.10's
       unified back reference syntax, in which \g can be used for both numeric
       and named references, is also supported. We could rewrite the above
       example in any of the following ways:

         * (?<p1>(?i)rah)\s+\k<p1>

         * (?'p1'(?i)rah)\s+\k{p1}

         * (?P<p1>(?i)rah)\s+(?P=p1)

         * (?<p1>(?i)rah)\s+\g{p1}

       A subpattern that is referenced by name may appear in the pattern
       before or after the reference.

       There may be more than one back reference to the same subpattern. If a
       subpattern has not actually been used in a particular match, any back
       references to it always fail. For example, the pattern

       (a|(bc))\2

       always fails if it starts to match "a" rather than "bc". Because there
       may be many capturing parentheses in a pattern, all digits following
       the backslash are taken as part of a potential back reference number.
       If the pattern continues with a digit character, some delimiter must be
       used to terminate the back reference. If the _e_x_t_e_n_d_e_d option is set,
       this can be whitespace. Otherwise an empty comment (see "Comments"
       below) can be used.

       A back reference that occurs inside the parentheses to which it refers
       fails when the subpattern is first used, so, for example, (a\1) never
       matches. However, such references can be useful inside repeated
       subpatterns. For example, the pattern

       (a|b\1)+

       matches any number of "a"s and also "aba", "ababbaa" etc. At each
       iteration of the subpattern, the back reference matches the character
       string corresponding to the previous iteration. In order for this to
       work, the pattern must be such that the first iteration does not need
       to match the back reference. This can be done using alternation, as in
       the example above, or by a quantifier with a minimum of zero.

AASSSSEERRTTIIOONNSS
       An assertion is a test on the characters following or preceding the
       current matching point that does not actually consume any characters.
       The simple assertions coded as \b, \B, \A, \G, \Z, \z, ^ and $ are
       described above.

       More complicated assertions are coded as subpatterns. There are two
       kinds: those that look ahead of the current position in the subject
       string, and those that look behind it. An assertion subpattern is
       matched in the normal way, except that it does not cause the current
       matching position to be changed.

       Assertion subpatterns are not capturing subpatterns, and may not be
       repeated, because it makes no sense to assert the same thing several
       times. If any kind of assertion contains capturing subpatterns within
       it, these are counted for the purposes of numbering the capturing
       subpatterns in the whole pattern. However, substring capturing is
       carried out only for positive assertions, because it does not make
       sense for negative assertions.

       _L_o_o_k_a_h_e_a_d _a_s_s_e_r_t_i_o_n_s

       Lookahead assertions start with (?= for positive assertions and (?! for
       negative assertions. For example,

       \w+(?=;)

       matches a word followed by a semicolon, but does not include the
       semicolon in the match, and

       foo(?!bar)

       matches any occurrence of "foo" that is not followed by "bar". Note
       that the apparently similar pattern

       (?!foo)bar

       does not find an occurrence of "bar" that is preceded by something
       other than "foo"; it finds any occurrence of "bar" whatsoever, because
       the assertion (?!foo) is always true when the next three characters are
       "bar". A lookbehind assertion is needed to achieve the other effect.

       If you want to force a matching failure at some point in a pattern, the
       most convenient way to do it is with (?!) because an empty string
       always matches, so an assertion that requires there not to be an empty
       string must always fail.

       _L_o_o_k_b_e_h_i_n_d _a_s_s_e_r_t_i_o_n_s

       Lookbehind assertions start with (?<= for positive assertions and (?<!
       for negative assertions. For example,

       (?<!foo)bar

       does find an occurrence of "bar" that is not preceded by "foo". The
       contents of a lookbehind assertion are restricted such that all the
       strings it matches must have a fixed length. However, if there are
       several top-level alternatives, they do not all have to have the same
       fixed length. Thus

       (?<=bullock|donkey)

       is permitted, but

       (?<!dogs?|cats?)

       causes an error at compile time. Branches that match different length
       strings are permitted only at the top level of a lookbehind assertion.
       This is an extension compared with Perl (at least for 5.8), which
       requires all branches to match the same length of string. An assertion
       such as

       (?<=ab(c|de))

       is not permitted, because its single top-level branch can match two
       different lengths, but it is acceptable if rewritten to use two top-
       level branches:

       (?<=abc|abde)

       In some cases, the Perl 5.10 escape sequence \K (see above) can be used
       instead of a lookbehind assertion; this is not restricted to a fixed-
       length.

       The implementation of lookbehind assertions is, for each alternative,
       to temporarily move the current position back by the fixed length and
       then try to match. If there are insufficient characters before the
       current position, the assertion fails.

       PCRE does not allow the \C escape (which matches a single byte in UTF-8
       mode) to appear in lookbehind assertions, because it makes it
       impossible to calculate the length of the lookbehind. The \X and \R
       escapes, which can match different numbers of bytes, are also not
       permitted.

       Possessive quantifiers can be used in conjunction with lookbehind
       assertions to specify efficient matching at the end of the subject
       string. Consider a simple pattern such as

       abcd$

       when applied to a long string that does not match. Because matching
       proceeds from left to right, PCRE will look for each "a" in the subject
       and then see if what follows matches the rest of the pattern. If the
       pattern is specified as

       ^.*abcd$

       the initial .* matches the entire string at first, but when this fails
       (because there is no following "a"), it backtracks to match all but the
       last character, then all but the last two characters, and so on. Once
       again the search for "a" covers the entire string, from right to left,
       so we are no better off. However, if the pattern is written as

       ^.*+(?<=abcd)

       there can be no backtracking for the .*+ item; it can match only the
       entire string. The subsequent lookbehind assertion does a single test
       on the last four characters. If it fails, the match fails immediately.
       For long strings, this approach makes a significant difference to the
       processing time.

       _U_s_i_n_g _m_u_l_t_i_p_l_e _a_s_s_e_r_t_i_o_n_s

       Several assertions (of any sort) may occur in succession. For example,

       (?<=\d{3})(?<!999)foo

       matches "foo" preceded by three digits that are not "999". Notice that
       each of the assertions is applied independently at the same point in
       the subject string. First there is a check that the previous three
       characters are all digits, and then there is a check that the same
       three characters are not "999". This pattern does _n_o_t match "foo"
       preceded by six characters, the first of which are digits and the last
       three of which are not "999". For example, it doesn't match
       "123abcfoo". A pattern to do that is

       (?<=\d{3}...)(?<!999)foo

       This time the first assertion looks at the preceding six characters,
       checking that the first three are digits, and then the second assertion
       checks that the preceding three characters are not "999".

       Assertions can be nested in any combination. For example,

       (?<=(?<!foo)bar)baz

       matches an occurrence of "baz" that is preceded by "bar" which in turn
       is not preceded by "foo", while

       (?<=\d{3}(?!999)...)foo

       is another pattern that matches "foo" preceded by three digits and any
       three characters that are not "999".

CCOONNDDIITTIIOONNAALL SSUUBBPPAATTTTEERRNNSS
       It is possible to cause the matching process to obey a subpattern
       conditionally or to choose between two alternative subpatterns,
       depending on the result of an assertion, or whether a previous
       capturing subpattern matched or not. The two possible forms of
       conditional subpattern are

         * (?(condition)yes-pattern)

         * (?(condition)yes-pattern|no-pattern)

       If the condition is satisfied, the yes-pattern is used; otherwise the
       no-pattern (if present) is used. If there are more than two
       alternatives in the subpattern, a compile-time error occurs.

       There are four kinds of condition: references to subpatterns,
       references to recursion, a pseudo-condition called DEFINE, and
       assertions.

       _C_h_e_c_k_i_n_g _f_o_r _a _u_s_e_d _s_u_b_p_a_t_t_e_r_n _b_y _n_u_m_b_e_r

       If the text between the parentheses consists of a sequence of digits,
       the condition is true if the capturing subpattern of that number has
       previously matched. An alternative notation is to precede the digits
       with a plus or minus sign. In this case, the subpattern number is
       relative rather than absolute. The most recently opened parentheses can
       be referenced by (?(-1), the next most recent by (?(-2), and so on. In
       looping constructs it can also make sense to refer to subsequent groups
       with constructs such as (?(+2).

       Consider the following pattern, which contains non-significant
       whitespace to make it more readable (assume the _e_x_t_e_n_d_e_d option) and to
       divide it into three parts for ease of discussion:

       ( \( )? [^()]+ (?(1) \) )

       The first part matches an optional opening parenthesis, and if that
       character is present, sets it as the first captured substring. The
       second part matches one or more characters that are not parentheses.
       The third part is a conditional subpattern that tests whether the first
       set of parentheses matched or not. If they did, that is, if subject
       started with an opening parenthesis, the condition is true, and so the
       yes-pattern is executed and a closing parenthesis is required.
       Otherwise, since no-pattern is not present, the subpattern matches
       nothing. In other words, this pattern matches a sequence of non-
       parentheses, optionally enclosed in parentheses.

       If you were embedding this pattern in a larger one, you could use a
       relative reference:

       ...other stuff... ( \( )? [^()]+ (?(-1) \) ) ...

       This makes the fragment independent of the parentheses in the larger
       pattern.

       _C_h_e_c_k_i_n_g _f_o_r _a _u_s_e_d _s_u_b_p_a_t_t_e_r_n _b_y _n_a_m_e

       Perl uses the syntax (?(<name>)...) or (?('name')...) to test for a
       used subpattern by name. For compatibility with earlier versions of
       PCRE, which had this facility before Perl, the syntax (?(name)...) is
       also recognized. However, there is a possible ambiguity with this
       syntax, because subpattern names may consist entirely of digits. PCRE
       looks first for a named subpattern; if it cannot find one and the name
       consists entirely of digits, PCRE looks for a subpattern of that
       number, which must be greater than zero. Using subpattern names that
       consist entirely of digits is not recommended.

       Rewriting the above example to use a named subpattern gives this:

       (?<OPEN> \( )? [^()]+ (?(<OPEN>) \) )

       _C_h_e_c_k_i_n_g _f_o_r _p_a_t_t_e_r_n _r_e_c_u_r_s_i_o_n

       If the condition is the string (R), and there is no subpattern with the
       name R, the condition is true if a recursive call to the whole pattern
       or any subpattern has been made. If digits or a name preceded by
       ampersand follow the letter R, for example:

       (?(R3)...) or (?(R&name)...)

       the condition is true if the most recent recursion is into the
       subpattern whose number or name is given. This condition does not check
       the entire recursion stack.

       At "top level", all these recursion test conditions are false.
       Recursive patterns are described below.

       _D_e_f_i_n_i_n_g _s_u_b_p_a_t_t_e_r_n_s _f_o_r _u_s_e _b_y _r_e_f_e_r_e_n_c_e _o_n_l_y

       If the condition is the string (DEFINE), and there is no subpattern
       with the name DEFINE, the condition is always false. In this case,
       there may be only one alternative in the subpattern. It is always
       skipped if control reaches this point in the pattern; the idea of
       DEFINE is that it can be used to define "subroutines" that can be
       referenced from elsewhere. (The use of "subroutines" is described
       below.) For example, a pattern to match an IPv4 address could be
       written like this (ignore whitespace and line breaks):

       (?(DEFINE) (?<byte> 2[0-4]\d | 25[0-5] | 1\d\d | [1-9]?\d) ) \b
       (?&byte) (\.(?&byte)){3} \b

       The first part of the pattern is a DEFINE group inside which a another
       group named "byte" is defined. This matches an individual component of
       an IPv4 address (a number less than 256). When matching takes place,
       this part of the pattern is skipped because DEFINE acts like a false
       condition.

       The rest of the pattern uses references to the named group to match the
       four dot-separated components of an IPv4 address, insisting on a word
       boundary at each end.

       _A_s_s_e_r_t_i_o_n _c_o_n_d_i_t_i_o_n_s

       If the condition is not in any of the above formats, it must be an
       assertion. This may be a positive or negative lookahead or lookbehind
       assertion. Consider this pattern, again containing non-significant
       whitespace, and with the two alternatives on the second line:

         (?(?=[^a-z]*[a-z])
         \d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )

       The condition is a positive lookahead assertion that matches an
       optional sequence of non-letters followed by a letter. In other words,
       it tests for the presence of at least one letter in the subject. If a
       letter is found, the subject is matched against the first alternative;
       otherwise it is matched against the second. This pattern matches
       strings in one of the two forms dd-aaa-dd or dd-dd-dd, where aaa are
       letters and dd are digits.

CCOOMMMMEENNTTSS
       The sequence (?# marks the start of a comment that continues up to the
       next closing parenthesis. Nested parentheses are not permitted. The
       characters that make up a comment play no part in the pattern matching
       at all.

       If the _e_x_t_e_n_d_e_d option is set, an unescaped # character outside a
       character class introduces a comment that continues to immediately
       after the next newline in the pattern.

RREECCUURRSSIIVVEE PPAATTTTEERRNNSS
       Consider the problem of matching a string in parentheses, allowing for
       unlimited nested parentheses. Without the use of recursion, the best
       that can be done is to use a pattern that matches up to some fixed
       depth of nesting. It is not possible to handle an arbitrary nesting
       depth.

       For some time, Perl has provided a facility that allows regular
       expressions to recurse (amongst other things). It does this by
       interpolating Perl code in the expression at run time, and the code can
       refer to the expression itself. A Perl pattern using code interpolation
       to solve the parentheses problem can be created like this:

       $re = qr{\( (?: (?>[^()]+) | (?p{$re}) )* \)}x;

       The (?p{...}) item interpolates Perl code at run time, and in this case
       refers recursively to the pattern in which it appears.

       Obviously, PCRE cannot support the interpolation of Perl code. Instead,
       it supports special syntax for recursion of the entire pattern, and
       also for individual subpattern recursion. After its introduction in
       PCRE and Python, this kind of recursion was introduced into Perl at
       release 5.10.

       A special item that consists of (? followed by a number greater than
       zero and a closing parenthesis is a recursive call of the subpattern of
       the given number, provided that it occurs inside that subpattern. (If
       not, it is a "subroutine" call, which is described in the next
       section.) The special item (?R) or (?0) is a recursive call of the
       entire regular expression.

       In PCRE (like Python, but unlike Perl), a recursive subpattern call is
       always treated as an atomic group. That is, once it has matched some of
       the subject string, it is never re-entered, even if it contains untried
       alternatives and there is a subsequent matching failure.

       This PCRE pattern solves the nested parentheses problem (assume the
       _e_x_t_e_n_d_e_d option is set so that whitespace is ignored):

       \( ( (?>[^()]+) | (?R) )* \)

       First it matches an opening parenthesis. Then it matches any number of
       substrings which can either be a sequence of non-parentheses, or a
       recursive match of the pattern itself (that is, a correctly
       parenthesized substring). Finally there is a closing parenthesis.

       If this were part of a larger pattern, you would not want to recurse
       the entire pattern, so instead you could use this:

       ( \( ( (?>[^()]+) | (?1) )* \) )

       We have put the pattern into parentheses, and caused the recursion to
       refer to them instead of the whole pattern.

       In a larger pattern, keeping track of parenthesis numbers can be
       tricky. This is made easier by the use of relative references. (A Perl
       5.10 feature.) Instead of (?1) in the pattern above you can write (?-2)
       to refer to the second most recently opened parentheses preceding the
       recursion. In other words, a negative number counts capturing
       parentheses leftwards from the point at which it is encountered.

       It is also possible to refer to subsequently opened parentheses, by
       writing references such as (?+2). However, these cannot be recursive
       because the reference is not inside the parentheses that are
       referenced. They are always "subroutine" calls, as described in the
       next section.

       An alternative approach is to use named parentheses instead. The Perl
       syntax for this is (?&name); PCRE's earlier syntax (?P>name) is also
       supported. We could rewrite the above example as follows:

       (?<pn> \( ( (?>[^()]+) | (?&pn) )* \) )

       If there is more than one subpattern with the same name, the earliest
       one is used.

       This particular example pattern that we have been looking at contains
       nested unlimited repeats, and so the use of atomic grouping for
       matching strings of non-parentheses is important when applying the
       pattern to strings that do not match. For example, when this pattern is
       applied to

       (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()

       it yields "no match" quickly. However, if atomic grouping is not used,
       the match runs for a very long time indeed because there are so many
       different ways the + and * repeats can carve up the subject, and all
       have to be tested before failure can be reported.

       At the end of a match, the values set for any capturing subpatterns are
       those from the outermost level of the recursion at which the subpattern
       value is set. If the pattern above is matched against

       (ab(cd)ef)

       the value for the capturing parentheses is "ef", which is the last
       value taken on at the top level. If additional parentheses are added,
       giving

         \( ( ( (?>[^()]+) | (?R) )* ) \)
            ^                        ^
            ^                        ^

       the string they capture is "ab(cd)ef", the contents of the top level
       parentheses.

       Do not confuse the (?R) item with the condition (R), which tests for
       recursion. Consider this pattern, which matches text in angle brackets,
       allowing for arbitrary nesting. Only digits are allowed in nested
       brackets (that is, when recursing), whereas any characters are
       permitted at the outer level.

       < (?: (?(R) \d++ | [^<>]*+) | (?R)) * >

       In this pattern, (?(R) is the start of a conditional subpattern, with
       two different alternatives for the recursive and non-recursive cases.
       The (?R) item is the actual recursive call.

SSUUBBPPAATTTTEERRNNSS AASS SSUUBBRROOUUTTIINNEESS
       If the syntax for a recursive subpattern reference (either by number or
       by name) is used outside the parentheses to which it refers, it
       operates like a subroutine in a programming language. The "called"
       subpattern may be defined before or after the reference. A numbered
       reference can be absolute or relative, as in these examples:

         * (...(absolute)...)...(?2)...

         * (...(relative)...)...(?-1)...

         * (...(?+1)...(relative)...

       An earlier example pointed out that the pattern

       (sens|respons)e and \1ibility

       matches "sense and sensibility" and "response and responsibility", but
       not "sense and responsibility". If instead the pattern

       (sens|respons)e and (?1)ibility

       is used, it does match "sense and responsibility" as well as the other
       two strings. Another example is given in the discussion of DEFINE
       above.

       Like recursive subpatterns, a "subroutine" call is always treated as an
       atomic group. That is, once it has matched some of the subject string,
       it is never re-entered, even if it contains untried alternatives and
       there is a subsequent matching failure.

       When a subpattern is used as a subroutine, processing options such as
       case-independence are fixed when the subpattern is defined. They cannot
       be changed for different calls. For example, consider this pattern:

       (abc)(?i:(?-1))

       It matches "abcabc". It does not match "abcABC" because the change of
       processing option does not affect the called subpattern.

BBAACCKKTTRRAACCKKIINNGG CCOONNTTRROOLL
       Perl 5.10 introduced a number of "Special Backtracking Control Verbs",
       which are described in the Perl documentation as "experimental and
       subject to change or removal in a future version of Perl". It goes on
       to say: "Their usage in production code should be noted to avoid
       problems during upgrades." The same remarks apply to the PCRE features
       described in this section.

       The new verbs make use of what was previously invalid syntax: an
       opening parenthesis followed by an asterisk. In Perl, they are
       generally of the form (*VERB:ARG) but PCRE does not support the use of
       arguments, so its general form is just (*VERB). Any number of these
       verbs may occur in a pattern. There are two kinds:

       _V_e_r_b_s _t_h_a_t _a_c_t _i_m_m_e_d_i_a_t_e_l_y

       The following verbs act as soon as they are encountered:

       (*ACCEPT)

       This verb causes the match to end successfully, skipping the remainder
       of the pattern. When inside a recursion, only the innermost pattern is
       ended immediately. PCRE differs from Perl in what happens if the
       (*ACCEPT) is inside capturing parentheses. In Perl, the data so far is
       captured: in PCRE no data is captured. For example:

       A(A|B(*ACCEPT)|C)D

       This matches "AB", "AAD", or "ACD", but when it matches "AB", no data
       is captured.

       (*FAIL) or (*F)

       This verb causes the match to fail, forcing backtracking to occur. It
       is equivalent to (?!) but easier to read. The Perl documentation notes
       that it is probably useful only when combined with (?{}) or (??{}).
       Those are, of course, Perl features that are not present in PCRE. The
       nearest equivalent is the callout feature, as for example in this
       pattern:

       a+(?C)(*FAIL)

       A match with the string "aaaa" always fails, but the callout is taken
       before each backtrack happens (in this example, 10 times).

       _V_e_r_b_s _t_h_a_t _a_c_t _a_f_t_e_r _b_a_c_k_t_r_a_c_k_i_n_g

       The following verbs do nothing when they are encountered. Matching
       continues with what follows, but if there is no subsequent match, a
       failure is forced. The verbs differ in exactly what kind of failure
       occurs.

       (*COMMIT)

       This verb causes the whole match to fail outright if the rest of the
       pattern does not match. Even if the pattern is unanchored, no further
       attempts to find a match by advancing the start point take place. Once
       (*COMMIT) has been passed, _r_e_:_r_u_n_/_3 is committed to finding a match at
       the current starting point, or not at all. For example:

       a+(*COMMIT)b

       This matches "xxaab" but not "aacaab". It can be thought of as a kind
       of dynamic anchor, or "I've started, so I must finish."

       (*PRUNE)

       This verb causes the match to fail at the current position if the rest
       of the pattern does not match. If the pattern is unanchored, the normal
       "bumpalong" advance to the next starting character then happens.
       Backtracking can occur as usual to the left of (*PRUNE), or when
       matching to the right of (*PRUNE), but if there is no match to the
       right, backtracking cannot cross (*PRUNE). In simple cases, the use of
       (*PRUNE) is just an alternative to an atomic group or possessive
       quantifier, but there are some uses of (*PRUNE) that cannot be
       expressed in any other way.

       (*SKIP)

       This verb is like (*PRUNE), except that if the pattern is unanchored,
       the "bumpalong" advance is not to the next character, but to the
       position in the subject where (*SKIP) was encountered. (*SKIP)
       signifies that whatever text was matched leading up to it cannot be
       part of a successful match. Consider:

       a+(*SKIP)b

       If the subject is "aaaac...", after the first match attempt fails
       (starting at the first character in the string), the starting point
       skips on to start the next attempt at "c". Note that a possessive
       quantifier does not have the same effect in this example; although it
       would suppress backtracking during the first match attempt, the second
       attempt would start at the second character instead of skipping on to
       "c".

       (*THEN)

       This verb causes a skip to the next alternation if the rest of the
       pattern does not match. That is, it cancels pending backtracking, but
       only within the current alternation. Its name comes from the
       observation that it can be used for a pattern-based if-then-else block:

       ( COND1 (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ ) ...

       If the COND1 pattern matches, FOO is tried (and possibly further items
       after the end of the group if FOO succeeds); on failure the matcher
       skips to the second alternative and tries COND2, without backtracking
       into COND1. If (*THEN) is used outside of any alternation, it acts
       exactly like (*PRUNE).



Ericsson AB                      stdlib 1.18.2                           re(3)
