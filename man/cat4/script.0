script(5)                            Files                           script(5)



NNAAMMEE
       script - Boot script

DDEESSCCRRIIPPTTIIOONN
       The _b_o_o_t _s_c_r_i_p_t describes how the Erlang runtime system is started. It
       contains instructions on which code to load and which processes and
       applications to start.

       The command _e_r_l _-_b_o_o_t _N_a_m_e starts the system with a boot file called
       _N_a_m_e_._b_o_o_t, which is generated from the _N_a_m_e_._s_c_r_i_p_t file, using
       _s_y_s_t_o_o_l_s_:_s_c_r_i_p_t_2_b_o_o_t_/_1.

       The _._s_c_r_i_p_t file is generated by _s_y_s_t_o_o_l_s from a _._r_e_l file and _._a_p_p
       files.

FFIILLEE SSYYNNTTAAXX
       The boot script is stored in a file with the extension _._s_c_r_i_p_t

       The file has the following syntax:

       {script, {Name, Vsn},
        [
         {progress, loading},
         {preLoaded, [Mod1, Mod2, ...]},
         {path, [Dir1,"$ROOT/Dir",...]}.
         {primLoad, [Mod1, Mod2, ...]},
         ...
         {kernel_load_completed},
         {progress, loaded},
         {kernelProcess, Name, {Mod, Func, Args}},
         ...
         {apply, {Mod, Func, Args}},
         ...
         {progress, started}]}.

         * _N_a_m_e _= _s_t_r_i_n_g_(_) defines the name of the system.

         * _V_s_n _= _s_t_r_i_n_g_(_) defines the version of the system.

         * _{_p_r_o_g_r_e_s_s_, _T_e_r_m_} sets the "progress" of the initialization program.
           The function _i_n_i_t_:_g_e_t___s_t_a_t_u_s_(_) returns the current value of the
           progress, which is _{_I_n_t_e_r_n_a_l_S_t_a_t_u_s_,_T_e_r_m_}.

         * _{_p_a_t_h_, _[_D_i_r_]_} where _D_i_r is a string. This argument sets the load
           path of the system to _[_D_i_r_]. The load path used to load modules is
           obtained from the initial load path, which is given in the script
           file, together with any path flags which were supplied in the
           command line arguments. The command line arguments modify the path
           as follows:

           * _-_p_a _D_i_r_1 _D_i_r_2 _._._. _D_i_r_N adds the directories _D_i_r_1_, _D_i_r_2_, _._._._, _D_i_r_N
             to the front of the initial load path.

           * _-_p_z _D_i_r_1 _D_i_r_2 _._._. _D_i_r_N adds the directories _D_i_r_1_, _D_i_r_2_, _._._._, _D_i_r_N
             to the end of the initial load path.

           * _-_p_a_t_h _D_i_r_1 _D_i_r_2 _._._. _D_i_r_N defines a set of directories _D_i_r_1_, _D_i_r_2_,
             _._._._, _D_i_r_N which replaces the search path given in the script
             file. Directory names in the path are interpreted as follows:

             * Directory names starting with _/ are assumed to be absolute path
               names.

             * Directory names not starting with _/ are assumed to be relative
               the current working directory.

             * The special _$_R_O_O_T variable can only be used in the script, not
               as a command line argument. The given directory is relative the
               Erlang installation directory.

         * _{_p_r_i_m_L_o_a_d_, _[_M_o_d_]_} loads the modules _[_M_o_d_] from the directories
           specified in _P_a_t_h. The script interpreter fetches the appropriate
           module by calling the function _e_r_l___p_r_i_m___l_o_a_d_e_r_:_g_e_t___f_i_l_e_(_M_o_d_). A
           fatal error which terminates the system will occur if the module
           cannot be located.

         * _{_k_e_r_n_e_l___l_o_a_d___c_o_m_p_l_e_t_e_d_} indicates that all modules which _m_u_s_t be
           loaded _b_e_f_o_r_e any processes are started are loaded. In interactive
           mode, all _{_p_r_i_m_L_o_a_d_,_[_M_o_d_]_} commands interpreted after this command
           are ignored, and these modules are loaded on demand. In embedded
           mode, _k_e_r_n_e_l___l_o_a_d___c_o_m_p_l_e_t_e_d is ignored, and all modules are loaded
           during system start.

         * _{_k_e_r_n_e_l_P_r_o_c_e_s_s_, _N_a_m_e_, _{_M_o_d_, _F_u_n_c_, _A_r_g_s_}_} starts a "kernel process".
           The kernel process _N_a_m_e is started by evaluating _a_p_p_l_y_(_M_o_d_, _F_u_n_c_,
           _A_r_g_s_) which is expected to return _{_o_k_, _P_i_d_} or _i_g_n_o_r_e. The _i_n_i_t
           process monitors the behaviour of _P_i_d and terminates the system if
           _P_i_d dies. Kernel processes are key components of the runtime
           system. Users do not normally add new kernel processes.

         * _{_a_p_p_l_y_, _{_M_o_d_, _F_u_n_c_, _A_r_g_s_}_}. The init process simply evaluates
           _a_p_p_l_y_(_M_o_d_, _F_u_n_c_, _A_r_g_s_). The system terminates if this results in an
           error. The boot procedure hangs if this function never returns.

   NNoottee::
       In the _i_n_t_e_r_a_c_t_i_v_e system the code loader provides demand driven code
       loading, but in the _e_m_b_e_d_d_e_d system the code loader loads all the code
       immediately. The same version of _c_o_d_e is used in both cases. The code
       server calls _i_n_i_t_:_g_e_t___a_r_g_u_m_e_n_t_(_m_o_d_e_) to find out if it should run in
       demand mode, or non-demand driven mode.


SSEEEE AALLSSOO
       systools(3)



Ericsson AB                       sasl 2.2.1                         script(5)
